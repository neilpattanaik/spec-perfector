#!/usr/bin/env bash
#
# apr - Automated Plan Reviser Pro (v1.2.0)
# Iterative specification refinement with GPT Pro Extended Reasoning via Oracle
#
# FEATURES:
#   - Beautiful gum-based terminal UI with graceful ANSI fallback
#   - Interactive workflow setup wizard
#   - Multi-round revision tracking with git integration
#   - GPT Pro 5.2 Extended Reasoning via Oracle browser automation
#   - Session monitoring and reattachment
#   - Configurable document bundles (README, spec, implementation)
#   - Automatic round output management and history tracking
#   - Self-update with checksum verification
#   - Daily update checking (opt-in)
#
# Usage:
#   apr [command] [options]
#
# Commands:
#   run <round>        Run a revision round (default command)
#   setup              Interactive workflow setup wizard
#   status             Check Oracle session status
#   attach <session>   Attach to a running/completed session
#   list               List all configured workflows
#   history            Show revision history for current workflow
#   dashboard          Interactive analytics dashboard (TUI)
#   backfill           Generate metrics from existing rounds
#   update             Check for and install updates
#   help               Show help message
#
# Options:
#   -w, --workflow     Workflow name (default: from .apr/config.yaml or 'default')
#   -i, --include-impl Include implementation document
#   -d, --dry-run      Preview without sending to GPT Pro
#   -r, --render       Render bundle for manual paste
#   -c, --copy         Copy rendered bundle to clipboard
#   --wait             Wait for completion (blocking)
#   --login            Manual login mode (first-time setup)
#   --keep-browser     Keep browser open after completion
#   --no-preflight     Skip pre-flight checks (not recommended)
#   --retry            Enable Oracle retries (default)
#   --no-retry         Disable Oracle retries
#   -q, --quiet        Minimal output (errors only)
#   -v, --verbose      Verbose logging (debug)
#   --version          Show version
#
# Environment Variables:
#   APR_HOME           Data directory (default: ~/.local/share/apr)
#   APR_CACHE          Cache directory (default: ~/.cache/apr)
#   APR_CHECK_UPDATES  Enable daily update check (set to 1)
#   APR_NO_GUM         Disable gum even if available
#   NO_COLOR           Disable colors (accessibility)
#
#   Oracle Stability Thresholds (prevent truncation with GPT Pro Extended Thinking):
#   APR_ORACLE_MIN_STABLE_MS     Min stability time for normal answers (default: 30000ms)
#   APR_ORACLE_SHORT_STABLE_MS   Min stability time for short answers (default: 15000ms)
#   APR_ORACLE_SETTLE_WINDOW_MS  Settle window for completion detection (default: 30000ms)
#   APR_ORACLE_STABLE_CYCLES     Required stable polling cycles (default: 12)
#   APR_NO_ORACLE_PATCH          Disable Oracle patching (set to 1)
#
# More info: https://github.com/Dicklesworthstone/automated_plan_reviser_pro

set -euo pipefail

VERSION="1.2.2"

# Metrics schema (analytics)
readonly METRICS_SCHEMA_VERSION="1.0.0"

# GitHub repository info for updates
readonly REPO_OWNER="Dicklesworthstone"
readonly REPO_NAME="automated_plan_reviser_pro"
readonly GITHUB_RAW="https://raw.githubusercontent.com"
readonly VERSION_URL="${GITHUB_RAW}/${REPO_OWNER}/${REPO_NAME}/main/VERSION"
readonly RELEASES_URL="https://github.com/${REPO_OWNER}/${REPO_NAME}/releases"

# -----------------------------------------------------------------------------
# Exit Codes (semantic, non-contiguous for future additions)
# -----------------------------------------------------------------------------
readonly EXIT_SUCCESS=0
# shellcheck disable=SC2034  # Reserved for future use
readonly EXIT_PARTIAL_FAILURE=1   # Some operations failed
readonly EXIT_USAGE_ERROR=2       # Bad arguments
readonly EXIT_DEPENDENCY_ERROR=3  # Missing Oracle, Node.js, etc.
readonly EXIT_CONFIG_ERROR=4      # Invalid config, missing files
readonly EXIT_NETWORK_ERROR=10    # Timeout, DNS, unreachable
readonly EXIT_UPDATE_ERROR=11     # Self-update failed
readonly EXIT_BUSY_ERROR=12       # Single-flight / busy (e.g. lock already held)

# -----------------------------------------------------------------------------
# Error code taxonomy (robot `.code`) and mapping to exit codes
# -----------------------------------------------------------------------------
# NOTE: Robot mode uses `.code` (string) as the stable, machine-readable failure
# class. Human mode should emit a grep-friendly stderr tag for fatal errors:
#   APR_ERROR_CODE=<code>
apr_emit_error_code_tag() {
    local code="${1:-internal_error}"
    # ASCII-only, stable tag for automation.
    printf 'APR_ERROR_CODE=%s\n' "$code" >&2
}

apr_exit_code_for_code() {
    local code="$1"
    case "$code" in
        ok) echo "$EXIT_SUCCESS" ;;
        usage_error) echo "$EXIT_USAGE_ERROR" ;;
        dependency_missing) echo "$EXIT_DEPENDENCY_ERROR" ;;
        not_configured|config_error|validation_failed|attachment_mismatch) echo "$EXIT_CONFIG_ERROR" ;;
        network_error) echo "$EXIT_NETWORK_ERROR" ;;
        update_error) echo "$EXIT_UPDATE_ERROR" ;;
        busy) echo "$EXIT_BUSY_ERROR" ;;
        not_implemented|internal_error) echo "$EXIT_PARTIAL_FAILURE" ;;
        *) echo "$EXIT_PARTIAL_FAILURE" ;;
    esac
}

# -----------------------------------------------------------------------------
# Colors (conditional on TTY and NO_COLOR)
# -----------------------------------------------------------------------------
# Respect NO_COLOR environment variable for accessibility
# Check stderr (-t 2) since all log output goes there
if [[ -t 2 ]] && [[ -z "${NO_COLOR:-}" ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    CYAN='\033[0;36m'
    MAGENTA='\033[0;35m'
    WHITE='\033[1;37m'
    BOLD='\033[1m'
    DIM='\033[2m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' CYAN='' MAGENTA='' WHITE='' BOLD='' DIM='' NC=''
fi

# Gum availability flag
GUM_AVAILABLE=false

# Quiet mode flag
QUIET_MODE=false

# Verbose mode flag (for debugging)
VERBOSE="${APR_VERBOSE:-false}"

# Configuration (XDG-compliant with overrides)
APR_HOME="${APR_HOME:-${XDG_DATA_HOME:-$HOME/.local/share}/apr}"
APR_CACHE="${APR_CACHE:-${XDG_CACHE_HOME:-$HOME/.cache}/apr}"
CONFIG_DIR=".apr"

# Oracle command (determined at runtime)
ORACLE_CMD=()

# Oracle feature detection (best-effort, set during preflight and other entrypoints)
ORACLE_SUPPORTS_NOTIFY=false
ORACLE_FEATURES_DETECTED=false

# Oracle stability thresholds (monkey-patch prevention for GPT Pro Extended Thinking truncation)
# GPT Pro can pause 10-30+ seconds during thinking, which Oracle misinterprets as completion.
# These thresholds are patched into Oracle's assistantResponse.js at runtime.
APR_ORACLE_MIN_STABLE_MS="${APR_ORACLE_MIN_STABLE_MS:-30000}"      # Min stable time for normal answers (default: 30s)
APR_ORACLE_SHORT_STABLE_MS="${APR_ORACLE_SHORT_STABLE_MS:-15000}"  # Min stable time for short answers (default: 15s)
APR_ORACLE_SETTLE_WINDOW_MS="${APR_ORACLE_SETTLE_WINDOW_MS:-30000}" # Settle window for normal answers (default: 30s)
APR_ORACLE_STABLE_CYCLES="${APR_ORACLE_STABLE_CYCLES:-12}"         # Required stable cycles for normal (default: 12)
APR_ORACLE_PATCHED=false                                           # Track if we've patched Oracle this session

# Validate Oracle threshold env vars are positive integers
for _apr_var in APR_ORACLE_MIN_STABLE_MS APR_ORACLE_SHORT_STABLE_MS APR_ORACLE_SETTLE_WINDOW_MS APR_ORACLE_STABLE_CYCLES; do
    _apr_val="${!_apr_var}"
    if ! [[ "$_apr_val" =~ ^[0-9]+$ ]] || [[ "$_apr_val" -eq 0 ]]; then
        echo "Warning: $_apr_var must be a positive integer, got '$_apr_val'. Using default." >&2
        case "$_apr_var" in
            APR_ORACLE_MIN_STABLE_MS) APR_ORACLE_MIN_STABLE_MS=30000 ;;
            APR_ORACLE_SHORT_STABLE_MS) APR_ORACLE_SHORT_STABLE_MS=15000 ;;
            APR_ORACLE_SETTLE_WINDOW_MS) APR_ORACLE_SETTLE_WINDOW_MS=30000 ;;
            APR_ORACLE_STABLE_CYCLES) APR_ORACLE_STABLE_CYCLES=12 ;;
        esac
    fi
done
unset _apr_var _apr_val

# Temp directory for cleanup on exit
APR_TEMP_DIR=""

# Dashboard state (best-effort terminal restoration on exit)
DASHBOARD_ACTIVE=false

# Cleanup function for trap
cleanup_temp() {
    # Release any held lock
    release_lock 2>/dev/null || true

    # Restore terminal state if we were in the interactive dashboard
    if [[ "${DASHBOARD_ACTIVE:-false}" == "true" && -t 2 ]]; then
        if declare -F dashboard_show_cursor >/dev/null; then
            dashboard_show_cursor 2>/dev/null || true
        fi
        if declare -F dashboard_clear >/dev/null; then
            dashboard_clear 2>/dev/null || true
        fi
        DASHBOARD_ACTIVE=false
    fi

    # Remove temp directory
    if [[ -n "$APR_TEMP_DIR" && -d "$APR_TEMP_DIR" ]]; then
        rm -rf -- "$APR_TEMP_DIR"
    fi
}

# Set trap for cleanup on exit/interrupt.
# Important: avoid clobbering caller traps when this file is sourced (e.g. unit tests).
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    trap cleanup_temp EXIT INT TERM
fi

# Lock file path (set when acquired)
APR_LOCK_FILE=""
APR_LOCK_FD=""

# Acquire a lock for a workflow/round to prevent concurrent runs
# Usage: acquire_lock workflow round
# Returns: 0 if acquired, 1 if already locked
acquire_lock() {
    local workflow="$1"
    local round="$2"
    local lock_dir="$CONFIG_DIR/.locks"
    if ! mkdir -p "$lock_dir" 2>/dev/null; then
        return 1
    fi

    local lock_path="$lock_dir/${workflow}_round_${round}.lock"

    # Use flock if available (preferred - atomic and robust)
    if command -v flock &>/dev/null; then
        # Open file descriptor without truncating. Only update the PID file after the lock is acquired,
        # otherwise failed attempts can clobber the running process' PID info.
        if ! exec {APR_LOCK_FD}<>"$lock_path"; then
            verbose "acquire_lock: failed to open FD for $lock_path"
            APR_LOCK_FD=""
            return 1
        fi
        if ! flock -n "$APR_LOCK_FD"; then
            verbose "acquire_lock: flock failed for FD $APR_LOCK_FD ($lock_path)"
            # Failed to acquire: close FD and return
            { exec {APR_LOCK_FD}>&-; } 2>/dev/null || true
            APR_LOCK_FD=""
            return 1
        fi
        # Success: update PID file content and set global path.
        : > "$lock_path" 2>/dev/null || true
        printf '%s\n' "$$" 1>&"$APR_LOCK_FD" 2>/dev/null || true
        APR_LOCK_FILE="$lock_path"
        verbose "acquire_lock: acquired flock on FD $APR_LOCK_FD ($lock_path)"
    else
        # Fallback: simple file-based locking
        # Try atomic creation first (noclobber)
        if (set -C; echo "$$" > "$lock_path") 2>/dev/null; then
            APR_LOCK_FILE="$lock_path"
            verbose "acquire_lock: acquired fallback lock ($lock_path)"
            return 0
        fi

        # File exists - check if stale
        local pid
        pid=$(cat "$lock_path" 2>/dev/null || echo "")
        # Check if the process is still running
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            verbose "acquire_lock: fallback lock held by PID $pid"
            return 1
        fi
        
        # Stale lock file - remove and retry once
        if ! rm -f "$lock_path" 2>/dev/null; then
            return 1
        fi
        if (set -C; echo "$$" > "$lock_path") 2>/dev/null; then
            APR_LOCK_FILE="$lock_path"
            verbose "acquire_lock: acquired fallback lock after stale cleanup"
            return 0
        fi
        return 1
    fi
    return 0
}

# Release the lock
release_lock() {
    if [[ -n "$APR_LOCK_FD" ]]; then
        verbose "release_lock: closing FD $APR_LOCK_FD"
        { exec {APR_LOCK_FD}>&-; } 2>/dev/null || true
        APR_LOCK_FD=""
    fi
    if [[ -n "$APR_LOCK_FILE" && -f "$APR_LOCK_FILE" ]]; then
        verbose "release_lock: removing file $APR_LOCK_FILE"
        rm -f "$APR_LOCK_FILE" 2>/dev/null || true
        APR_LOCK_FILE=""
    fi
}

# In background runs, keep the lock held by the background process and prevent
# the parent shell EXIT trap from releasing it prematurely.
background_lock_detach_parent() {
    local background_pid="$1"
    verbose "background_lock_detach_parent: pid=$background_pid"

    # If using file-based lock fallback (no flock), write the background PID so
    # stale detection doesn't treat the lock as dead when the parent exits.
    if [[ -z "$APR_LOCK_FD" && -n "$APR_LOCK_FILE" && -f "$APR_LOCK_FILE" ]]; then
        printf '%s\n' "$background_pid" > "$APR_LOCK_FILE" 2>/dev/null || true
    fi

    # Close parent's copy of the lock FD (if any) without removing the lock file.
    if [[ -n "$APR_LOCK_FD" ]]; then
        verbose "background_lock_detach_parent: closing parent FD $APR_LOCK_FD"
        { exec {APR_LOCK_FD}>&-; } 2>/dev/null || true
    fi

    APR_LOCK_FD=""
    APR_LOCK_FILE=""
}

# -----------------------------------------------------------------------------
# Utility Functions
# -----------------------------------------------------------------------------

# Compare semantic versions. Returns 0 if $1 > $2
version_gt() {
    local v1="$1" v2="$2"
    if [[ "$v1" == "$v2" ]]; then return 1; fi

    local IFS=.
    local ver1 ver2 i
    read -ra ver1 <<< "$v1"
    read -ra ver2 <<< "$v2"

    # Compare each segment
    for ((i=0; i<${#ver1[@]} || i<${#ver2[@]}; i++)); do
        local t1=${ver1[i]:-0}
        local t2=${ver2[i]:-0}
        
        # Strip non-numeric suffixes for comparison (e.g. 1.0.0-beta -> 1.0.0)
        # This is a simplified check for x.y.z format
        t1="${t1%%[!0-9]*}"
        t2="${t2%%[!0-9]*}"
        
        # Default to 0 if empty
        [[ -z "$t1" ]] && t1=0
        [[ -z "$t2" ]] && t2=0

        if ((10#$t1 > 10#$t2)); then return 0; fi
        if ((10#$t1 < 10#$t2)); then return 1; fi
    done
    return 1
}

# Check if we can prompt the user (interactive terminal)
can_prompt() {
    [[ -t 0 && -t 2 && "$QUIET_MODE" != "true" ]]
}

# ISO8601 timestamp (UTC)
iso_timestamp() {
    date -u +"%Y-%m-%dT%H:%M:%SZ"
}

is_non_negative_int() {
    [[ "${1:-}" =~ ^[0-9]+$ ]]
}

is_valid_workflow_name() {
    [[ "${1:-}" =~ ^[A-Za-z0-9_][A-Za-z0-9._-]*$ ]]
}

# -----------------------------------------------------------------------------
# Update Checking (Opt-In)
# -----------------------------------------------------------------------------

check_for_updates() {
    # Only check if explicitly enabled
    [[ -z "${APR_CHECK_UPDATES:-}" ]] && return 0

    local check_file="${APR_HOME}/.last_update_check"
    local one_day=86400

    # Ensure directory exists
    mkdir -p "$APR_HOME" 2>/dev/null || true

    # Check if we already checked today
    if [[ -f "$check_file" ]]; then
        local last_check now
        last_check=$(cat "$check_file" 2>/dev/null || echo "0")
        now=$(date +%s)
        if (( now - last_check < one_day )); then
            return 0  # Skip - already checked today
        fi
    fi

    # Show progress indicator if interactive
    [[ "$QUIET_MODE" != "true" ]] && print_dim "Checking for updates..." >&2

    # Fetch remote version with short timeout
    local remote_version=""
    if command -v curl &> /dev/null; then
        remote_version=$(curl -fsSL --connect-timeout 2 --max-time 5 "$VERSION_URL" 2>/dev/null | tr -d '[:space:]') || true
    elif command -v wget &> /dev/null; then
        remote_version=$(wget -q --timeout=5 -O - "$VERSION_URL" 2>/dev/null | tr -d '[:space:]') || true
    fi

    # Update timestamp regardless of result
    date +%s > "$check_file" 2>/dev/null || true

    # Compare versions and notify if update available
    if [[ -n "$remote_version" && "$remote_version" != "$VERSION" ]]; then
        if version_gt "$remote_version" "$VERSION"; then
            echo -e "${YELLOW}[apr]${NC} Update available: ${VERSION} → ${remote_version}" >&2
            echo -e "${DIM}      Run 'apr update' to install${NC}" >&2
        fi
    fi
}

# -----------------------------------------------------------------------------
# Self-Update Command
# -----------------------------------------------------------------------------

cmd_update() {
    print_banner

    print_header "CHECKING FOR UPDATES"
    echo "" >&2

    # Fetch latest version
    print_info "Fetching latest version info..."
    local remote_version=""
    if command -v curl &> /dev/null; then
        remote_version=$(curl -fsSL --connect-timeout 5 --max-time 10 "$VERSION_URL" 2>/dev/null | tr -d '[:space:]') || true
    elif command -v wget &> /dev/null; then
        remote_version=$(wget -q --timeout=10 -O - "$VERSION_URL" 2>/dev/null | tr -d '[:space:]') || true
    fi

    if [[ -z "$remote_version" ]]; then
        print_error "Failed to check for updates (network error)"
        exit $EXIT_NETWORK_ERROR
    fi

    # Basic sanity check: remote version must be a safe semver-like token (no spaces, slashes, etc.).
    if [[ ! "$remote_version" =~ ^[0-9]+(\\.[0-9]+)*([A-Za-z0-9._-]+)?$ ]]; then
        print_error "Remote version string is invalid: '$remote_version'"
        exit $EXIT_UPDATE_ERROR
    fi

    if [[ "$remote_version" == "$VERSION" ]]; then
        print_success "Already up to date (v${VERSION})"
        exit $EXIT_SUCCESS
    fi

    if ! version_gt "$remote_version" "$VERSION"; then
        print_info "Current version (v${VERSION}) is newer than remote (v${remote_version})"
        exit $EXIT_SUCCESS
    fi

    print_info "Update available: v${VERSION} → v${remote_version}"
    echo "" >&2

    # Prompt for confirmation if interactive
    if can_prompt; then
        if ! confirm "Install update?"; then
            print_info "Update cancelled"
            exit $EXIT_SUCCESS
        fi
    fi

    # Create temp directory (uses global for cleanup trap)
    APR_TEMP_DIR=$(mktemp -d 2>/dev/null || mktemp -d -t apr 2>/dev/null || echo "")
    if [[ -z "$APR_TEMP_DIR" || ! -d "$APR_TEMP_DIR" ]]; then
        print_error "Failed to create temp directory"
        exit $EXIT_UPDATE_ERROR
    fi
    local tmp_dir="$APR_TEMP_DIR"

    # Download new version
    print_info "Downloading v${remote_version}..."
    local download_url="${RELEASES_URL}/download/v${remote_version}/apr"
    local checksum_url="${RELEASES_URL}/download/v${remote_version}/apr.sha256"

    if command -v curl &> /dev/null; then
        curl -fsSL "$download_url" -o "$tmp_dir/apr" 2>/dev/null || {
            # Fallback to main branch if no release
            curl -fsSL "${GITHUB_RAW}/${REPO_OWNER}/${REPO_NAME}/main/apr" -o "$tmp_dir/apr" 2>/dev/null
        }
    elif command -v wget &> /dev/null; then
        wget -q "$download_url" -O "$tmp_dir/apr" 2>/dev/null || {
            wget -q "${GITHUB_RAW}/${REPO_OWNER}/${REPO_NAME}/main/apr" -O "$tmp_dir/apr" 2>/dev/null
        }
    fi

    if [[ ! -s "$tmp_dir/apr" ]]; then
        print_error "Failed to download update"
        rm -rf -- "$tmp_dir"
        exit $EXIT_UPDATE_ERROR
    fi

    # Verify it's a bash script (security check)
    local first_line=""
    IFS= read -r first_line < "$tmp_dir/apr" 2>/dev/null || true
    # Accept any valid bash shebang: #!/bin/bash, #!/usr/bin/env bash, etc.
    if [[ ! "$first_line" =~ ^#!.*bash ]]; then
        print_error "Downloaded file is not a valid apr script"
        print_dim "Expected bash shebang, got: $first_line"
        rm -rf -- "$tmp_dir"
        exit $EXIT_UPDATE_ERROR
    fi

    # Syntax check (security + reliability): ensure the downloaded script parses as bash.
    local syntax_err=""
    if ! bash -n "$tmp_dir/apr" 2>/dev/null; then
        syntax_err=$(bash -n "$tmp_dir/apr" 2>&1 || true)
        print_error "Downloaded file failed bash syntax check"
        [[ -n "$syntax_err" ]] && print_dim "$syntax_err"
        rm -rf -- "$tmp_dir"
        exit $EXIT_UPDATE_ERROR
    fi

    # Try to verify checksum (non-fatal if checksums not available)
    # Checksum file may be: just hash, or "hash  filename" (sha256sum format)
    local expected_checksum="" raw_checksum=""
    if command -v curl &> /dev/null; then
        raw_checksum=$(curl -fsSL "$checksum_url" 2>/dev/null) || true
    elif command -v wget &> /dev/null; then
        raw_checksum=$(wget -q -O - "$checksum_url" 2>/dev/null) || true
    fi
    # Extract just the hash (first field if space-separated, otherwise whole string)
    expected_checksum=$(echo "$raw_checksum" | awk '{print $1}' | tr -d '[:space:]')
    if [[ -n "$expected_checksum" && ! "$expected_checksum" =~ ^[0-9A-Fa-f]{64}$ ]]; then
        expected_checksum=""
    fi

    if [[ -n "$expected_checksum" ]]; then
        print_info "Verifying checksum..."
        local actual_checksum=""
        if command -v sha256sum &> /dev/null; then
            actual_checksum=$(sha256sum "$tmp_dir/apr" | cut -d' ' -f1)
        elif command -v shasum &> /dev/null; then
            actual_checksum=$(shasum -a 256 "$tmp_dir/apr" | cut -d' ' -f1)
        fi

        if [[ -n "$actual_checksum" && "$actual_checksum" != "$expected_checksum" ]]; then
            print_error "Checksum verification failed!"
            print_error "Expected: $expected_checksum"
            print_error "Got:      $actual_checksum"
            rm -rf -- "$tmp_dir"
            exit $EXIT_UPDATE_ERROR
        fi
        print_success "Checksum verified"
    else
        print_warning "Checksum not available (installing from main branch)"
    fi

    # Find where we're installed.
    # Note: when invoked via $PATH, $0/BASH_SOURCE[0] may be just "apr" (no slash),
    # so we must resolve via `command -v` first.
    local script_path="${BASH_SOURCE[0]}"
    if [[ "$script_path" != /* ]]; then
        if [[ "$script_path" == */* ]]; then
            local script_dir=""
            script_dir=$(cd "$(dirname "$script_path")" 2>/dev/null && pwd) || script_dir=""
            [[ -n "$script_dir" ]] && script_path="$script_dir/$(basename "$script_path")"
        else
            script_path=$(command -v -- "$script_path" 2>/dev/null || echo "$script_path")
        fi
    fi
    script_path=$(realpath "$script_path" 2>/dev/null || readlink -f "$script_path" 2>/dev/null || echo "$script_path")
    if [[ -z "$script_path" || ! -e "$script_path" ]]; then
        print_error "Cannot determine apr install path for update"
        print_info "Try running update via the full path to apr, or reinstall via install.sh"
        rm -rf -- "$tmp_dir"
        exit $EXIT_UPDATE_ERROR
    fi

    # Install update
    print_info "Installing to $script_path..."
    chmod +x "$tmp_dir/apr"

    if [[ -w "$script_path" ]]; then
        mv "$tmp_dir/apr" "$script_path"
    elif command -v sudo &> /dev/null; then
        sudo mv "$tmp_dir/apr" "$script_path"
    else
        print_error "Cannot write to $script_path (try running with sudo)"
        rm -rf -- "$tmp_dir"
        exit $EXIT_UPDATE_ERROR
    fi

    rm -rf -- "$tmp_dir"
    APR_TEMP_DIR=""  # Clear for trap
    print_success "Updated to v${remote_version}!"
}

# -----------------------------------------------------------------------------
# Gum Detection
# -----------------------------------------------------------------------------

check_gum() {
    # Respect APR_NO_GUM
    [[ -n "${APR_NO_GUM:-}" ]] && return 1
    # Suppress gum in CI / non-interactive environments (stream-safe output)
    [[ -n "${CI:-}" ]] && return 1
    [[ -n "${NO_COLOR:-}" ]] && return 1
    [[ -t 2 ]] || return 1

    if command -v gum &> /dev/null; then
        GUM_AVAILABLE=true
        return 0
    fi

    return 1
}

# -----------------------------------------------------------------------------
# Oracle Detection
# -----------------------------------------------------------------------------

check_oracle() {
    if command -v oracle &> /dev/null; then
        ORACLE_CMD=("oracle")
        return 0
    elif [[ -z "${APR_NO_NPX:-}" ]] && command -v npx &> /dev/null; then
        ORACLE_CMD=("npx" "-y" "@steipete/oracle")
        return 0
    else
        return 1
    fi
}

oracle_detect_features() {
    local mode="${1:-full}" # "full" (default) or "fast"

    # Only detect once per process unless explicitly reset.
    [[ "${ORACLE_FEATURES_DETECTED:-false}" == "true" ]] && return 0

    ORACLE_SUPPORTS_NOTIFY=false

    if [[ ${#ORACLE_CMD[@]} -eq 0 ]]; then
        return 1
    fi
    # Avoid noisy "command not found" output in dry-run placeholder scenarios.
    if ! command -v "${ORACLE_CMD[0]}" &>/dev/null; then
        return 1
    fi

    # In fast mode, avoid triggering `npx -y @steipete/oracle --help` during dry-runs,
    # which can unexpectedly download/install packages.
    if [[ "$mode" == "fast" && "${ORACLE_CMD[0]}" == "npx" ]]; then
        ORACLE_FEATURES_DETECTED=true
        verbose "oracle_detect_features: skipping --help probe for npx in fast mode"
        return 0
    fi

    # Check if --notify actually works with real commands (not just appears in help).
    # Oracle 0.8.4 has a bug where --notify appears in help but is rejected by the parser
    # when used with actual prompts. Test by checking if the flag produces an error.
    local _notify_test
    _notify_test=$("${ORACLE_CMD[@]}" -p "test" --notify --render 2>&1)
    if echo "$_notify_test" | /usr/bin/grep -q "unknown option"; then
        ORACLE_SUPPORTS_NOTIFY=false
        verbose "oracle_detect_features: Oracle --notify rejected by parser (Oracle bug)"
    else
        ORACLE_SUPPORTS_NOTIFY=true
        verbose "oracle_detect_features: Oracle supports --notify"
    fi

    ORACLE_FEATURES_DETECTED=true
}

# -----------------------------------------------------------------------------
# Oracle Stability Threshold Patching (GPT Pro Extended Thinking Fix)
# -----------------------------------------------------------------------------
# Oracle's browser automation detects "completion" when the response text stops
# changing. However, GPT Pro Extended Thinking can pause for 10-30+ seconds
# during its reasoning phase, which Oracle misinterprets as completion.
#
# This function patches Oracle's assistantResponse.js to use configurable
# stability thresholds that tolerate GPT Pro's thinking pauses.
#
# Original values (cause truncation):
#   minStableMs: 1200ms (normal), 8000ms (short)
#   settleWindowMs: 5000ms (normal), 12000ms (short)
#   stableCycles: 6 (normal), 12 (short)
#
# Patched values (configured via APR_ORACLE_* env vars):
#   minStableMs: APR_ORACLE_MIN_STABLE_MS (normal), APR_ORACLE_SHORT_STABLE_MS (short)
#   settleWindowMs: APR_ORACLE_SETTLE_WINDOW_MS (normal), 15000ms (short)
#   stableCycles: APR_ORACLE_STABLE_CYCLES (normal), 18 (short)
#
# NOTE: If Oracle is updated via npm, the backup may become stale.
# Run `apr --restore-oracle` or delete the .apr-backup file to re-patch.

ORACLE_ASSISTANT_RESPONSE_PATH=""
ORACLE_BACKUP_PATH=""

find_oracle_assistant_response() {
    # Find Oracle's assistantResponse.js in the npm installation
    local oracle_path=""

    # Try to find oracle binary location
    if command -v oracle &>/dev/null; then
        oracle_path=$(command -v oracle)
        # Resolve symlinks to find actual installation
        if [[ -L "$oracle_path" ]]; then
            oracle_path=$(readlink -f "$oracle_path" 2>/dev/null || realpath "$oracle_path" 2>/dev/null)
        fi
    fi

    # Find the node_modules root
    local node_modules=""
    if [[ -n "$oracle_path" ]]; then
        # Navigate from bin/oracle to lib/node_modules/@steipete/oracle
        local bin_dir
        bin_dir=$(dirname "$oracle_path")
        local prefix_dir
        prefix_dir=$(dirname "$bin_dir")
        node_modules="$prefix_dir/lib/node_modules"
    fi

    # Fallback: try npm root -g
    if [[ -z "$node_modules" ]] || [[ ! -d "$node_modules" ]]; then
        node_modules=$(npm root -g 2>/dev/null || echo "")
    fi

    if [[ -z "$node_modules" ]] || [[ ! -d "$node_modules" ]]; then
        verbose "find_oracle_assistant_response: Cannot find npm global node_modules"
        return 1
    fi

    local target_file="$node_modules/@steipete/oracle/dist/src/browser/actions/assistantResponse.js"
    if [[ -f "$target_file" ]]; then
        ORACLE_ASSISTANT_RESPONSE_PATH="$target_file"
        ORACLE_BACKUP_PATH="${target_file}.apr-backup"
        verbose "find_oracle_assistant_response: Found at $target_file"
        return 0
    fi

    verbose "find_oracle_assistant_response: assistantResponse.js not found at $target_file"
    return 1
}

patch_oracle_stability_thresholds() {
    # Skip if already patched this session
    if [[ "$APR_ORACLE_PATCHED" == "true" ]]; then
        verbose "patch_oracle_stability_thresholds: Already patched this session"
        return 0
    fi

    # Skip if user disabled patching
    if [[ "${APR_NO_ORACLE_PATCH:-}" == "1" ]]; then
        verbose "patch_oracle_stability_thresholds: Disabled via APR_NO_ORACLE_PATCH"
        return 0
    fi

    # Find the file to patch
    if ! find_oracle_assistant_response; then
        print_warning "Cannot find Oracle assistantResponse.js for stability patching"
        print_warning "GPT Pro Extended Thinking responses may be truncated"
        return 1
    fi

    # Check if file is already patched (look for our marker comment)
    if grep -q "APR_PATCHED_STABILITY_THRESHOLDS" "$ORACLE_ASSISTANT_RESPONSE_PATH" 2>/dev/null; then
        verbose "patch_oracle_stability_thresholds: Already patched (marker found)"
        APR_ORACLE_PATCHED=true
        return 0
    fi

    # Check if we can write to the file
    if [[ ! -w "$ORACLE_ASSISTANT_RESPONSE_PATH" ]]; then
        print_warning "Cannot write to Oracle assistantResponse.js (permission denied)"
        print_warning "Run with sudo or fix permissions: $ORACLE_ASSISTANT_RESPONSE_PATH"
        return 1
    fi

    verbose "patch_oracle_stability_thresholds: Patching $ORACLE_ASSISTANT_RESPONSE_PATH"

    # Create backup if it doesn't exist
    if [[ ! -f "$ORACLE_BACKUP_PATH" ]]; then
        cp "$ORACLE_ASSISTANT_RESPONSE_PATH" "$ORACLE_BACKUP_PATH"
        verbose "patch_oracle_stability_thresholds: Backup created at $ORACLE_BACKUP_PATH"
    fi

    # Apply patches using sed -i (in-place, more robust than echo piping)
    # Note: Using | as delimiter to avoid escaping issues with /

    # Patch 1: minStableMs in pollAssistantCompletion (line ~293)
    # Original: const minStableMs = shortAnswer ? 8000 : 1200;
    # Patched:  const minStableMs = shortAnswer ? 15000 : 30000; /* APR_PATCHED_STABILITY_THRESHOLDS */
    sed -i "s|const minStableMs = shortAnswer ? 8000 : 1200;|const minStableMs = shortAnswer ? ${APR_ORACLE_SHORT_STABLE_MS} : ${APR_ORACLE_MIN_STABLE_MS}; /* APR_PATCHED_STABILITY_THRESHOLDS */|g" "$ORACLE_ASSISTANT_RESPONSE_PATH"

    # Patch 2: requiredStableCycles in pollAssistantCompletion (line ~291)
    # Original: const requiredStableCycles = shortAnswer ? 12 : 6;
    # Patched:  const requiredStableCycles = shortAnswer ? 18 : 12;
    sed -i "s|const requiredStableCycles = shortAnswer ? 12 : 6;|const requiredStableCycles = shortAnswer ? 18 : ${APR_ORACLE_STABLE_CYCLES};|g" "$ORACLE_ASSISTANT_RESPONSE_PATH"

    # Patch 3: settleWindowMs in waitForSettle (line ~551)
    # Original: const settleWindowMs = shortAnswer ? 12_000 : 5_000;
    # Patched:  const settleWindowMs = shortAnswer ? 15_000 : 30_000;
    sed -i "s|const settleWindowMs = shortAnswer ? 12_000 : 5_000;|const settleWindowMs = shortAnswer ? 15_000 : ${APR_ORACLE_SETTLE_WINDOW_MS};|g" "$ORACLE_ASSISTANT_RESPONSE_PATH"

    # Patch 4: stableTarget in waitForSettle (line ~557)
    # Original: const stableTarget = shortAnswer ? 6 : 3;
    # Patched:  const stableTarget = shortAnswer ? 12 : 6;
    sed -i "s|const stableTarget = shortAnswer ? 6 : 3;|const stableTarget = shortAnswer ? 12 : 6;|g" "$ORACLE_ASSISTANT_RESPONSE_PATH"

    # Verify patch was applied
    if grep -q "APR_PATCHED_STABILITY_THRESHOLDS" "$ORACLE_ASSISTANT_RESPONSE_PATH" 2>/dev/null; then
        APR_ORACLE_PATCHED=true
        print_success "Patched Oracle stability thresholds for GPT Pro Extended Thinking"
        verbose "patch_oracle_stability_thresholds: Patch applied successfully"
        verbose "  minStableMs: ${APR_ORACLE_MIN_STABLE_MS}ms (normal), ${APR_ORACLE_SHORT_STABLE_MS}ms (short)"
        verbose "  settleWindowMs: ${APR_ORACLE_SETTLE_WINDOW_MS}ms"
        verbose "  stableCycles: ${APR_ORACLE_STABLE_CYCLES}"
        return 0
    else
        print_warning "Oracle patch may not have applied correctly"
        return 1
    fi
}

restore_oracle_from_backup() {
    # Restore Oracle's original assistantResponse.js from backup
    if [[ -z "$ORACLE_BACKUP_PATH" ]] || [[ -z "$ORACLE_ASSISTANT_RESPONSE_PATH" ]]; then
        find_oracle_assistant_response || return 1
    fi

    if [[ ! -f "$ORACLE_BACKUP_PATH" ]]; then
        print_error "No Oracle backup found at $ORACLE_BACKUP_PATH"
        return 1
    fi

    # Verify destination directory exists (Oracle might have been uninstalled)
    local dest_dir
    dest_dir=$(dirname "$ORACLE_ASSISTANT_RESPONSE_PATH")
    if [[ ! -d "$dest_dir" ]]; then
        print_error "Oracle installation directory not found: $dest_dir"
        print_error "Oracle may have been uninstalled. Backup preserved at: $ORACLE_BACKUP_PATH"
        return 1
    fi

    cp "$ORACLE_BACKUP_PATH" "$ORACLE_ASSISTANT_RESPONSE_PATH"
    APR_ORACLE_PATCHED=false
    print_success "Restored Oracle from backup"
    return 0
}

# -----------------------------------------------------------------------------
# Pre-flight Oracle Validation
# -----------------------------------------------------------------------------

# Run pre-flight checks before expensive Oracle runs
# Usage: preflight_check readme_path spec_path [impl_path]
# Returns: 0 if all checks pass, 1 if critical failure, 2 if warning only
preflight_check() {
    local readme_path="$1"
    local spec_path="$2"
    local impl_path="${3:-}"
    local has_warnings=false

    verbose "preflight_check: readme=$readme_path spec=$spec_path impl=${impl_path:-<none>}"

    print_info "Running pre-flight checks..."

    # Check Oracle availability
    if ! check_oracle; then
        print_error "Pre-flight failed: Oracle not available"
        return 1
    fi
    verbose "preflight: Oracle available via ${ORACLE_CMD[*]}"

    # Try to check Oracle health (quick version check)
    local oracle_version=""
    if oracle_version=$("${ORACLE_CMD[@]}" --version 2>/dev/null); then
        verbose "preflight: Oracle version: $oracle_version"
        print_success "Oracle available ($oracle_version)"
    else
        print_warning "Could not verify Oracle version (may still work)"
        has_warnings=true
    fi

    # Detect Oracle feature support (--notify may not exist in older versions)
    oracle_detect_features || true

    # Patch Oracle stability thresholds to prevent GPT Pro Extended Thinking truncation
    # This is critical for reliable spec revision - without it, responses are often cut off mid-sentence
    if ! patch_oracle_stability_thresholds; then
        print_warning "Oracle stability patch failed - responses may be truncated"
        print_warning "Set APR_NO_ORACLE_PATCH=1 to disable this warning"
        has_warnings=true
    fi

    # Check source files exist and are readable
    if [[ ! -f "$readme_path" ]]; then
        print_error "Pre-flight failed: README not found: $readme_path"
        return 1
    fi
    if [[ ! -r "$readme_path" ]]; then
        print_error "Pre-flight failed: README not readable: $readme_path"
        return 1
    fi
    local readme_size
    readme_size=$(du -h "$readme_path" 2>/dev/null | cut -f1)
    verbose "preflight: README exists: $readme_path ($readme_size)"
    print_success "README: $readme_path ($readme_size)"
    local readme_bytes
    readme_bytes=$(wc -c < "$readme_path" 2>/dev/null || echo "0")
    if [[ "$readme_bytes" -eq 0 ]]; then
        print_error "Pre-flight failed: README is empty: $readme_path"
        return 1
    fi
    if [[ "$readme_bytes" -lt 64 ]]; then
        print_warning "README is suspiciously small (${readme_bytes} bytes): $readme_path"
        has_warnings=true
    fi

    if [[ ! -f "$spec_path" ]]; then
        print_error "Pre-flight failed: Spec not found: $spec_path"
        return 1
    fi
    if [[ ! -r "$spec_path" ]]; then
        print_error "Pre-flight failed: Spec not readable: $spec_path"
        return 1
    fi
    local spec_size
    spec_size=$(du -h "$spec_path" 2>/dev/null | cut -f1)
    verbose "preflight: Spec exists: $spec_path ($spec_size)"
    print_success "Spec: $spec_path ($spec_size)"
    local spec_bytes
    spec_bytes=$(wc -c < "$spec_path" 2>/dev/null || echo "0")
    if [[ "$spec_bytes" -eq 0 ]]; then
        print_error "Pre-flight failed: Spec is empty: $spec_path"
        return 1
    fi
    if [[ "$spec_bytes" -lt 64 ]]; then
        print_warning "Spec is suspiciously small (${spec_bytes} bytes): $spec_path"
        has_warnings=true
    fi

    # Check implementation file if provided
    if [[ -n "$impl_path" ]]; then
        if [[ ! -f "$impl_path" ]]; then
            print_warning "Implementation not found: $impl_path (will be skipped)"
            has_warnings=true
        elif [[ ! -r "$impl_path" ]]; then
            print_warning "Implementation not readable: $impl_path (will be skipped)"
            has_warnings=true
        else
            local impl_size
            impl_size=$(du -h "$impl_path" 2>/dev/null | cut -f1)
            verbose "preflight: Implementation exists: $impl_path ($impl_size)"
            print_success "Implementation: $impl_path ($impl_size)"
            local impl_bytes
            impl_bytes=$(wc -c < "$impl_path" 2>/dev/null || echo "0")
            if [[ "$impl_bytes" -eq 0 ]]; then
                print_error "Pre-flight failed: Implementation is empty: $impl_path"
                return 1
            fi
            if [[ "$impl_bytes" -lt 64 ]]; then
                print_warning "Implementation is suspiciously small (${impl_bytes} bytes): $impl_path"
                has_warnings=true
            fi
        fi
    fi

    echo "" >&2
    if [[ "$has_warnings" == "true" ]]; then
        print_warning "Pre-flight completed with warnings"
        return 2
    else
        print_success "All pre-flight checks passed"
        return 0
    fi
}

# -----------------------------------------------------------------------------
# Prompt Quality Controls
# -----------------------------------------------------------------------------
#
# Browser automation runs are expensive and slow. We fail fast on common
# "how did that even happen?" mistakes and produce actionable errors.

PROMPT_QC_REASON=""
PROMPT_QC_DETAILS=""

# Validate that the prompt we send to Oracle/ChatGPT does not contain obvious
# unexpanded placeholders (e.g. {{README}}). APR does NOT expand mustache-style
# placeholders; if they appear here, the model will see them verbatim.
#
# Usage:
#   prompt_quality_check "$prompt" "$config_path" "label"
#
# Returns:
#   0 if OK
#   1 if fatal (PROMPT_QC_REASON + PROMPT_QC_DETAILS set)
prompt_quality_check() {
    local prompt="$1"
    local config_path="${2:-}"
    local label="${3:-prompt}"

    PROMPT_QC_REASON=""
    PROMPT_QC_DETAILS=""

    # Escape hatch for advanced use (default is strict).
    if [[ "${APR_ALLOW_CURLY_PLACEHOLDERS:-}" == "1" ]]; then
        return 0
    fi

    # Guard: '{{' / '}}' in the prompt almost always means "expected substitution"
    # but nothing will substitute it.
    if printf '%s' "$prompt" | /usr/bin/grep -Fq '{{' || printf '%s' "$prompt" | /usr/bin/grep -Fq '}}'; then
        PROMPT_QC_REASON="Prompt contains unexpanded placeholders ('{{' / '}}'). APR does not substitute these."

        local prompt_hits cfg_hits
        prompt_hits=$(printf '%s\n' "$prompt" | awk -v label="$label" 'index($0,"{{") || index($0,"}}") { printf "  %s:%d: %s\n", label, NR, $0 }' | head -n 8)

        cfg_hits=""
        if [[ -n "$config_path" && -f "$config_path" ]]; then
            cfg_hits=$(awk 'index($0,"{{") || index($0,"}}") { printf "  %s:%d: %s\n", FILENAME, NR, $0 }' "$config_path" | head -n 8)
        fi

        PROMPT_QC_DETAILS=$(
            cat <<EOF
Why this fails:
- The model will literally see "{{README}}" instead of the README contents.
- APR already attaches the files via Oracle; the prompt should reference them by name.

Fix:
- Remove {{...}} placeholders from your workflow templates.
- Replace with instructions like: "Read the attached README.md" / "Read the attached spec file".

Offending lines:
${prompt_hits:-  (no prompt hits captured)}

Config hits:
${cfg_hits:-  (no config hits captured)}

Override (not recommended):
- Set APR_ALLOW_CURLY_PLACEHOLDERS=1 to bypass this guard.
EOF
        )

        return 1
    fi

    return 0
}

# -----------------------------------------------------------------------------
# Auto-Retry with Exponential Backoff
# -----------------------------------------------------------------------------

# Maximum retry attempts
MAX_RETRY_ATTEMPTS="${APR_MAX_RETRIES:-3}"
# Initial backoff in seconds
INITIAL_BACKOFF="${APR_INITIAL_BACKOFF:-10}"

# Validate retry configuration to avoid integer-comparison crashes when env vars are invalid.
# - MAX_RETRY_ATTEMPTS must be >= 1
# - INITIAL_BACKOFF may be 0 (useful for tests / instant retries)
if ! is_non_negative_int "$MAX_RETRY_ATTEMPTS" || [[ "$MAX_RETRY_ATTEMPTS" -lt 1 ]]; then
    MAX_RETRY_ATTEMPTS=3
fi
if ! is_non_negative_int "$INITIAL_BACKOFF"; then
    INITIAL_BACKOFF=10
fi

# Run Oracle with auto-retry on transient failures
# Usage: run_oracle_with_retry oracle_args...
# Returns: Oracle exit code
run_oracle_with_retry() {
    local attempt=1
    local backoff="$INITIAL_BACKOFF"
    local exit_code=0

    verbose "run_oracle_with_retry: max_attempts=$MAX_RETRY_ATTEMPTS initial_backoff=$INITIAL_BACKOFF"

    while [[ $attempt -le $MAX_RETRY_ATTEMPTS ]]; do
        verbose "Oracle attempt $attempt/$MAX_RETRY_ATTEMPTS"

        # Run Oracle command
        set +e
        "${ORACLE_CMD[@]}" "$@"
        exit_code=$?
        set -e

        verbose "Oracle attempt $attempt exit_code=$exit_code"

        # Success - return immediately
        if [[ $exit_code -eq 0 ]]; then
            return 0
        fi

        # Check if this is a retryable error
        # Exit codes: typically network/transient issues are specific codes
        # For now, we'll retry on any non-zero exit if we have attempts left
        if [[ $attempt -lt $MAX_RETRY_ATTEMPTS ]]; then
            print_warning "Attempt $attempt/$MAX_RETRY_ATTEMPTS failed (exit code: $exit_code)"
            print_info "Retrying in ${backoff}s..."
            sleep "$backoff"
            # Exponential backoff: 10s, 30s, 90s
            backoff=$((backoff * 3))
        fi

        ((attempt++))
    done

    print_error "All $MAX_RETRY_ATTEMPTS attempts failed"
    return "$exit_code"
}

# -----------------------------------------------------------------------------
# Output Validation
# -----------------------------------------------------------------------------
# Validates Oracle output file for completeness.
# Returns 0 if valid, 1 if truncated/incomplete.
# Sets OUTPUT_VALIDATION_REASON with explanation.

OUTPUT_VALIDATION_REASON=""

# Minimum expected size for a revision round output (in bytes)
# GPT Pro Extended Reasoning typically produces 10KB+ for spec reviews
readonly MIN_OUTPUT_SIZE_BYTES=2048

validate_output_file() {
    local output_file="$1"
    OUTPUT_VALIDATION_REASON=""

    # Check if file exists
    if [[ ! -f "$output_file" ]]; then
        OUTPUT_VALIDATION_REASON="Output file does not exist"
        return 1
    fi

    # Check if file is empty
    local file_size
    file_size=$(wc -c < "$output_file" 2>/dev/null || echo "0")
    if [[ "$file_size" -eq 0 ]]; then
        OUTPUT_VALIDATION_REASON="Output file is empty"
        return 1
    fi

    # Check if file is suspiciously small
    if [[ "$file_size" -lt "$MIN_OUTPUT_SIZE_BYTES" ]]; then
        OUTPUT_VALIDATION_REASON="Output file is suspiciously small (${file_size} bytes, expected >=${MIN_OUTPUT_SIZE_BYTES})"
        return 1
    fi

    # Check if file ends mid-word (truncation indicator)
    # A properly completed response should end with punctuation, newline, or code block
    local last_chars
    last_chars=$(tail -c 50 "$output_file" 2>/dev/null | tr -d '\n\r\t ')
    if [[ -n "$last_chars" ]]; then
        local last_char="${last_chars: -1}"
        # Valid endings: punctuation, quotes, brackets, backticks
        if [[ ! "$last_char" =~ [.!?\)\]\}\"\'\`\>] ]]; then
            # Check if it ends mid-word (letter followed by nothing)
            if [[ "$last_char" =~ [a-zA-Z] ]]; then
                # Read the last 100 chars to see if we're mid-sentence
                local context
                context=$(tail -c 100 "$output_file" 2>/dev/null)
                # If there's no sentence-ending punctuation in the last 100 chars, likely truncated
                if [[ ! "$context" =~ [.!?]$ ]] && [[ ! "$context" =~ \`\`\`$ ]]; then
                    OUTPUT_VALIDATION_REASON="Output appears truncated (ends mid-word: '...${last_chars: -20}')"
                    return 1
                fi
            fi
        fi
    fi

    # Output looks valid
    return 0
}

# -----------------------------------------------------------------------------
# Styled Output Functions
# -----------------------------------------------------------------------------

print_banner() {
    [[ "$QUIET_MODE" == "true" ]] && return

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style \
            --border double \
            --border-foreground 212 \
            --padding "0 2" \
            --margin "1 0" \
            --bold \
            --foreground 212 \
            "  Automated Plan Reviser Pro v${VERSION}" \
            "  Iterative AI-Powered Spec Refinement" >&2
    else
        # Get terminal width, default to 60 if unavailable
        local term_width
        term_width=$(tput cols 2>/dev/null || echo "60")
        # Cap at 60 for aesthetics
        (( term_width > 60 )) && term_width=60
        # Minimum width for readability
        (( term_width < 40 )) && term_width=40

        # Generate border of appropriate width
        local border=""
        for ((i=0; i<term_width; i++)); do
            border+="━"
        done

        echo "" >&2
        echo -e "${BOLD}${MAGENTA}${border}${NC}" >&2
        echo -e "  ${BOLD}${WHITE}Automated Plan Reviser Pro${NC} ${DIM}v${VERSION}${NC}" >&2
        echo -e "  ${DIM}Iterative AI-Powered Spec Refinement${NC}" >&2
        echo -e "${BOLD}${MAGENTA}${border}${NC}" >&2
        echo "" >&2
    fi
}

print_header() {
    [[ "$QUIET_MODE" == "true" ]] && return
    local text="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 214 --bold "$text" >&2
    else
        echo -e "${BOLD}${YELLOW}$text${NC}" >&2
    fi
}

print_success() {
    [[ "$QUIET_MODE" == "true" ]] && return
    local text="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 82 "✓ $text" >&2
    else
        echo -e "${GREEN}✓${NC} $text" >&2
    fi
}

print_error() {
    local text="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 196 "✗ $text" >&2
    else
        echo -e "${RED}✗${NC} $text" >&2
    fi
}

print_warning() {
    local text="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 214 "⚠ $text" >&2
    else
        echo -e "${YELLOW}⚠${NC} $text" >&2
    fi
}

print_info() {
    [[ "$QUIET_MODE" == "true" ]] && return
    local text="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 39 "ℹ $text" >&2
    else
        echo -e "${CYAN}ℹ${NC} $text" >&2
    fi
}

print_dim() {
    [[ "$QUIET_MODE" == "true" ]] && return
    local text="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --faint "$text" >&2
    else
        echo -e "${DIM}$text${NC}" >&2
    fi
}

# Verbose logging (only shown when VERBOSE=true or --verbose flag)
verbose() {
    [[ "$VERBOSE" != "true" ]] && return
    echo -e "${DIM}[apr:verbose]${NC} $*" >&2
}

print_step() {
    [[ "$QUIET_MODE" == "true" ]] && return
    local step="$1"
    local total="$2"
    local text="$3"
    local optional="${4:-}"  # Pass "optional" for optional steps

    local step_label="[$step/$total]"
    if [[ "$optional" == "optional" ]]; then
        step_label="[Optional]"
    fi

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        echo "$(gum style --foreground 212 --bold "$step_label") $(gum style --faint "$text")" >&2
    else
        echo -e "${BOLD}${MAGENTA}${step_label}${NC} ${DIM}$text${NC}" >&2
    fi
}

spin() {
    local text="$1"
    shift
    if [[ "$GUM_AVAILABLE" == "true" && "$QUIET_MODE" != "true" ]]; then
        gum spin --spinner dot --title "$text" -- "$@"
    else
        [[ "$QUIET_MODE" != "true" ]] && echo -e "${CYAN}→${NC} $text" >&2
        "$@"
    fi
}

confirm() {
    local prompt="$1"
    local default="${2:-false}"

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum confirm "$prompt"
    else
        if ! can_prompt; then
            [[ "$default" == "true" ]]
            return $?
        fi

        local yn
        if [[ "$default" == "true" ]]; then
            read -rp "$prompt [Y/n] " yn
            case "${yn,,}" in
                n|no) return 1 ;;
                *) return 0 ;;
            esac
        else
            read -rp "$prompt [y/N] " yn
            case "${yn,,}" in
                y|yes) return 0 ;;
                *) return 1 ;;
            esac
        fi
    fi
}

choose() {
    local prompt="$1"
    local choice=""
    shift
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum choose --header "$prompt" "$@"
    else
        echo "$prompt" >&2
        local i=1
        for opt in "$@"; do
            echo "  $i) $opt" >&2
            ((i++))
        done
        read -rp "Enter number: " choice
        local idx=1
        for opt in "$@"; do
            if [[ "$idx" == "$choice" ]]; then
                echo "$opt"
                return 0
            fi
            ((idx++))
        done
        echo "$1"  # default to first
    fi
}

input() {
    local prompt="$1"
    local default="${2:-}"
    local value=""
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        if [[ -n "$default" ]]; then
            gum input --placeholder "$default" --prompt "$prompt: " --value "$default"
        else
            gum input --prompt "$prompt: "
        fi
    else
        if [[ -n "$default" ]]; then
            read -rp "$prompt [$default]: " value
            echo "${value:-$default}"
        else
            read -rp "$prompt: " value
            echo "$value"
        fi
    fi
}

file_picker() {
    local prompt="$1"
    local path=""
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        # Don't use --all to hide hidden files (.git, .apr, etc.)
        # Use --height for better folder visibility and --show-help for navigation hints
        # Users can navigate into directories by pressing Enter on them
        gum file --file --header "$prompt" --height 20 --show-help
    else
        read -rp "$prompt (enter path): " path
        echo "$path"
    fi
}

# -----------------------------------------------------------------------------
# Configuration Management
# -----------------------------------------------------------------------------

# Show first-run welcome message for users who haven't set up yet
show_first_run_welcome() {
    print_banner
    echo "" >&2
    print_header "WELCOME TO APR!"
    echo "" >&2
    echo "  APR automates iterative specification refinement using" >&2
    echo "  GPT Pro Extended Reasoning via Oracle." >&2
    echo "" >&2
    print_info "To get started, run the setup wizard:"
    echo "" >&2
    echo -e "    ${CYAN}apr setup${NC}" >&2
    echo "" >&2
    print_dim "This will configure your workflow and document paths."
    print_dim "For full documentation, run 'apr help'."
    echo "" >&2
}

ensure_config_dir() {
    mkdir -p "$CONFIG_DIR"
    mkdir -p "$CONFIG_DIR/workflows"
    mkdir -p "$CONFIG_DIR/rounds"
}

load_config() {
    local workflow="${1:-default}"
    local config_path="$CONFIG_DIR/workflows/$workflow.yaml"

    if [[ ! -f "$config_path" ]]; then
        config_path="$CONFIG_DIR/config.yaml"
    fi

    if [[ ! -f "$config_path" ]]; then
        return 1
    fi

    echo "$config_path"
}

get_config_value() {
    local key="$1"
    local config_file="$2"
    # Handle both top-level and nested YAML keys while ignoring block scalar content.
    awk -v key="$key" '
        function indent_len(line) { match(line, /^[[:space:]]*/); return RLENGTH }
        BEGIN { in_block = 0; block_indent = 0 }
        {
            if (in_block) {
                if ($0 ~ /^[[:space:]]*$/) {
                    next
                }
                if (indent_len($0) <= block_indent) {
                    in_block = 0
                } else {
                    next
                }
            }
            if ($0 ~ /^[[:space:]]*[^#][^:]*:[[:space:]]*[|>][-+]?[[:space:]]*(#.*)?$/) {
                block_indent = indent_len($0)
                in_block = 1
                next
            }
            if ($0 ~ "^[[:space:]]*" key ":[[:space:]]*") {
                line = $0
                sub("^[[:space:]]*" key ":[[:space:]]*", "", line)
                sub(/[[:space:]]*$/, "", line)
                if (line !~ /^["\047]/) {
                    sub(/[[:space:]]+#.*$/, "", line)
                    sub(/[[:space:]]*$/, "", line)
                }
                print line
                exit
            }
        }
    ' "$config_file"
}

# Quote a scalar value for YAML (double-quoted).
yaml_quote() {
    local value="$1"
    value=${value//\\/\\\\}
    value=${value//\"/\\\"}
    printf '"%s"' "$value"
}

yaml_unquote() {
    local value="$1"
    if [[ "$value" == \"*\" && "$value" == *\" ]]; then
        value=${value#\"}
        value=${value%\"}
        value=${value//\\\"/\"}
        value=${value//\\\\/\\}
    elif [[ "$value" == \'* && "$value" == *\' ]]; then
        value=${value#\'}
        value=${value%\'}
        value=${value//"''"/"'"}
    fi
    printf '%s' "$value"
}

# Normalize YAML boolean strings with a default-true policy.
# Empty or unknown values resolve to "true"; explicit false-like values disable.
config_bool_default_true() {
    local raw="${1:-}"
    local normalized=""
    normalized=$(printf '%s' "$raw" | tr '[:upper:]' '[:lower:]')
    case "$normalized" in
        ""|true|1|yes|on)
            printf 'true'
            ;;
        false|0|no|off)
            printf 'false'
            ;;
        *)
            printf 'true'
            ;;
    esac
}

# Extract a YAML block scalar (| or >) for a given key.
# Returns block contents via stdout, or empty if not found.
get_yaml_block() {
    local key="$1"
    local config_file="$2"

    awk -v key="$key" '
        BEGIN {
            found = 0
            indent_len = 0
            indent = ""
        }
        {
            if (!found) {
                if ($0 ~ "^[[:space:]]*" key ":[[:space:]]*[|>][-+]?[[:space:]]*(#.*)?$") {
                    found = 1
                    next
                }
            } else {
                if ($0 ~ /^[[:space:]]*$/) {
                    print ""
                    next
                }
                if (indent_len == 0) {
                    if ($0 ~ /^[[:space:]]*$/) {
                        print ""
                        next
                    }
                    match($0, /^[[:space:]]+/)
                    if (RLENGTH == 0) {
                        exit
                    }
                    indent_len = RLENGTH
                    indent = substr($0, 1, indent_len)
                }
                match($0, /^[[:space:]]+/)
                if (RLENGTH < indent_len) {
                    exit
                }
                line = $0
                sub("^" indent, "", line)
                print line
            }
        }
    ' "$config_file"
}

load_prompt_template() {
    local include_impl="$1"
    local config_file="$2"
    local template=""

    if [[ -z "$config_file" || ! -f "$config_file" ]]; then
        return 0
    fi

    if [[ "$include_impl" == "true" ]]; then
        template=$(get_yaml_block "template_with_impl" "$config_file")
    fi

    if [[ -z "$template" ]]; then
        template=$(get_yaml_block "template" "$config_file")
    fi

    printf '%s' "$template"
}

# Build the revision prompt for GPT Pro review
# Usage: build_revision_prompt [include_impl]
# Returns prompt via stdout
build_revision_prompt() {
    local include_impl="${1:-false}"
    local config_file="${2:-}"
    local template=""

    template=$(load_prompt_template "$include_impl" "$config_file")
    if [[ -n "$template" ]]; then
        printf '%s\n' "$template"
        return 0
    fi

    local prompt="First, read this README:

\`\`\`
<contents of README will be included by oracle>
\`\`\`

---
"

    if [[ "$include_impl" == "true" ]]; then
        prompt+="
And here is a document detailing the implementation; you should also keep
the implementation in mind as you think about the specification, since
ultimately the specification needs to be translated into code eventually!

\`\`\`
<contents of implementation will be included by oracle>
\`\`\`

---
"
    fi

    prompt+="
NOW: Carefully review this entire plan for me and come up with your best
revisions in terms of better architecture, new features, changed features,
etc. to make it better, more robust/reliable, more performant, more
compelling/useful, etc.

For each proposed change, give me your detailed analysis and
rationale/justification for why it would make the project better along
with the git-diff style change versus the original plan shown below:

\`\`\`
<contents of spec will be included by oracle>
\`\`\`
"

    printf '%s\n' "$prompt"
}

# -----------------------------------------------------------------------------
# Analytics Metrics Schema (fzi.1)
#
# Metrics JSON schema (stored at .apr/analytics/<workflow>/metrics.json):
# {
#   "schema_version": "1.0.0",
#   "workflow": "default",
#   "created_at": "2026-01-12T20:00:00Z",
#   "updated_at": "2026-01-12T21:30:00Z",
#   "rounds": [
#     {
#       "round": 1,
#       "timestamp": "2026-01-12T20:00:00Z",
#       "documents": {
#         "readme": {
#           "path": "README.md",
#           "char_count": 5420,
#           "word_count": 892,
#           "line_count": 145,
#           "heading_count": 12,
#           "code_block_count": 5,
#           "link_count": 8,
#           "list_item_count": 23
#         },
#         "spec": { "...": "same metrics as readme" },
#         "implementation": null
#       },
#       "output": {
#         "path": ".apr/rounds/default/round_1.md",
#         "char_count": 8500,
#         "word_count": 1400,
#         "line_count": 180
#       },
#       "changes_from_previous": null
#     },
#     {
#       "round": 2,
#       "timestamp": "2026-01-12T21:30:00Z",
#       "documents": { "...": "same shape as round 1" },
#       "output": { "...": "same shape as round 1" },
#       "changes_from_previous": {
#         "spec": {
#           "lines_added": 45,
#           "lines_deleted": 12,
#           "lines_modified": 28,
#           "diff_ratio": 0.265,
#           "similarity_score": 0.82
#         }
#       }
#     }
#   ],
#   "convergence": {
#     "detected": false,
#     "confidence": 0.0,
#     "estimated_rounds_remaining": null,
#     "signals": {
#       "output_size_trend": "decreasing",
#       "change_velocity": "decreasing",
#       "similarity_trend": "increasing"
#     }
#   }
# }
#
# Metric definitions:
# - char_count: total characters in file
# - word_count: total words in file
# - line_count: total lines in file
# - heading_count: markdown headings (#) count
# - code_block_count: fenced code blocks (```) count
# - link_count: markdown links count
# - list_item_count: bullet/numbered list items count
# - lines_added/lines_deleted/lines_modified: diff metrics between rounds
# - diff_ratio: (lines_added + lines_deleted + lines_modified) / total_lines
# - similarity_score: 0.0..1.0 similarity between rounds
# -----------------------------------------------------------------------------

metrics_dir() {
    local workflow="$1"
    echo "$CONFIG_DIR/analytics/$workflow"
}

metrics_file_path() {
    local workflow="$1"
    echo "$(metrics_dir "$workflow")/metrics.json"
}

metrics_default_json() {
    local workflow="$1"
    local ts
    ts=$(iso_timestamp)
    jq -nc \
        --arg schema_version "$METRICS_SCHEMA_VERSION" \
        --arg workflow "$workflow" \
        --arg ts "$ts" \
        '{
            schema_version: $schema_version,
            workflow: $workflow,
            created_at: $ts,
            updated_at: $ts,
            rounds: [],
            convergence: {
                detected: false,
                confidence: 0.0,
                estimated_rounds_remaining: null,
                signals: {}
            }
        }'
}

metrics_validate_json() {
    local json_input="$1"
    echo "$json_input" | jq -e \
        '.schema_version and (.schema_version | type == "string")
         and .workflow and (.workflow | type == "string")
         and (.rounds | type == "array")
         and (.convergence == null or (.convergence | type == "object"))' >/dev/null
}

metrics_migrate_json() {
    local json_input="$1"
    local workflow="${2:-}"
    local version ts
    version=$(echo "$json_input" | jq -r '.schema_version // empty' 2>/dev/null || echo "")
    ts=$(iso_timestamp)

    if [[ -n "$version" ]] && version_gt "$version" "$METRICS_SCHEMA_VERSION"; then
        print_warning "Metrics schema version '$version' newer than supported '$METRICS_SCHEMA_VERSION'; leaving unchanged"
        echo "$json_input"
        return 0
    fi

    if [[ -n "$version" && "$version" == "$METRICS_SCHEMA_VERSION" ]]; then
        if metrics_validate_json "$json_input"; then
            echo "$json_input"
            return 0
        fi
    fi

    if [[ -z "$version" ]]; then
        print_warning "Metrics schema_version missing; migrating to v${METRICS_SCHEMA_VERSION}"
    elif [[ "$version" != "$METRICS_SCHEMA_VERSION" ]]; then
        print_warning "Metrics schema version '$version' detected; migrating to v${METRICS_SCHEMA_VERSION}"
    fi

    # Normalize to latest schema while preserving unknown fields.
    echo "$json_input" | jq -c \
        --arg schema_version "$METRICS_SCHEMA_VERSION" \
        --arg workflow "$workflow" \
        --arg ts "$ts" \
        '
        .schema_version = $schema_version
        | .workflow = (
            if (.workflow // "") != "" then .workflow
            elif ($workflow | length) > 0 then $workflow
            else "unknown"
            end
          )
        | .created_at = (.created_at // $ts)
        | .updated_at = $ts
        | .rounds = (.rounds // [])
        | .convergence = (.convergence // {
            detected: false,
            confidence: 0.0,
            estimated_rounds_remaining: null,
            signals: {}
          })
        '
}

metrics_exists() {
    local workflow="$1"
    [[ -f "$(metrics_file_path "$workflow")" ]]
}

metrics_init() {
    local workflow="$1"
    local metrics_path
    metrics_path=$(metrics_file_path "$workflow")

    if ! command -v jq &>/dev/null; then
        print_error "jq is required for analytics metrics"
        return 1
    fi

    if [[ -f "$metrics_path" ]]; then
        verbose "metrics_init: metrics file exists for workflow '$workflow'"
        metrics_migrate "$workflow" || return 1
        return 0
    fi

    verbose "metrics_init: creating metrics file for workflow '$workflow'"
    mkdir -p "$(metrics_dir "$workflow")"

    local json
    json=$(metrics_default_json "$workflow") || {
        print_error "Failed to build metrics JSON"
        return 1
    }

    metrics_write_file "$workflow" "$json"
}

# Backwards-compatible alias
metrics_init_file() {
    metrics_init "$@"
}

metrics_read() {
    local workflow="$1"
    local metrics_path
    metrics_path=$(metrics_file_path "$workflow")

    verbose "metrics_read: workflow=$workflow path=$metrics_path"

    if ! command -v jq &>/dev/null; then
        print_error "jq is required for analytics metrics"
        return 1
    fi

    metrics_init "$workflow" || return 1

    verbose "metrics_read: loading metrics JSON"
    local json
    json=$(cat "$metrics_path")
    if ! metrics_validate_json "$json"; then
        print_error "Metrics file failed schema validation"
        return 1
    fi
    printf '%s\n' "$json"
}

metrics_validate() {
    local workflow="$1"
    local metrics_path
    metrics_path=$(metrics_file_path "$workflow")

    verbose "metrics_validate: workflow=$workflow path=$metrics_path"

    if ! command -v jq &>/dev/null; then
        print_error "jq is required for analytics metrics"
        return 1
    fi

    if [[ ! -f "$metrics_path" ]]; then
        print_error "Metrics file not found for workflow '$workflow'"
        return 1
    fi

    local json
    json=$(cat "$metrics_path")
    if ! metrics_validate_json "$json"; then
        print_error "Metrics file failed schema validation"
        return 1
    fi
    return 0
}

metrics_migrate() {
    local workflow="$1"
    local metrics_path
    metrics_path=$(metrics_file_path "$workflow")

    verbose "metrics_migrate: workflow=$workflow path=$metrics_path"

    if [[ ! -f "$metrics_path" ]]; then
        return 0
    fi

    if ! command -v jq &>/dev/null; then
        print_error "jq is required for analytics metrics"
        return 1
    fi

    local current_json current_version
    current_json=$(cat "$metrics_path")
    current_version=$(echo "$current_json" | jq -r '.schema_version // empty' 2>/dev/null || echo "")

    if [[ -n "$current_version" ]] && version_gt "$current_version" "$METRICS_SCHEMA_VERSION"; then
        print_warning "Metrics schema version '$current_version' newer than supported '$METRICS_SCHEMA_VERSION'; skipping migration"
        return 0
    fi

    if [[ -n "$current_version" && "$current_version" == "$METRICS_SCHEMA_VERSION" ]]; then
        return 0
    fi

    local backup_path
    backup_path="${metrics_path}.backup.$(date -u +%Y%m%d_%H%M%S)"
    cp "$metrics_path" "$backup_path"
    verbose "metrics_migrate: backup created at $backup_path"

    local migrated_json
    migrated_json=$(metrics_migrate_json "$current_json" "$workflow") || {
        print_error "Metrics migration failed"
        return 1
    }

    metrics_write_file "$workflow" "$migrated_json"
}

metrics_read_round() {
    local workflow="$1"
    local round_num="$2"

    verbose "metrics_read_round: workflow=$workflow round=$round_num"

    local json
    json=$(metrics_read "$workflow") || return 1

    echo "$json" | jq -c --argjson round "$round_num" \
        '(.rounds | map(select(.round == $round)) | .[0]) // null'
}

metrics_write_round() {
    local workflow="$1"
    local round_num="$2"
    local round_json="$3"
    local metrics_path
    metrics_path=$(metrics_file_path "$workflow")

    verbose "metrics_write_round: workflow=$workflow round=$round_num"

    if ! command -v jq &>/dev/null; then
        print_error "jq is required for analytics metrics"
        return 1
    fi

    # Acquire lock for RMW cycle
    metrics_lock "$workflow" || return 1

    # Initialize if needed (inside lock)
    if ! metrics_init "$workflow"; then
        metrics_unlock "$workflow"
        return 1
    fi

    if ! echo "$round_json" | jq -e '.' >/dev/null 2>&1; then
        print_error "Round metrics JSON is invalid"
        metrics_unlock "$workflow"
        return 1
    fi

    local ts normalized_round merged
    ts=$(iso_timestamp)
    normalized_round=$(echo "$round_json" | jq -c --argjson num "$round_num" '.round = $num')

    # Read current state (safe due to lock)
    local current_json
    current_json=$(cat "$metrics_path")

    if ! merged=$(echo "$current_json" | jq -c --argjson round "$normalized_round" --argjson num "$round_num" --arg ts "$ts" '.rounds |= (map(select(.round != $num)) + [$round] | sort_by(.round)) | .updated_at = $ts'); then
        print_error "Failed to merge round metrics"
        metrics_unlock "$workflow"
        return 1
    fi

    metrics_write_file "$workflow" "$merged"
    metrics_unlock "$workflow"
    verbose "metrics_write_round: wrote round $round_num for workflow '$workflow'"
}

metrics_write_convergence() {
    local workflow="$1"
    local convergence_json="$2"
    local metrics_path
    metrics_path=$(metrics_file_path "$workflow")

    verbose "metrics_write_convergence: workflow=$workflow"

    if ! command -v jq &>/dev/null; then
        print_error "jq is required for analytics metrics"
        return 1
    fi

    metrics_lock "$workflow" || return 1

    if ! metrics_init "$workflow"; then
        metrics_unlock "$workflow"
        return 1
    fi

    if ! echo "$convergence_json" | jq -e 'type == "object"' >/dev/null 2>&1; then
        print_error "Convergence JSON must be an object"
        metrics_unlock "$workflow"
        return 1
    fi

    local ts merged current_json
    ts=$(iso_timestamp)
    current_json=$(cat "$metrics_path")

    if ! merged=$(echo "$current_json" | jq -c --argjson convergence "$convergence_json" --arg ts "$ts" '.convergence = $convergence | .updated_at = $ts'); then
        print_error "Failed to merge convergence metrics"
        metrics_unlock "$workflow"
        return 1
    fi

    metrics_write_file "$workflow" "$merged"
    metrics_unlock "$workflow"
    verbose "metrics_write_convergence: updated convergence for workflow '$workflow'"
}

# Internal: Write JSON to metrics file (atomic via rename)

# Assumes lock is held by caller if used in RMW cycle.

metrics_write_file() {

    local workflow="$1"

    local json_input="$2"

    local metrics_path metrics_dir_path

    metrics_path=$(metrics_file_path "$workflow")

    metrics_dir_path=$(metrics_dir "$workflow")



    if ! command -v jq &>/dev/null; then

        print_error "jq is required for analytics metrics"

        return 1

    fi



    if ! metrics_validate_json "$json_input"; then

        print_error "Refusing to write invalid metrics JSON"

        return 1

    fi



    mkdir -p "$metrics_dir_path"



            local tmp_file=""



            tmp_file=$(mktemp -p "$metrics_dir_path" "metrics.json.tmp.XXXXXX" 2>/dev/null || mktemp "${metrics_dir_path}/metrics.json.tmp.XXXXXX" 2>/dev/null || echo "")



            if [[ -z "$tmp_file" ]]; then

        print_error "Failed to create temporary file for metrics"

        return 1

    fi



    if ! printf '%s\n' "$json_input" > "$tmp_file"; then

        print_error "Failed to write metrics temp file"

        rm -f "$tmp_file" 2>/dev/null

        return 1

    fi



    if ! mv -f "$tmp_file" "$metrics_path"; then

        print_error "Failed to move metrics temp file into place"

        rm -f "$tmp_file" 2>/dev/null

        return 1

    fi

    verbose "Wrote metrics to $metrics_path"

}



# Locking helpers for metrics

METRICS_LOCK_FD=""



metrics_lock() {
    local workflow="$1"
    local metrics_dir_path
    metrics_dir_path=$(metrics_dir "$workflow")

    mkdir -p "$metrics_dir_path"



    local lock_file="${metrics_dir_path}/.metrics.lock"



    if command -v flock &>/dev/null; then

        exec {METRICS_LOCK_FD}>"$lock_file"

        if ! flock -x "$METRICS_LOCK_FD"; then

            return 1

        fi

    else

        # Fallback: simplistic spin lock (less robust but works for basic concurrency)

        local retries=0

        while ! (set -C; echo "$" > "$lock_file") 2>/dev/null; do

            # Check for stale lock

            local pid

            pid=$(cat "$lock_file" 2>/dev/null || echo "")

            if [[ -n "$pid" ]] && ! kill -0 "$pid" 2>/dev/null; then

                rm -f "$lock_file" 2>/dev/null

            fi

            

            sleep 0.1

            ((retries++))

            if (( retries > 50 )); then # 5 seconds

                print_error "Failed to acquire metrics lock for $workflow"

                return 1

            fi

        done

    fi

    return 0

}



metrics_unlock() {

    local workflow="$1"

    local metrics_dir_path

    metrics_dir_path=$(metrics_dir "$workflow")

    local lock_file="${metrics_dir_path}/.metrics.lock"



    if [[ -n "$METRICS_LOCK_FD" ]]; then

        exec {METRICS_LOCK_FD}>&-

        METRICS_LOCK_FD=""

    else

        rm -f "$lock_file" 2>/dev/null

    fi

}

# -----------------------------------------------------------------------------
# Document Metrics Collection (fzi.3)
# -----------------------------------------------------------------------------

# collect_document_metrics - Extract quantitative metrics from a markdown file
#
# Metrics collected:
#   - char_count: Total characters
#   - word_count: Total words
#   - line_count: Total lines
#   - heading_count: Markdown headings (lines starting with #)
#   - code_block_count: Fenced code blocks (``` pairs)
#   - link_count: Markdown links [text](url)
#   - list_item_count: Bullet/numbered list items
#
# Arguments:
#   $1 - file_path: Path to markdown file (returns null if missing)
#   $2 - doc_type: Document type identifier ("readme", "spec", "output")
#
# Output:
#   JSON object with metrics, or "null" if file missing
#
# Example:
#   metrics=$(collect_document_metrics "README.md" "readme")
#   echo "$metrics" | jq ".word_count"
#
collect_document_metrics() {
    local file_path="$1"
    local doc_type="${2:-document}"

    if ! command -v jq &>/dev/null; then
        print_error "jq is required for analytics metrics"
        return 1
    fi

    verbose "Collecting metrics for $doc_type: ${file_path:-<empty>}"

    if [[ -z "$file_path" || ! -f "$file_path" ]]; then
        verbose "File not found for $doc_type: ${file_path:-<empty>}"
        echo "null"
        return 0
    fi

    local start_ts end_ts elapsed_ms
    start_ts=$(date +%s 2>/dev/null || echo 0)

    local char_count word_count line_count
    local heading_count raw_code_blocks code_block_count link_count list_item_count

    char_count=$(wc -c < "$file_path" | tr -d ' ')
    word_count=$(wc -w < "$file_path" | tr -d ' ')
    line_count=$(wc -l < "$file_path" | tr -d ' ')

    verbose "Basic metrics: chars=$char_count words=$word_count lines=$line_count"

    if [[ "$char_count" =~ ^[0-9]+$ ]] && [[ "$char_count" -gt 1048576 ]]; then
        print_warning "Large $doc_type file (>1MB): $file_path"
    fi

    # Count headings (Atx style ^#+ ) but skip those inside fenced code blocks
    heading_count=$(awk '
        /^```/ { in_code = !in_code; next }
        !in_code && /^#+ / { count++ }
        END { print count+0 }
    ' "$file_path" 2>/dev/null || echo 0)

    raw_code_blocks=$(grep -c '^```' "$file_path" 2>/dev/null || true)
    code_block_count=$((raw_code_blocks / 2))
    link_count=$({ grep -oE '\[([^\]]+)\]\([^)]+\)' "$file_path" 2>/dev/null || true; } | wc -l | tr -d ' ')
    list_item_count=$(grep -cE '^[[:space:]]*([-*]|[0-9]+\.)' "$file_path" 2>/dev/null || true)

    verbose "Structure metrics: headings=$heading_count code_blocks=$code_block_count links=$link_count lists=$list_item_count"

    end_ts=$(date +%s 2>/dev/null || echo 0)
    elapsed_ms=$(( (end_ts - start_ts) * 1000 ))
    verbose "collect_document_metrics completed in ${elapsed_ms}ms"

    jq -nc \
        --arg path "$file_path" \
        --argjson char_count "$char_count" \
        --argjson word_count "$word_count" \
        --argjson line_count "$line_count" \
        --argjson heading_count "$heading_count" \
        --argjson code_block_count "$code_block_count" \
        --argjson link_count "$link_count" \
        --argjson list_item_count "$list_item_count" \
        '{
            path: $path,
            char_count: $char_count,
            word_count: $word_count,
            line_count: $line_count,
            heading_count: $heading_count,
            code_block_count: $code_block_count,
            link_count: $link_count,
            list_item_count: $list_item_count
        }'
}

collect_round_document_metrics() {
    local workflow="$1"
    local round_num="$2"
    local readme_path="$3"
    local spec_path="$4"
    local impl_path="${5:-}"
    local output_path="${6:-}"

    if ! command -v jq &>/dev/null; then
        print_error "jq is required for analytics metrics"
        return 1
    fi

    verbose "Collecting round $round_num document metrics for workflow: $workflow"
    verbose "  README: $readme_path"
    verbose "  Spec:   $spec_path"
    verbose "  Impl:   ${impl_path:-<none>}"

    if [[ -z "$output_path" ]]; then
        output_path="$CONFIG_DIR/rounds/$workflow/round_${round_num}.md"
    fi
    verbose "  Output: $output_path"

    local readme_metrics spec_metrics impl_metrics output_metrics
    readme_metrics=$(collect_document_metrics "$readme_path" "readme")
    spec_metrics=$(collect_document_metrics "$spec_path" "spec")
    if [[ -n "$impl_path" ]]; then
        impl_metrics=$(collect_document_metrics "$impl_path" "implementation")
    else
        impl_metrics="null"
    fi
    output_metrics=$(collect_document_metrics "$output_path" "output")

    verbose "All document metrics collected, building aggregate JSON"

    jq -nc \
        --argjson readme "$readme_metrics" \
        --argjson spec "$spec_metrics" \
        --argjson impl "$impl_metrics" \
        --argjson output "$output_metrics" \
        '{
            readme: $readme,
            spec: $spec,
            implementation: $impl,
            output: $output
        }'
}

# ---------------------------------------------------------------------------
# Inter-Round Change Analysis (fzi.4)
# ---------------------------------------------------------------------------

calculate_change_metrics() {
    local old_file="$1"
    local new_file="$2"

    local start_ts end_ts elapsed_ms
    start_ts=$(date +%s 2>/dev/null || echo 0)

    verbose "Calculating change metrics"
    verbose "  Old: $old_file"
    verbose "  New: $new_file"

    # Handle missing files
    if [[ -z "$old_file" || ! -f "$old_file" ]]; then
        verbose "Old file not found, returning null"
        echo "null"
        return 0
    fi

    if [[ -z "$new_file" || ! -f "$new_file" ]]; then
        verbose "New file not found, returning null"
        echo "null"
        return 0
    fi

    # Fast path: files are identical
    if cmp -s "$old_file" "$new_file"; then
        verbose "Files are identical (fast path)"
        end_ts=$(date +%s 2>/dev/null || echo 0)
        elapsed_ms=$(( (end_ts - start_ts) * 1000 ))
        verbose "calculate_change_metrics completed in ${elapsed_ms}ms"
        jq -nc '{
            lines_added: 0,
            lines_deleted: 0,
            lines_modified: 0,
            total_changes: 0,
            diff_ratio: 0,
            similarity_score: 1.0,
            identical: true
        }'
        return 0
    fi

    verbose "Files differ, computing metrics..."

    local lines_added lines_deleted total_changes
    local total_lines diff_ratio similarity_score

    # Get diff output
    local diff_output
    diff_output=$(diff "$old_file" "$new_file" 2>/dev/null || true)

    # Count changes
    lines_added=$(echo "$diff_output" | grep -c '^>' 2>/dev/null || true)
    lines_deleted=$(echo "$diff_output" | grep -c '^<' 2>/dev/null || true)
    total_changes=$((lines_added + lines_deleted))

    verbose "Diff counts: +$lines_added -$lines_deleted (total: $total_changes)"

    # Calculate diff ratio
    total_lines=$(wc -l < "$new_file" | tr -d ' ')
    if [[ "$total_lines" =~ ^[0-9]+$ ]] && [[ $total_lines -gt 0 ]]; then
        diff_ratio=$(echo "scale=4; $total_changes / $total_lines" | bc 2>/dev/null || echo "0")
    else
        diff_ratio="0"
    fi

    verbose "Diff ratio: $diff_ratio ($total_changes / $total_lines)"

    # Calculate similarity score using line-based Jaccard
    local common_lines total_unique
    common_lines=$(comm -12 <(sort "$old_file") <(sort "$new_file") 2>/dev/null | wc -l | tr -d ' ')
    total_unique=$(cat <(sort -u "$old_file") <(sort -u "$new_file") 2>/dev/null | sort -u | wc -l | tr -d ' ')

    if [[ "$total_unique" =~ ^[0-9]+$ ]] && [[ $total_unique -gt 0 ]]; then
        similarity_score=$(echo "scale=4; $common_lines / $total_unique" | bc 2>/dev/null || echo "1.0")
    else
        similarity_score="1.0"
    fi

    verbose "Similarity: $similarity_score ($common_lines common / $total_unique unique)"

    end_ts=$(date +%s 2>/dev/null || echo 0)
    elapsed_ms=$(( (end_ts - start_ts) * 1000 ))
    verbose "calculate_change_metrics completed in ${elapsed_ms}ms"

    # Build JSON result
    jq -nc \
        --argjson lines_added "$lines_added" \
        --argjson lines_deleted "$lines_deleted" \
        --argjson total_changes "$total_changes" \
        --arg diff_ratio "$diff_ratio" \
        --arg similarity_score "$similarity_score" \
        '{
            lines_added: $lines_added,
            lines_deleted: $lines_deleted,
            lines_modified: 0,
            total_changes: $total_changes,
            diff_ratio: ($diff_ratio | tonumber),
            similarity_score: ($similarity_score | tonumber),
            identical: false
        }'
}

calculate_round_changes() {
    local workflow="$1"
    local current_round="$2"
    local output_dir="${3:-}"

    local prev_round=$((current_round - 1))

    verbose "Calculating round changes: round $current_round vs round $prev_round"

    # No previous round
    if [[ $prev_round -lt 1 ]]; then
        verbose "No previous round (current is round 1), returning null"
        echo "null"
        return 0
    fi

    # Compare OUTPUT files (GPT responses), not spec files
    # The spec changes are made by the USER after each round
    # We track GPT output changes to detect convergence
    if [[ -z "$output_dir" ]]; then
        output_dir="$CONFIG_DIR/rounds/$workflow"
    fi

    local prev_output="$output_dir/round_${prev_round}.md"
    local curr_output="$output_dir/round_${current_round}.md"

    verbose "Comparing outputs:"
    verbose "  Previous: $prev_output"
    verbose "  Current:  $curr_output"

    calculate_change_metrics "$prev_output" "$curr_output"
}

# -----------------------------------------------------------------------------
# Convergence Detection (fzi.5)
#
# These functions analyze revision history to detect when a specification
# has stabilized. The convergence score is a weighted combination of three
# independent signals:
#
#   Score = (0.35 × output_trend) + (0.35 × change_velocity) + (0.30 × similarity_trend)
#
# Each signal returns 0.0..1.0 where higher values indicate convergence.
# A combined score >= 0.75 indicates high confidence of convergence.
# -----------------------------------------------------------------------------

# calculate_output_trend_signal - Detect decreasing output size trend
#
# GPT Pro's feedback typically decreases in size as specifications mature.
# Early rounds produce lengthy analyses; convergence shows as more focused,
# briefer feedback. Compares average output size of first half vs second half
# of recent rounds.
#
# Arguments:
#   $1 - metrics_json: Full metrics JSON containing rounds array
#
# Returns: Signal value 0.0..1.0 (1.0 = strong decreasing trend)
#
calculate_output_trend_signal() {
    local metrics_json="$1"

    verbose "Calculating output size trend signal"

    local sizes=()
    mapfile -t sizes < <(echo "$metrics_json" | jq -r '.rounds[-5:][].output.char_count // 0' 2>/dev/null || true)

    local count=${#sizes[@]}
    if [[ $count -lt 2 ]]; then
        echo "0"
        return 0
    fi

    local half=$((count / 2))
    [[ $half -lt 1 ]] && half=1
    local first_sum=0 second_sum=0
    local i
    for i in "${!sizes[@]}"; do
        if [[ $i -lt $half ]]; then
            first_sum=$((first_sum + sizes[i]))
        else
            second_sum=$((second_sum + sizes[i]))
        fi
    done

    local second_count=$((count - half))
    [[ $second_count -lt 1 ]] && second_count=1

    local first_avg second_avg
    first_avg=$(echo "scale=4; $first_sum / $half" | bc 2>/dev/null || echo "0")
    second_avg=$(echo "scale=4; $second_sum / $second_count" | bc 2>/dev/null || echo "0")

    verbose "Output size averages: first=$first_avg second=$second_avg"

    if [[ $(echo "$first_avg == 0" | bc 2>/dev/null || echo 1) -eq 1 ]]; then
        echo "0"
        return 0
    fi

    local low high signal
    low=$(echo "scale=4; $first_avg * 0.8" | bc 2>/dev/null || echo "0")
    high=$(echo "scale=4; $first_avg * 1.2" | bc 2>/dev/null || echo "0")

    if [[ $(echo "$second_avg <= $low" | bc 2>/dev/null || echo 0) -eq 1 ]]; then
        signal="1.0"
    elif [[ $(echo "$second_avg >= $high" | bc 2>/dev/null || echo 0) -eq 1 ]]; then
        signal="0.0"
    else
        signal=$(echo "scale=4; 1 - (($second_avg - $low) / ($high - $low))" | bc 2>/dev/null || echo "0")
    fi

    echo "$signal"
}

# calculate_change_velocity_signal - Detect slowing rate of changes
#
# The rate of changes typically slows as the specification matures. Uses
# the diff_ratio metric (lines changed / total lines) to measure change
# velocity. Lower average diff_ratio indicates convergence.
#
# Arguments:
#   $1 - metrics_json: Full metrics JSON containing rounds array
#
# Returns: Signal value 0.0..1.0 (1.0 = very low change velocity)
#
calculate_change_velocity_signal() {
    local metrics_json="$1"

    verbose "Calculating change velocity signal"

    # Require enough rounds for a meaningful velocity signal.
    local round_count
    round_count=$(echo "$metrics_json" | jq -r '.rounds | length' 2>/dev/null || echo "0")
    if [[ "$round_count" -lt 3 ]]; then
        echo "0"
        return 0
    fi

    local ratios=()
    mapfile -t ratios < <(echo "$metrics_json" | jq -r '.rounds[-5:][].changes_from_previous.diff_ratio // 1.0' 2>/dev/null || true)

    local count=${#ratios[@]}
    if [[ $count -lt 1 ]]; then
        echo "0"
        return 0
    fi

    local sum=0
    local r
    for r in "${ratios[@]}"; do
        sum=$(echo "scale=4; $sum + $r" | bc 2>/dev/null || echo "$sum")
    done

    local avg
    avg=$(echo "scale=4; $sum / $count" | bc 2>/dev/null || echo "1.0")
    verbose "Average diff ratio: $avg"

    local signal
    if [[ $(echo "$avg <= 0.1" | bc 2>/dev/null || echo 0) -eq 1 ]]; then
        signal="1.0"
    elif [[ $(echo "$avg >= 0.5" | bc 2>/dev/null || echo 0) -eq 1 ]]; then
        signal="0.0"
    else
        signal=$(echo "scale=4; 1 - (($avg - 0.1) / 0.4)" | bc 2>/dev/null || echo "0")
    fi

    echo "$signal"
}

# calculate_similarity_trend_signal - Detect increasing content similarity
#
# Successive outputs should become more similar as the specification stabilizes.
# Uses word-level overlap (similarity_score) between consecutive rounds.
# Higher average similarity indicates convergence.
#
# Arguments:
#   $1 - metrics_json: Full metrics JSON containing rounds array
#
# Returns: Signal value 0.0..1.0 (1.0 = very high similarity)
#
calculate_similarity_trend_signal() {
    local metrics_json="$1"

    verbose "Calculating similarity trend signal"

    # Require enough rounds for a meaningful similarity trend.
    local round_count
    round_count=$(echo "$metrics_json" | jq -r '.rounds | length' 2>/dev/null || echo "0")
    if [[ "$round_count" -lt 3 ]]; then
        echo "0"
        return 0
    fi

    local sims=()
    mapfile -t sims < <(echo "$metrics_json" | jq -r '.rounds[-5:][].changes_from_previous.similarity_score // 0' 2>/dev/null || true)

    local count=${#sims[@]}
    if [[ $count -lt 1 ]]; then
        echo "0"
        return 0
    fi

    local sum=0
    local s
    for s in "${sims[@]}"; do
        sum=$(echo "scale=4; $sum + $s" | bc 2>/dev/null || echo "$sum")
    done

    local avg
    avg=$(echo "scale=4; $sum / $count" | bc 2>/dev/null || echo "0")
    verbose "Average similarity score: $avg"

    local signal
    if [[ $(echo "$avg >= 0.9" | bc 2>/dev/null || echo 0) -eq 1 ]]; then
        signal="1.0"
    elif [[ $(echo "$avg <= 0.6" | bc 2>/dev/null || echo 0) -eq 1 ]]; then
        signal="0.0"
    else
        signal=$(echo "scale=4; ($avg - 0.6) / 0.3" | bc 2>/dev/null || echo "0")
    fi

    echo "$signal"
}

# calculate_convergence - Compute overall convergence score and estimate
#
# Combines the three convergence signals with weights:
#   - output_trend: 35% (decreasing feedback length)
#   - change_velocity: 35% (slowing rate of changes)
#   - similarity_trend: 30% (increasing content similarity)
#
# Also estimates remaining rounds based on current trajectory.
#
# Arguments:
#   $1 - workflow: Workflow name to calculate convergence for
#
# Output: JSON object with convergence data:
#   {
#     "detected": true/false,     // true if confidence >= 0.75
#     "confidence": 0.0..1.0,     // weighted signal combination
#     "estimated_rounds_remaining": N or null,
#     "signals": { output_size_trend, change_velocity, similarity_trend }
#   }
#
calculate_convergence() {
    local workflow="$1"

    verbose "Calculating convergence for workflow: $workflow"

    if ! command -v bc &>/dev/null; then
        print_warning "bc not available; convergence disabled"
        jq -nc '{
            detected: false,
            confidence: 0.0,
            estimated_rounds_remaining: null,
            signals: {
                output_size_trend: 0.0,
                change_velocity: 0.0,
                similarity_trend: 0.0
            }
        }'
        return 0
    fi

    local metrics_json
    metrics_json=$(metrics_read "$workflow") || return 1

    local round_count
    round_count=$(echo "$metrics_json" | jq -r '.rounds | length' 2>/dev/null || echo "0")

    if [[ "$round_count" -lt 3 ]]; then
        verbose "Insufficient rounds for convergence analysis (need >= 3)"
        jq -nc '{
            reason: "insufficient_rounds",
            detected: false,
            confidence: 0.0,
            estimated_rounds_remaining: null,
            signals: {
                output_size_trend: 0.0,
                change_velocity: 0.0,
                similarity_trend: 0.0
            }
        }'
        return 0
    fi

    local output_signal change_signal similarity_signal
    output_signal=$(calculate_output_trend_signal "$metrics_json")
    change_signal=$(calculate_change_velocity_signal "$metrics_json")
    similarity_signal=$(calculate_similarity_trend_signal "$metrics_json")

    verbose "Signals: output=$output_signal change=$change_signal similarity=$similarity_signal"

    local convergence_score
    convergence_score=$(echo "scale=4; 0.35 * $output_signal + 0.35 * $change_signal + 0.30 * $similarity_signal" | bc 2>/dev/null || echo "0")

    local detected="false"
    local is_converged
    is_converged=$(echo "$convergence_score >= 0.75" | bc 2>/dev/null || echo "0")
    if [[ "$is_converged" -eq 1 ]]; then
        detected="true"
    fi

    local estimated_remaining="null"
    if [[ "$detected" != "true" ]]; then
        estimated_remaining=$(echo "scale=0; (1 - $convergence_score) * 5 / 1" | bc 2>/dev/null || echo "1")
        if [[ -z "$estimated_remaining" || "$estimated_remaining" -lt 1 ]]; then
            estimated_remaining=1
        fi
    fi

    jq -nc \
        --argjson detected "$detected" \
        --argjson confidence "$convergence_score" \
        --argjson est_remaining "$estimated_remaining" \
        --argjson output_signal "$output_signal" \
        --argjson change_signal "$change_signal" \
        --argjson similarity_signal "$similarity_signal" \
        '{
            detected: $detected,
            confidence: $confidence,
            estimated_rounds_remaining: $est_remaining,
            signals: {
                output_size_trend: $output_signal,
                change_velocity: $change_signal,
                similarity_trend: $similarity_signal
            }
        }'
}

update_convergence_metrics() {
    local workflow="$1"

    verbose "Updating convergence metrics for workflow: $workflow"

    local convergence_data
    convergence_data=$(calculate_convergence "$workflow") || return 1

    metrics_write_convergence "$workflow" "$convergence_data"
    verbose "Convergence metrics updated"
}

# -----------------------------------------------------------------------------
# Interactive Setup Wizard
# -----------------------------------------------------------------------------

run_setup() {
    print_banner

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style \
            --border rounded \
            --border-foreground 39 \
            --padding "1 2" \
            --margin "0 0 1 0" \
            "Welcome to the APR Setup Wizard!" \
            "" \
            "This will help you configure a new revision workflow." \
            "You'll specify your documents and review preferences." >&2
    else
        echo "" >&2
        echo -e "${BOLD}Welcome to the APR Setup Wizard!${NC}" >&2
        echo "" >&2
        echo "  This will help you configure a new revision workflow." >&2
        echo "  You'll specify your documents and review preferences." >&2
    fi
    echo "" >&2

    ensure_config_dir

    # Step 1: Workflow name
    print_step 1 5 "Workflow name"
    local workflow_name
    while true; do
        workflow_name=$(input "Workflow name" "default")
        # Validate: safe filename segment (no slashes/spaces)
        if ! is_valid_workflow_name "$workflow_name"; then
            print_error "Invalid name: use only letters, numbers, dots, hyphens, underscores"
            continue
        fi
        # Check for existing workflow
        if [[ -f "$CONFIG_DIR/workflows/$workflow_name.yaml" ]]; then
            print_warning "Workflow '$workflow_name' already exists"
            if ! confirm "Overwrite existing workflow?"; then
                continue
            fi
        fi
        break
    done
    echo "" >&2

    # Step 2: Project description
    print_step 2 5 "Project description"
    local description
    description=$(input "Brief description" "Iterative specification refinement")
    echo "" >&2

    # Step 3: README/Overview document
    print_step 3 5 "README/Overview document"
    print_info "Select the main README or overview document"
    local readme_path
    readme_path=$(file_picker "Select README file")
    if [[ ! -f "$readme_path" ]]; then
        print_error "File not found: $readme_path"
        exit $EXIT_CONFIG_ERROR
    fi
    print_success "README: $readme_path"
    echo "" >&2

    # Step 4: Specification document
    print_step 4 5 "Specification document"
    print_info "Select the main specification/plan document"
    local spec_path
    spec_path=$(file_picker "Select specification file")
    if [[ ! -f "$spec_path" ]]; then
        print_error "File not found: $spec_path"
        exit $EXIT_CONFIG_ERROR
    fi
    print_success "Specification: $spec_path"
    echo "" >&2

    # Step 5: Implementation document (optional)
    print_step 0 0 "Implementation document" "optional"
    local impl_path=""
    if confirm "Do you have an implementation/reference document?"; then
        impl_path=$(file_picker "Select implementation file")
        if [[ -n "$impl_path" && ! -f "$impl_path" ]]; then
            print_warning "File not found: $impl_path (skipping)"
            impl_path=""
        else
            print_success "Implementation: $impl_path"
        fi
    fi
    echo "" >&2

    # Step 5: Review preferences
    print_step 5 5 "Review preferences"
    local model
    model=$(choose "Select GPT model for reviews:" \
        "5.2 Thinking (Extended Reasoning)" \
        "gpt-5.2-pro" \
        "gpt-5.2")

    # Extract model name
    case "$model" in
        "5.2 Thinking"*) model="5.2 Thinking" ;;
        *) ;;
    esac

    echo "" >&2

    # Create workflow directory and config
    local workflow_dir="$CONFIG_DIR/workflows"
    mkdir -p "$workflow_dir"
    mkdir -p "$CONFIG_DIR/rounds/$workflow_name"

    # Write config file
    cat > "$workflow_dir/$workflow_name.yaml" << EOF
# APR Workflow Configuration
# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")

name: $workflow_name
description: $(yaml_quote "$description")

documents:
  readme: $(yaml_quote "$readme_path")
  spec: $(yaml_quote "$spec_path")
  implementation: $(yaml_quote "${impl_path:-}")

oracle:
  model: "$model"
  browser_hide_window: true

rounds:
  output_dir: $(yaml_quote "$CONFIG_DIR/rounds/$workflow_name")
EOF

    # Create default config if this is the first workflow
    if [[ ! -f "$CONFIG_DIR/config.yaml" ]]; then
        cat > "$CONFIG_DIR/config.yaml" << EOF
# APR Global Configuration
default_workflow: $workflow_name
EOF
    fi

    echo "" >&2
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style \
            --border rounded \
            --border-foreground 82 \
            --padding "1 2" \
            "✓ Workflow '$workflow_name' created successfully!" \
            "" \
            "To run your first revision round:" \
            "  apr run 1" \
            "" \
            "To run with implementation doc:" \
            "  apr run 1 --include-impl" >&2
    else
        echo "" >&2
        print_success "Workflow '$workflow_name' created successfully!"
        echo "" >&2
        echo "  To run your first revision round:" >&2
        echo -e "    ${CYAN}apr run 1${NC}" >&2
        echo "" >&2
        echo "  To run with implementation doc:" >&2
        echo -e "    ${CYAN}apr run 1 --include-impl${NC}" >&2
    fi
}

# -----------------------------------------------------------------------------
# Run Revision Round
# -----------------------------------------------------------------------------

run_round() {
    local round_num="$1"
    local workflow="${WORKFLOW:-default}"
    local include_impl="${INCLUDE_IMPL:-false}"
    local dry_run="${DRY_RUN:-false}"
    local render="${RENDER:-false}"
    local copy="${COPY:-false}"
    local wait_mode="${WAIT_MODE:-false}"
    local manual_login="${MANUAL_LOGIN:-false}"
    local keep_browser="${KEEP_BROWSER:-false}"
    local skip_preflight="${SKIP_PREFLIGHT:-false}"
    local enable_retry="${ENABLE_RETRY:-true}"

    print_banner

    verbose "Starting run_round: round=$round_num workflow=$workflow"
    verbose "Options: include_impl=$include_impl dry_run=$dry_run render=$render"
    verbose "Options: wait_mode=$wait_mode manual_login=$manual_login"
    verbose "Options: skip_preflight=$skip_preflight enable_retry=$enable_retry"

    # Load workflow config
    local config_path="$CONFIG_DIR/workflows/$workflow.yaml"
    verbose "Loading workflow config: $config_path"
    if [[ ! -f "$config_path" ]]; then
        # If no config at all, show the friendly welcome experience
        if [[ ! -d "$CONFIG_DIR" || ! -f "$CONFIG_DIR/config.yaml" ]]; then
            show_first_run_welcome
        else
            print_error "Workflow '$workflow' not found"
            print_info "Run 'apr setup' to create a new workflow"
            print_info "Or 'apr list' to see available workflows"
        fi
        exit $EXIT_CONFIG_ERROR
    fi

    # Parse config (simple grep-based for now)
    local readme_path spec_path impl_path model output_dir impl_every_n thinking_time
    local browser_hide_window_raw browser_hide_window
    readme_path=$(yaml_unquote "$(get_config_value "readme" "$config_path")")
    spec_path=$(yaml_unquote "$(get_config_value "spec" "$config_path")")
    impl_path=$(yaml_unquote "$(get_config_value "implementation" "$config_path")")
    model=$(yaml_unquote "$(get_config_value "model" "$config_path")")
    output_dir=$(yaml_unquote "$(get_config_value "output_dir" "$config_path")")
    impl_every_n=$(yaml_unquote "$(get_config_value "impl_every_n" "$config_path")")
    thinking_time=$(yaml_unquote "$(get_config_value "thinking_time" "$config_path")")
    browser_hide_window_raw=$(yaml_unquote "$(get_config_value "browser_hide_window" "$config_path")")
    browser_hide_window=$(config_bool_default_true "$browser_hide_window_raw")

    # Auto-include implementation every N rounds if configured
    if [[ -n "$impl_every_n" && "$impl_every_n" =~ ^[0-9]+$ && "$impl_every_n" -gt 0 ]]; then
        if (( round_num % impl_every_n == 0 )); then
            verbose "impl_every_n=$impl_every_n: round $round_num triggers automatic impl inclusion"
            include_impl=true
        fi
    fi

    local config_errors=()
    [[ -z "$model" ]] && config_errors+=("Model not configured in workflow")
    [[ -z "$output_dir" ]] && config_errors+=("Output directory not configured in workflow")
    if [[ ${#config_errors[@]} -gt 0 ]]; then
        local err
        for err in "${config_errors[@]}"; do
            print_error "$err"
        done
        print_info "Fix workflow configuration in $config_path"
        exit $EXIT_CONFIG_ERROR
    fi

    verbose "Config parsed:"
    verbose "  README: $readme_path"
    verbose "  Spec: $spec_path"
    verbose "  Implementation: ${impl_path:-<not configured>}"
    verbose "  Model: $model"
    verbose "  Output dir: $output_dir"
    verbose "  impl_every_n: ${impl_every_n:-<not configured>}"
    verbose "  thinking_time (legacy, ignored): ${thinking_time:-<not configured>}"
    verbose "  browser_hide_window: $browser_hide_window"

    if [[ -n "$thinking_time" ]]; then
        print_warning "oracle.thinking_time is deprecated and ignored: '$thinking_time'"
        print_info "Remove 'oracle.thinking_time' from $config_path"
    fi

    if [[ -z "$model" ]]; then
        print_error "Model not configured in $config_path"
        exit $EXIT_CONFIG_ERROR
    fi
    if [[ -z "$output_dir" ]]; then
        print_error "Output directory not configured in $config_path"
        exit $EXIT_CONFIG_ERROR
    fi

    # Run pre-flight checks (unless skipped or dry-run/render mode)
    if [[ "$skip_preflight" != "true" && "$dry_run" != "true" && "$render" != "true" ]]; then
        local impl_for_preflight=""
        [[ "$include_impl" == "true" && -n "$impl_path" ]] && impl_for_preflight="$impl_path"

        local preflight_result=0
        preflight_check "$readme_path" "$spec_path" "$impl_for_preflight" || preflight_result=$?

        if [[ $preflight_result -eq 1 ]]; then
            print_error "Pre-flight checks failed. Fix the issues above and try again."
            print_info "Use --no-preflight to skip these checks (not recommended)"
            exit $EXIT_CONFIG_ERROR
        fi
        # preflight_result=2 means warnings only, continue execution
    else
        verbose "Skipping pre-flight checks (skip_preflight=$skip_preflight dry_run=$dry_run render=$render)"
        # Basic file validation when preflight is skipped
        for f in "$readme_path" "$spec_path"; do
            if [[ ! -f "$f" ]]; then
                print_error "Required file not found: $f"
                exit $EXIT_CONFIG_ERROR
            fi
        done
    fi

    if [[ "$include_impl" == "true" ]]; then
        if [[ -z "$impl_path" ]]; then
            print_warning "Implementation document not configured; skipping"
            include_impl=false
        elif [[ ! -f "$impl_path" ]]; then
            print_warning "Implementation file not found: $impl_path"
            include_impl=false
        fi
    fi

    # Display round info
    local slug="apr-${workflow}-round-${round_num}"
    local output_file="${output_dir}/round_${round_num}.md"

    if [[ "$include_impl" == "true" && -n "$impl_path" ]]; then
        slug="${slug}-with-impl"
    fi

    # Warn if output file already exists
    if [[ -f "$output_file" && "$dry_run" != "true" && "$render" != "true" ]]; then
        local file_size
        file_size=$(du -h "$output_file" 2>/dev/null | cut -f1)
        print_warning "Round $round_num output already exists ($file_size)"
        if can_prompt; then
            if ! confirm "Overwrite existing output?"; then
                print_info "Cancelled. Use a different round number or backup the file."
                exit $EXIT_SUCCESS
            fi
        fi
    fi

    if [[ "$GUM_AVAILABLE" == "true" && "$QUIET_MODE" != "true" ]]; then
        gum style \
            --border rounded \
            --border-foreground 212 \
            --padding "1 2" \
            --margin "0 0 1 0" \
            "$(gum style --foreground 212 --bold "REVISION ROUND $round_num")" \
            "" \
            "$(gum style --foreground 39 "Workflow:") $workflow" \
            "$(gum style --foreground 39 "Model:") $model" \
            "$(gum style --foreground 39 "Include impl:") $include_impl" \
            "$(gum style --foreground 39 "Output:") $output_file" >&2
    elif [[ "$QUIET_MODE" != "true" ]]; then
        echo "" >&2
        echo -e "  ${BOLD}${MAGENTA}REVISION ROUND $round_num${NC}" >&2
        echo "" >&2
        echo -e "  ${CYAN}Workflow:${NC}     $workflow" >&2
        echo -e "  ${CYAN}Model:${NC}        $model" >&2
        echo -e "  ${CYAN}Include impl:${NC} $include_impl" >&2
        echo -e "  ${CYAN}Output:${NC}       $output_file" >&2
    fi
    echo "" >&2

    # Build file arguments
    local file_args=(--file "$readme_path")
    if [[ "$include_impl" == "true" && -n "$impl_path" ]]; then
        file_args+=(--file "$impl_path")
    fi
    file_args+=(--file "$spec_path")

    # Build prompt using shared function
    local prompt
    prompt=$(build_revision_prompt "$include_impl" "$config_path")
    if [[ -z "$prompt" ]]; then
        if [[ "$ROBOT_MODE" == "true" ]]; then
            robot_json false "validation_failed" '{"errors":["Prompt template is empty"]}' \
                "Add 'template' or 'template_with_impl' to workflow"
        else
            print_error "Prompt template is empty"
            print_info "Add 'template' or 'template_with_impl' to $config_path"
        fi
        return 1
    fi

    # Quality gate: refuse to run if the prompt contains obvious unexpanded placeholders.
    if ! prompt_quality_check "$prompt" "$config_path" "prompt"; then
        if [[ "$ROBOT_MODE" == "true" ]]; then
            robot_json false "validation_failed" "$(jq -nc --arg err "$PROMPT_QC_REASON" '{errors:[$err]}')" \
                "Fix workflow template before running"
        else
            print_error "Prompt quality check failed: $PROMPT_QC_REASON"
            echo "" >&2
            echo "$PROMPT_QC_DETAILS" >&2
        fi
        return 1
    fi

    # Best-effort Oracle feature detection for accurate dry-run output and
    # to enable optional flags when preflight is skipped.
    # Note: In dry-run/render mode, preflight_check doesn't run, so check_oracle
    # hasn't set ORACLE_CMD yet. Call it here if needed.
    if [[ "$render" != "true" ]]; then
        if [[ ${#ORACLE_CMD[@]} -eq 0 ]]; then
            check_oracle || true
        fi
        if [[ "$dry_run" == "true" ]]; then
            oracle_detect_features fast || true
        else
            oracle_detect_features || true
        fi
    fi

    # Dry run mode
    if [[ "$dry_run" == "true" ]]; then
        print_header "DRY RUN"
        echo "" >&2
        print_info "Would execute:"
        echo "" >&2
        echo "  ${ORACLE_CMD[*]} --engine browser \\" >&2
        echo "    -m \"$model\" \\" >&2
        for f in "${file_args[@]}"; do
            echo "    $f \\" >&2
        done
        echo "    --browser-attachments never \\" >&2
        echo "    --slug \"$slug\" \\" >&2
        echo "    --write-output \"$output_file\" \\" >&2
        [[ "$manual_login" == "true" ]] && echo "    --browser-manual-login \\" >&2
        [[ "$keep_browser" == "true" ]] && echo "    --browser-keep-browser \\" >&2
        [[ "$browser_hide_window" == "true" ]] && echo "    --browser-hide-window \\" >&2
        [[ "$ORACLE_SUPPORTS_NOTIFY" == "true" ]] && echo "    --notify \\" >&2
        echo "    --heartbeat 30 \\" >&2
        echo "    -p \"<prompt>\"" >&2
        exit $EXIT_SUCCESS
    fi

    # Render mode
    if [[ "$render" == "true" ]]; then
        local render_args=("--render")
        [[ "$copy" == "true" ]] && render_args+=("--copy")

        print_info "Rendering bundle for manual use..."
        "${ORACLE_CMD[@]}" "${file_args[@]}" "${render_args[@]}" -p "$prompt"
        exit $EXIT_SUCCESS
    fi

    # Acquire lock to prevent concurrent runs of the same workflow/round.
    if ! acquire_lock "$workflow" "$round_num"; then
        print_error "Another APR process is already running round $round_num for workflow '$workflow'"
        print_info "Wait for it to complete or check 'apr status'"
        exit $EXIT_CONFIG_ERROR
    fi

    # Build Oracle command
    local oracle_args=(
        --engine browser
        -m "$model"
        "${file_args[@]}"
        --browser-attachments never  # Paste inline, never upload as files
        --slug "$slug"
        --write-output "$output_file"
        --files-report
        --heartbeat 30
    )

    [[ "$ORACLE_SUPPORTS_NOTIFY" == "true" ]] && oracle_args+=(--notify)
    [[ "$manual_login" == "true" ]] && oracle_args+=(--browser-manual-login)
    [[ "$keep_browser" == "true" ]] && oracle_args+=(--browser-keep-browser)
    [[ "$browser_hide_window" == "true" ]] && oracle_args+=(--browser-hide-window)
    oracle_args+=(-p "$prompt")

    verbose "Oracle command: ${ORACLE_CMD[*]} ${oracle_args[*]}"
    verbose "Output file: $output_file"
    verbose "Session slug: $slug"

    # Create output directory
    mkdir -p "$(dirname "$output_file")"

    # Execute
    print_info "Starting GPT Pro Extended Reasoning review..."
    print_dim "This may take 10-60 minutes depending on complexity."
    echo "" >&2

    if [[ "$manual_login" == "true" ]]; then
        print_warning "Manual login mode enabled"
        print_dim "Chrome will open - log into ChatGPT if prompted"
        print_dim "Your session will be saved for future runs"
        echo "" >&2
    fi

    if [[ "$wait_mode" == "true" ]]; then
        print_info "Running in foreground (--wait)..."
        [[ "$enable_retry" == "true" ]] && print_dim "Auto-retry enabled (up to $MAX_RETRY_ATTEMPTS attempts)"
        print_dim "Elapsed time will be shown on completion."
        echo "" >&2
        local start_time oracle_exit=0
        start_time=$(date +%s)

        # Use auto-retry wrapper if enabled
        if [[ "$enable_retry" == "true" ]]; then
            run_oracle_with_retry "${oracle_args[@]}" || oracle_exit=$?
        else
            "${ORACLE_CMD[@]}" "${oracle_args[@]}" || oracle_exit=$?
        fi

        local end_time elapsed_secs elapsed_fmt
        end_time=$(date +%s)
        elapsed_secs=$((end_time - start_time))
        # Format elapsed time as HH:MM:SS or MM:SS
        if (( elapsed_secs >= 3600 )); then
            elapsed_fmt=$(printf '%d:%02d:%02d' $((elapsed_secs/3600)) $((elapsed_secs%3600/60)) $((elapsed_secs%60)))
        else
            elapsed_fmt=$(printf '%d:%02d' $((elapsed_secs/60)) $((elapsed_secs%60)))
        fi
        echo "" >&2

        if [[ $oracle_exit -eq 0 ]]; then
            # Validate output file for completeness
            if ! validate_output_file "$output_file"; then
                print_warning "Output validation failed: $OUTPUT_VALIDATION_REASON"
                print_info "Attempting automatic recovery via Oracle session reattach..."
                echo "" >&2

                # Try to recover via Oracle session reattach
                local recovery_success=false
                local recovery_output_file="${output_file}.recovery"

                # Wait a bit for ChatGPT to complete if it's still generating
                print_dim "Waiting 30s for ChatGPT to complete generation..."
                sleep 30

                # Try to get the full output via session reattach
                if "${ORACLE_CMD[@]}" session "$slug" --write-output "$recovery_output_file" 2>/dev/null; then
                    if validate_output_file "$recovery_output_file"; then
                        # Recovery successful - replace truncated output
                        mv "$recovery_output_file" "$output_file"
                        OUTPUT_VALIDATION_REASON=""
                        recovery_success=true
                        print_success "Recovery successful! Full output retrieved via session reattach."
                    else
                        rm -f "$recovery_output_file"
                        verbose "Recovery output also invalid: $OUTPUT_VALIDATION_REASON"
                    fi
                else
                    # Clean up any partial recovery file that might have been created
                    rm -f "$recovery_output_file" 2>/dev/null
                    verbose "Oracle session reattach failed for slug: $slug"
                fi

                if [[ "$recovery_success" != "true" ]]; then
                    print_error "Automatic recovery failed"
                    print_warning "The response was truncated by Oracle's browser automation."
                    print_info "This happens when GPT Pro Extended Thinking pauses during reasoning."
                    echo "" >&2
                    print_info "Manual recovery options:"
                    print_info "  1. Re-run the round: apr run $round_num --wait"
                    print_info "  2. Check the Oracle session: apr attach $slug"
                    print_info "  3. File an issue if this persists: https://github.com/steipete/oracle/issues"
                    echo "" >&2
                    print_info "Partial output saved to: $output_file"
                    # Continue but mark as incomplete for metrics
                fi
            fi

            if [[ -z "$OUTPUT_VALIDATION_REASON" ]]; then
                print_success "Review complete! (${elapsed_fmt} elapsed)"
                print_info "Output saved to: $output_file"
            fi

            # Best-effort metrics collection (skip if output is invalid)
            if [[ -n "$OUTPUT_VALIDATION_REASON" ]]; then
                print_warning "Skipping metrics collection due to invalid output"
            elif command -v jq &>/dev/null; then
                local doc_metrics round_record
                doc_metrics=$(collect_round_document_metrics "$workflow" "$round_num" \
                    "$readme_path" "$spec_path" "$impl_path" "$output_file") || {
                    print_warning "Metrics collection failed; continuing without analytics"
                }

                if [[ -n "${doc_metrics:-}" ]]; then
                    round_record=$(jq -nc \
                        --argjson num "$round_num" \
                        --arg ts "$(iso_timestamp)" \
                        --argjson docs "$doc_metrics" \
                        '{
                            round: $num,
                            timestamp: $ts,
                            documents: {
                                readme: $docs.readme,
                                spec: $docs.spec,
                                implementation: $docs.implementation
                            },
                            output: $docs.output,
                            changes_from_previous: null
                        }') || {
                        print_warning "Failed to build round metrics record"
                    }

                    if [[ -n "${round_record:-}" ]]; then
                        local change_metrics
                        change_metrics=$(calculate_round_changes "$workflow" "$round_num" "$output_dir") || {
                            print_warning "Failed to calculate change metrics"
                            change_metrics="null"
                        }

                        if [[ -n "${change_metrics:-}" ]]; then
                            round_record=$(echo "$round_record" | jq -c --argjson changes "$change_metrics" \
                                '.changes_from_previous = $changes') || {
                                print_warning "Failed to attach change metrics"
                            }
                        fi

                        if metrics_write_round "$workflow" "$round_num" "$round_record"; then
                            verbose "Metrics written for round $round_num"
                        else
                            print_warning "Failed to write round metrics"
                        fi

                        if update_convergence_metrics "$workflow"; then
                            local confidence is_high
                            if confidence=$(metrics_read "$workflow" | jq -r '.convergence.confidence // 0' 2>/dev/null); then
                                if command -v bc &>/dev/null; then
                                    is_high=$(echo "$confidence >= 0.75" | bc 2>/dev/null || echo "0")
                                    if [[ "$is_high" -eq 1 ]]; then
                                        print_success "Specification appears to be converging (confidence: $confidence)"
                                    else
                                        print_dim "Convergence confidence: $confidence"
                                    fi
                                fi
                            else
                                print_warning "Failed to read convergence metrics"
                            fi
                        else
                            print_warning "Failed to update convergence metrics"
                        fi
                    fi
                fi
            else
                print_warning "jq not available; skipping metrics collection"
            fi
        else
            print_error "Oracle failed after ${elapsed_fmt} (exit code: $oracle_exit)"
            exit $oracle_exit
        fi
    else
        (
            # Bash will SIGHUP background jobs on shell exit. Ignore HUP so the
            # background run keeps going after `apr run` returns.
            trap "" HUP
            if [[ "$enable_retry" == "true" ]]; then
                run_oracle_with_retry "${oracle_args[@]}"
            else
                "${ORACLE_CMD[@]}" "${oracle_args[@]}"
            fi
        ) &
        local oracle_pid=$!

        # Brief delay to verify process started
        sleep 0.5

        # Verify the process is actually running
        if ! kill -0 "$oracle_pid" 2>/dev/null; then
            release_lock 2>/dev/null || true
            print_error "Oracle process failed to start"
            print_info "Try running with --wait to see error output"
            exit $EXIT_DEPENDENCY_ERROR
        fi

        background_lock_detach_parent "$oracle_pid"

        print_success "Oracle running in background (PID: $oracle_pid)"
        echo "" >&2

        if [[ "$GUM_AVAILABLE" == "true" && "$QUIET_MODE" != "true" ]]; then
            gum style \
                --border rounded \
                --border-foreground 39 \
                --padding "1 2" \
                "$(gum style --foreground 214 --bold "MONITORING COMMANDS")" \
                "" \
                "Check status:      $(gum style --foreground 82 "apr status")" \
                "Attach to session: $(gum style --foreground 82 "apr attach $slug")" \
                "View with output:  $(gum style --foreground 82 "${ORACLE_CMD[*]} session $slug --render")" >&2
        elif [[ "$QUIET_MODE" != "true" ]]; then
            echo -e "  ${BOLD}${CYAN}MONITORING COMMANDS${NC}" >&2
            echo "" >&2
            echo -e "  Check status:      ${GREEN}apr status${NC}" >&2
            echo -e "  Attach to session: ${GREEN}apr attach $slug${NC}" >&2
            echo -e "  View with output:  ${GREEN}${ORACLE_CMD[*]} session $slug --render${NC}" >&2
        fi

        echo "" >&2
        print_info "Output will be saved to: $output_file"
    fi

    echo "" >&2
    print_header "NEXT STEPS AFTER REVIEW COMPLETES"

    # Contextual tips based on round number and options
    local tips=()
    tips+=("Review the output in $output_file")
    tips+=("Integrate feedback into your specification")
    tips+=("Update README to reflect changes")

    if [[ -n "$impl_path" ]]; then
        tips+=("Harmonize implementation doc")
    fi

    tips+=("Commit changes and repeat")

    # Show numbered steps
    local step=1
    for tip in "${tips[@]}"; do
        echo "$step. $tip" >&2
        ((step++))
    done

    echo "" >&2

    # Contextual suggestions
    if [[ "$round_num" == "1" && "$manual_login" != "true" ]]; then
        print_dim "Tip: For first runs, use --login to handle browser authentication"
    elif [[ -n "$impl_every_n" && "$impl_every_n" =~ ^[0-9]+$ && "$impl_every_n" -gt 0 ]]; then
        local next_impl_round=$(( ((round_num / impl_every_n) + 1) * impl_every_n ))
        if [[ "$include_impl" == "true" ]]; then
            print_dim "Tip: This round includes impl (every $impl_every_n rounds)"
        else
            print_dim "Tip: Impl auto-included every $impl_every_n rounds (next: round $next_impl_round)"
        fi
    elif [[ "$round_num" -ge 3 && "$include_impl" != "true" && -n "$impl_path" ]]; then
        print_dim "Tip: Try impl_every_n: 4 in workflow to auto-include impl periodically"
    elif [[ "$round_num" -ge 5 ]]; then
        print_dim "Tip: After 5+ rounds, look for convergence - similar feedback suggests stability"
    fi
}

# -----------------------------------------------------------------------------
# Status & Session Management
# -----------------------------------------------------------------------------

show_status() {
    print_banner
    print_header "ORACLE SESSION STATUS"
    if ! is_non_negative_int "${STATUS_HOURS:-}"; then
        STATUS_HOURS=72
    fi
    print_info "Showing sessions from last ${STATUS_HOURS}h"
    echo "" >&2
    "${ORACLE_CMD[@]}" status --hours "$STATUS_HOURS"
}

attach_session() {
    local session="$1"
    print_banner
    print_info "Attaching to session: $session"
    echo "" >&2
    "${ORACLE_CMD[@]}" session "$session" --render
}

# -----------------------------------------------------------------------------
# List Workflows
# -----------------------------------------------------------------------------

list_workflows() {
    print_banner
    print_header "CONFIGURED WORKFLOWS"
    echo "" >&2

    local workflow_dir="$CONFIG_DIR/workflows"
    if [[ ! -d "$workflow_dir" ]]; then
        print_warning "No workflows configured yet"
        print_info "Run 'apr setup' to create your first workflow"
        exit $EXIT_SUCCESS
    fi

    # Get default workflow
    local default_wf=""
    if [[ -f "$CONFIG_DIR/config.yaml" ]]; then
        default_wf=$(get_config_value "default_workflow" "$CONFIG_DIR/config.yaml")
    fi

    local found_any=false
    for config in "$workflow_dir"/*.yaml; do
        [[ -f "$config" ]] || continue
        found_any=true
        local name desc is_default=""
        name=$(basename "$config" .yaml)
        desc=$(yaml_unquote "$(get_config_value "description" "$config")")

        if [[ "$name" == "$default_wf" ]]; then
            is_default=" (default)"
        fi

        if [[ "$GUM_AVAILABLE" == "true" ]]; then
            if [[ -n "$is_default" ]]; then
                gum style --foreground 82 --bold "$name" --suffix " $(gum style --faint '(default)')" >&2
            else
                gum style --foreground 82 --bold "$name" >&2
            fi
            gum style --faint "  $desc" >&2
        else
            echo -e "  ${GREEN}${BOLD}$name${NC}${DIM}$is_default${NC}" >&2
            echo -e "    ${DIM}$desc${NC}" >&2
        fi
        echo "" >&2
    done

    if [[ "$found_any" == "false" ]]; then
        print_warning "No workflows configured yet"
        print_info "Run 'apr setup' to create your first workflow"
    fi
}

# -----------------------------------------------------------------------------
# History
# -----------------------------------------------------------------------------

show_history() {
    local workflow="${WORKFLOW:-default}"

    # Verify workflow exists
    local workflow_file="$CONFIG_DIR/workflows/${workflow}.yaml"
    if [[ ! -f "$workflow_file" ]]; then
        print_error "Workflow '$workflow' not found"
        print_info "Run 'apr list' to see available workflows"
        exit $EXIT_CONFIG_ERROR
    fi

    print_banner
    print_header "REVISION HISTORY: $workflow"
    echo "" >&2

    local rounds_dir="$CONFIG_DIR/rounds/$workflow"
    if [[ ! -d "$rounds_dir" ]]; then
        print_warning "No rounds recorded yet for workflow '$workflow'"
        print_info "Run 'apr run 1' to start your first revision round"
        exit $EXIT_SUCCESS
    fi

    # Collect all round files and find the latest
    local round_entries=()
    local latest_round=0
    for round_file in "$rounds_dir"/round_*.md; do
        [[ -f "$round_file" ]] || continue
        local num
        num=$(basename "$round_file" .md | sed 's/round_//')
        if [[ "$num" =~ ^[0-9]+$ ]]; then
            round_entries+=("${num}|${round_file}")
            if (( num > latest_round )); then
                latest_round=$num
            fi
        fi
    done

    if [[ ${#round_entries[@]} -eq 0 ]]; then
        print_warning "No rounds recorded yet for workflow '$workflow'"
        print_info "Run 'apr run 1' to start your first revision round"
        exit $EXIT_SUCCESS
    fi

    local sorted_entries=()
    if [[ ${#round_entries[@]} -gt 0 ]]; then
        mapfile -t sorted_entries < <(printf '%s\n' "${round_entries[@]}" | sort -n -t '|' -k1,1)
    fi

    # Display each round with enhanced info
    for entry in "${sorted_entries[@]}"; do
        local round_num round_file size mod_date mod_ts first_line is_latest=""
        round_num=${entry%%|*}
        round_file=${entry#*|}
        size=$(du -h "$round_file" 2>/dev/null | cut -f1)
        # Cross-platform date: try GNU stat, then BSD stat, then date fallback
        mod_ts=$(stat -c '%Y' "$round_file" 2>/dev/null || stat -f '%m' "$round_file" 2>/dev/null || echo "")
        if [[ -n "$mod_ts" && "$mod_ts" =~ ^[0-9]+$ ]]; then
            mod_date=$(date -d "@$mod_ts" '+%Y-%m-%d %H:%M' 2>/dev/null || date -r "$mod_ts" '+%Y-%m-%d %H:%M' 2>/dev/null || echo "N/A")
        else
            mod_date="N/A"
        fi

        # Get first non-empty line as preview
        first_line=$(grep -m1 '.' "$round_file" 2>/dev/null | head -c 60 | tr '\n' ' ')
        [[ ${#first_line} -eq 60 ]] && first_line="${first_line}..."

        # Mark latest round
        if [[ "$round_num" == "$latest_round" ]]; then
            is_latest=" ${GREEN}(latest)${NC}"
        fi

        if [[ "$GUM_AVAILABLE" == "true" ]]; then
            echo "$(gum style --foreground 82 --bold "Round $round_num")${is_latest}  $(gum style --faint "$size  $mod_date")" >&2
            [[ -n "$first_line" ]] && gum style --faint "    $first_line" >&2
        else
            echo -e "  ${CYAN}${BOLD}Round $round_num${NC}${is_latest}  ${DIM}$size  $mod_date${NC}" >&2
            [[ -n "$first_line" ]] && echo -e "    ${DIM}$first_line${NC}" >&2
        fi
        echo "" >&2
    done

    # Summary
    print_dim "Total: ${#round_entries[@]} round(s). Use 'apr show <round>' to view content."
}

# -----------------------------------------------------------------------------
# Show Round Output
# -----------------------------------------------------------------------------

show_round() {
    local round_num="$1"
    local workflow="${WORKFLOW:-default}"

    # Verify workflow exists
    local workflow_file="$CONFIG_DIR/workflows/${workflow}.yaml"
    if [[ ! -f "$workflow_file" ]]; then
        print_error "Workflow '$workflow' not found"
        print_info "Run 'apr list' to see available workflows"
        exit $EXIT_CONFIG_ERROR
    fi

    local output_file="$CONFIG_DIR/rounds/$workflow/round_${round_num}.md"

    if [[ ! -f "$output_file" ]]; then
        print_error "Round $round_num not found for workflow '$workflow'"
        print_info "Run 'apr history' to see available rounds"
        exit $EXIT_CONFIG_ERROR
    fi

    # If pager is available and stdout is a tty, use it
    if [[ -t 1 ]]; then
        if command -v bat &>/dev/null; then
            bat --style=plain --language=markdown "$output_file"
        elif command -v less &>/dev/null; then
            less "$output_file"
        else
            cat "$output_file"
        fi
    else
        cat "$output_file"
    fi
}

# -----------------------------------------------------------------------------
# Diff Rounds - Compare two round outputs
# -----------------------------------------------------------------------------

diff_rounds() {
    local arg1="$1"
    local arg2="${2:-}"
    local workflow="${WORKFLOW:-default}"

    verbose "diff_rounds: arg1=$arg1 arg2=${arg2:-<none>} workflow=$workflow"

    # Verify workflow exists
    local workflow_file="$CONFIG_DIR/workflows/${workflow}.yaml"
    if [[ ! -f "$workflow_file" ]]; then
        print_error "Workflow '$workflow' not found"
        print_info "Run 'apr list' to see available workflows"
        exit $EXIT_CONFIG_ERROR
    fi

    local rounds_dir="$CONFIG_DIR/rounds/$workflow"
    local round_old
    local round_new

    # Argument normalization
    # Case 1: apr diff 5       -> old=4, new=5
    # Case 2: apr diff 3 5     -> old=3, new=5 (Standard diff order)
    if [[ -z "$arg2" ]]; then
        round_new="$arg1"
        if [[ "$round_new" -le 1 ]]; then
            print_error "Round 1 has no previous round to compare with"
            print_info "Usage: apr diff <round>"
            exit $EXIT_USAGE_ERROR
        fi
        round_old=$((round_new - 1))
        verbose "Auto-selected round_old=$round_old (previous round)"
    else
        round_old="$arg1"
        round_new="$arg2"
        # Normalize: ensure round_old < round_new for intuitive diff order
        if [[ "$round_old" -gt "$round_new" ]]; then
            local tmp="$round_old"
            round_old="$round_new"
            round_new="$tmp"
            verbose "Normalized round order: old=$round_old new=$round_new"
        fi
    fi

    local file_old="$rounds_dir/round_${round_old}.md"
    local file_new="$rounds_dir/round_${round_new}.md"

    # Validate both files exist
    if [[ ! -f "$file_old" ]]; then
        print_error "Round $round_old not found for workflow '$workflow'"
        print_info "Run 'apr history' to see available rounds"
        exit $EXIT_CONFIG_ERROR
    fi
    if [[ ! -f "$file_new" ]]; then
        print_error "Round $round_new not found for workflow '$workflow'"
        print_info "Run 'apr history' to see available rounds"
        exit $EXIT_CONFIG_ERROR
    fi

    local size_old size_new
    size_old=$(du -h "$file_old" 2>/dev/null | cut -f1)
    size_new=$(du -h "$file_new" 2>/dev/null | cut -f1)

    print_banner
    print_header "ROUND COMPARISON: $round_old → $round_new"
    echo "" >&2
    print_info "Comparing Round $round_old ($size_old) with Round $round_new ($size_new)"
    echo "" >&2

    # Use delta if available (beautiful diff), otherwise fall back to diff
    # Note: diff returns 1 when files differ (expected), so we use || true to prevent
    # script exit with set -euo pipefail. Exit code 2 indicates an actual error.
    if command -v delta &>/dev/null; then
        verbose "Using delta for diff"
        delta --side-by-side "$file_old" "$file_new" || true
    elif command -v diff &>/dev/null; then
        verbose "Using diff (delta not available)"
        # Use colored diff if terminal supports it
        if [[ -t 1 ]] && diff --color=auto /dev/null /dev/null 2>/dev/null; then
            if command -v less &>/dev/null; then
                diff --color=auto -u "$file_old" "$file_new" | less -R || true
            else
                diff --color=auto -u "$file_old" "$file_new" || true
            fi
        else
            if [[ -t 1 ]] && command -v less &>/dev/null; then
                diff -u "$file_old" "$file_new" | less || true
            else
                diff -u "$file_old" "$file_new" || true
            fi
        fi
    else
        print_error "No diff tool available (install delta for best experience)"
        exit $EXIT_DEPENDENCY_ERROR
    fi
}

# -----------------------------------------------------------------------------
# Integrate - Generate Claude Code integration prompt
# -----------------------------------------------------------------------------

generate_integration() {
    local round_num="$1"
    local workflow="${WORKFLOW:-default}"
    local output_path="${INTEGRATE_OUTPUT:-}"
    local copy_to_clipboard="${COPY:-false}"

    verbose "generate_integration: round=$round_num workflow=$workflow output=${output_path:-<stdout>} copy=$copy_to_clipboard"

    # Verify workflow exists
    local workflow_file="$CONFIG_DIR/workflows/${workflow}.yaml"
    if [[ ! -f "$workflow_file" ]]; then
        print_error "Workflow '$workflow' not found"
        print_info "Run 'apr list' to see available workflows"
        exit $EXIT_CONFIG_ERROR
    fi

    # Get workflow config
    local spec_path
    spec_path=$(yaml_unquote "$(get_config_value "spec" "$workflow_file")")
    if [[ -z "$spec_path" ]]; then
        print_error "Spec path not configured in workflow '$workflow'"
        print_info "Check 'spec:' in $workflow_file"
        exit $EXIT_CONFIG_ERROR
    fi
    if [[ ! -f "$spec_path" ]]; then
        print_error "Spec file not found: $spec_path"
        print_info "Check 'spec:' in $workflow_file"
        exit $EXIT_CONFIG_ERROR
    fi

    local round_file="$CONFIG_DIR/rounds/$workflow/round_${round_num}.md"
    if [[ ! -f "$round_file" ]]; then
        print_error "Round $round_num not found for workflow '$workflow'"
        print_info "Run 'apr history' to see available rounds"
        exit $EXIT_CONFIG_ERROR
    fi

    local round_size
    round_size=$(du -h "$round_file" 2>/dev/null | cut -f1)

    # Build the integration prompt
    local prompt
    prompt=$(cat <<EOF
First read ALL of the AGENTS.md file and README.md file super carefully
and understand ALL of both! Then use your code investigation agent mode
to fully understand the code and technical architecture of the project.
Read ALL of the specification document at: $spec_path

Now integrate the following feedback from GPT Pro 5.2 Extended Reasoning
(Round $round_num of the APR iterative refinement process). For each
suggestion, carefully evaluate whether you agree with the proposed change.
Then apply the changes you endorse to the specification document.

Be meticulous and use ultrathink.

---

$(cat "$round_file")
EOF
)

    # Output handling
    if [[ -n "$output_path" ]]; then
        # Write to file
        echo "$prompt" > "$output_path"
        print_success "Integration prompt saved to: $output_path"
    elif [[ "$copy_to_clipboard" == "true" ]]; then
        # Copy to clipboard
        if command -v pbcopy &>/dev/null; then
            echo "$prompt" | pbcopy
            print_success "Integration prompt copied to clipboard (pbcopy)"
        elif command -v xclip &>/dev/null; then
            echo "$prompt" | xclip -selection clipboard
            print_success "Integration prompt copied to clipboard (xclip)"
        elif command -v xsel &>/dev/null; then
            echo "$prompt" | xsel --clipboard
            print_success "Integration prompt copied to clipboard (xsel)"
        else
            print_warning "No clipboard tool found (pbcopy, xclip, xsel)"
            print_info "Outputting to stdout instead:"
            echo ""
            echo "$prompt"
        fi
    else
        # Output to stdout
        if [[ "$QUIET_MODE" != "true" ]]; then
            print_banner
            print_header "CLAUDE CODE INTEGRATION PROMPT"
            print_info "Round $round_num ($round_size) for workflow '$workflow'"
            echo "" >&2
            print_dim "Copy the following prompt to Claude Code:"
            echo "" >&2
            echo "─────────────────────────────────────────────────────────────" >&2
        fi
        echo "$prompt"
        if [[ "$QUIET_MODE" != "true" ]]; then
            echo "" >&2
            echo "─────────────────────────────────────────────────────────────" >&2
            echo "" >&2
            print_dim "Tip: Use 'apr integrate $round_num --copy' to copy to clipboard"
        fi
    fi
}

# -----------------------------------------------------------------------------
# Stats - Round analytics and convergence signals
# -----------------------------------------------------------------------------

format_bytes() {
    local bytes="${1:-0}"
    if [[ -z "$bytes" || "$bytes" == "null" ]]; then
        echo "0B"
        return 0
    fi
    if [[ ! "$bytes" =~ ^[0-9]+$ ]]; then
        echo "0B"
        return 0
    fi

    if [[ "$bytes" -ge 1048576 ]]; then
        awk -v b="$bytes" 'BEGIN { printf "%.1fM", b/1048576 }'
    elif [[ "$bytes" -ge 1024 ]]; then
        awk -v b="$bytes" 'BEGIN { printf "%.1fK", b/1024 }'
    else
        echo "${bytes}B"
    fi
}

format_iso_date() {
    local iso="$1"
    if [[ -z "$iso" || "$iso" == "null" ]]; then
        echo "N/A"
        return 0
    fi

    local formatted
    formatted=$(date -d "$iso" '+%Y-%m-%d' 2>/dev/null || true)
    if [[ -n "$formatted" ]]; then
        echo "$formatted"
        return 0
    fi

    formatted=$(date -j -f '%Y-%m-%dT%H:%M:%SZ' "$iso" '+%Y-%m-%d' 2>/dev/null || true)
    if [[ -n "$formatted" ]]; then
        echo "$formatted"
        return 0
    fi

    echo "${iso%%T*}"
}

format_float() {
    local value="$1"
    if [[ -z "$value" || "$value" == "null" ]]; then
        echo "-"
        return 0
    fi
    # Prepend 0 if value starts with .
    if [[ "$value" == .* ]]; then
        value="0$value"
    fi
    if [[ "$value" =~ ^[0-9]+([.][0-9]+)?$ ]]; then
        printf "%.2f" "$value"
    else
        echo "-"
    fi
}

safe_json_num() {
    local json="$1"
    local path="$2"
    local default="${3:-0}"

    local value
    value=$(echo "$json" | jq -r "$path // $default" 2>/dev/null || echo "$default")
    if [[ -z "$value" || "$value" == "null" ]]; then
        echo "$default"
    else
        echo "$value"
    fi
}

generate_sparkline() {
    local values=("$@")
    local count=${#values[@]}
    if [[ $count -eq 0 ]]; then
        verbose "generate_sparkline: no values"
        return 0
    fi
    verbose "generate_sparkline: count=$count"

    local min=${values[0]}
    local max=${values[0]}
    local v
    for v in "${values[@]}"; do
        (( v < min )) && min=$v
        (( v > max )) && max=$v
    done

    local range=$((max - min))
    [[ $range -eq 0 ]] && range=1
    verbose "generate_sparkline: min=$min max=$max range=$range"

    local chars="▁▂▃▄▅▆▇█"
    local sparkline=""
    for v in "${values[@]}"; do
        local idx=$(( (v - min) * 7 / range ))
        sparkline+="${chars:$idx:1}"
    done

    echo "$sparkline"
}

get_trend_arrow() {
    local values=("$@")
    local count=${#values[@]}
    verbose "get_trend_arrow: count=$count"
    if [[ $count -lt 2 ]]; then
        verbose "get_trend_arrow: insufficient values, returning stable"
        echo "→"
        return 0
    fi

    local half=$((count / 2))
    [[ $half -lt 1 ]] && half=1
    local first_sum=0 second_sum=0 i
    for ((i=0; i<half; i++)); do
        first_sum=$((first_sum + values[i]))
    done
    for ((i=half; i<count; i++)); do
        second_sum=$((second_sum + values[i]))
    done

    local first_avg=$((first_sum / half))
    local second_count=$((count - half))
    [[ $second_count -lt 1 ]] && second_count=1
    local second_avg=$((second_sum / second_count))
    verbose "get_trend_arrow: first_avg=$first_avg second_avg=$second_avg"

    if (( second_avg < first_avg * 80 / 100 )); then
        echo "↘"
    elif (( second_avg > first_avg * 120 / 100 )); then
        echo "↗"
    else
        echo "→"
    fi
}

get_convergence_indicator() {
    local confidence="${1:-0}"
    local indicator="◌"
    verbose "get_convergence_indicator: confidence=$confidence"

    if command -v bc &>/dev/null; then
        if [[ $(echo "$confidence >= 0.90" | bc 2>/dev/null || echo 0) -eq 1 ]]; then
            indicator="●"
        elif [[ $(echo "$confidence >= 0.75" | bc 2>/dev/null || echo 0) -eq 1 ]]; then
            indicator="◉"
        elif [[ $(echo "$confidence >= 0.50" | bc 2>/dev/null || echo 0) -eq 1 ]]; then
            indicator="○"
        fi
    fi

    verbose "get_convergence_indicator: indicator=$indicator"
    echo "$indicator"
}

format_changes() {
    local added="${1:-}"
    local deleted="${2:-}"

    if [[ -z "$added" || "$added" == "null" ]]; then
        echo "-"
        return 0
    fi
    if [[ -z "$deleted" || "$deleted" == "null" ]]; then
        deleted="0"
    fi
    echo "+${added}-${deleted}"
}

show_stats_full() {
    local workflow="$1"

    if ! command -v jq &>/dev/null; then
        print_warning "jq not available; falling back to basic stats"
        return 1
    fi

    local metrics
    metrics=$(metrics_read "$workflow") || return 1

    local round_count
    round_count=$(echo "$metrics" | jq -r '.rounds | length' 2>/dev/null || echo "0")
    verbose "show_stats_full: rounds=$round_count"

    if [[ "$round_count" -lt 1 ]]; then
        print_warning "No rounds recorded yet for workflow '$workflow'"
        print_info "Run 'apr run 1' to start your first revision round"
        return 0
    fi

    local has_backfilled
    has_backfilled=$(echo "$metrics" | jq -r 'any(.rounds[]?; .backfilled == true) // false' 2>/dev/null || echo "false")

    local average_size
    average_size=$(echo "$metrics" | jq -r '[.rounds[].output.char_count // 0] | add / length' 2>/dev/null || echo "0")
    average_size=${average_size%.*}
    if [[ ! "$average_size" =~ ^[0-9]+$ ]]; then
        average_size=0
    fi
    local avg_human
    avg_human=$(format_bytes "$average_size")

    local confidence
    confidence=$(echo "$metrics" | jq -r '.convergence.confidence // 0' 2>/dev/null || echo "0")
    verbose "show_stats_full: avg_size=$average_size confidence=$confidence"
    local indicator
    indicator=$(get_convergence_indicator "$confidence")

    local estimated_remaining
    estimated_remaining=$(echo "$metrics" | jq -r '.convergence.estimated_rounds_remaining // ""' 2>/dev/null || echo "")

    print_banner
    print_header "REVISION STATISTICS: $workflow"
    echo "" >&2
    if [[ "$has_backfilled" == "true" ]]; then
        print_dim "Note: Some metrics were backfilled and may be less precise"
        echo "" >&2
    fi

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style \
            --border rounded \
            --border-foreground 212 \
            --padding "1 2" \
            "Rounds: ${round_count}    Avg Size: ${avg_human}    Status: ${indicator}" \
            "Convergence: $(printf "%.0f" "$(echo "$confidence * 100" | bc 2>/dev/null || echo 0)")% confidence" \
            "Estimated remaining: ${estimated_remaining:-N/A} rounds" >&2
    else
        echo "┌────────────────────────────────────────────────────────────┐" >&2
        printf "│  Rounds: %-4s Avg Size: %-6s Status: %-2s              │\n" "$round_count" "$avg_human" "$indicator" >&2
        printf "│  Convergence: %-5s confidence                           │\n" "$(printf "%.0f%%" "$(echo "$confidence * 100" | bc 2>/dev/null || echo 0)")" >&2
        printf "│  Estimated remaining: %-5s rounds                      │\n" "${estimated_remaining:-N/A}" >&2
        echo "└────────────────────────────────────────────────────────────┘" >&2
    fi

    echo "" >&2

    local backfilled
    backfilled=$(echo "$metrics" | jq -r 'any(.rounds[]?; .backfilled == true)' 2>/dev/null || echo "false")
    if [[ "$backfilled" == "true" ]]; then
        print_dim "Note: Some rounds were backfilled (limited accuracy for structure metrics)"
        echo "" >&2
    fi

    local output_sizes=()
    mapfile -t output_sizes < <(echo "$metrics" | jq -r '.rounds | sort_by(.round) | .[].output.char_count // 0')
    local change_values=()
    mapfile -t change_values < <(echo "$metrics" | jq -r '.rounds | sort_by(.round) | map((.changes_from_previous.diff_ratio // 0) * 100 | floor) | .[]')
    local similarity_values=()
    mapfile -t similarity_values < <(echo "$metrics" | jq -r '.rounds | sort_by(.round) | map((.changes_from_previous.similarity_score // 0) * 100 | floor) | .[]')

    if [[ ${#output_sizes[@]} -ge 3 ]]; then
        verbose "show_stats_full: rendering sparklines"
        local output_spark change_spark similarity_spark
        output_spark=$(generate_sparkline "${output_sizes[@]}")
        change_spark=$(generate_sparkline "${change_values[@]}")
        similarity_spark=$(generate_sparkline "${similarity_values[@]}")

        echo "TREND SPARKLINES" >&2
        printf "  Output Size:  %s %s\n" "$output_spark" "$(get_trend_arrow "${output_sizes[@]}")" >&2
        printf "  Changes:      %s %s\n" "$change_spark" "$(get_trend_arrow "${change_values[@]}")" >&2
        printf "  Similarity:   %s %s\n" "$similarity_spark" "$(get_trend_arrow "${similarity_values[@]}")" >&2
        echo "" >&2
    fi

    echo "ROUND DETAILS" >&2
    verbose "show_stats_full: rendering round table"
    printf "  %-3s │ %-7s │ %-9s │ %-7s │ %-10s\n" "#" "Output" "Changes" "Similar" "Modified" >&2
    echo "  ───┼─────────┼───────────┼─────────┼────────────" >&2

    local round_json
    while IFS= read -r round_json; do
        local round_num output_size added deleted similarity ts date_only
        round_num=$(safe_json_num "$round_json" '.round' "0")
        output_size=$(safe_json_num "$round_json" '.output.char_count' "0")
        added=$(safe_json_num "$round_json" '.changes_from_previous.lines_added' "null")
        deleted=$(safe_json_num "$round_json" '.changes_from_previous.lines_deleted' "null")
        similarity=$(safe_json_num "$round_json" '.changes_from_previous.similarity_score' "null")
        ts=$(echo "$round_json" | jq -r '.timestamp // ""' 2>/dev/null || echo "")
        date_only=$(format_iso_date "$ts")

        printf "  %-3s │ %-7s │ %-9s │ %-7s │ %-10s\n" \
            "$round_num" \
            "$(format_bytes "$output_size")" \
            "$(format_changes "$added" "$deleted")" \
            "$(format_float "$similarity")" \
            "$date_only" >&2
    done < <(echo "$metrics" | jq -c '.rounds | sort_by(.round) | .[]')

    echo "" >&2

    local output_signal change_signal similarity_signal
    output_signal=$(safe_json_num "$metrics" '.convergence.signals.output_size_trend' "0")
    change_signal=$(safe_json_num "$metrics" '.convergence.signals.change_velocity' "0")
    similarity_signal=$(safe_json_num "$metrics" '.convergence.signals.similarity_trend' "0")
    verbose "show_stats_full: signals output=$output_signal change=$change_signal similarity=$similarity_signal"

    echo "CONVERGENCE SIGNALS" >&2
    printf "  %s Output size trend (%.2f)\n" "$( [[ $(echo "$output_signal >= 0.7" | bc 2>/dev/null || echo 0) -eq 1 ]] && echo "✓" || echo "·" )" "$output_signal" >&2
    printf "  %s Change velocity (%.2f)\n" "$( [[ $(echo "$change_signal >= 0.7" | bc 2>/dev/null || echo 0) -eq 1 ]] && echo "✓" || echo "·" )" "$change_signal" >&2
    printf "  %s Similarity trend (%.2f)\n" "$( [[ $(echo "$similarity_signal >= 0.7" | bc 2>/dev/null || echo 0) -eq 1 ]] && echo "✓" || echo "·" )" "$similarity_signal" >&2
    echo "" >&2

    if [[ "$STATS_DETAILED" == "true" ]]; then
        local last_round
        last_round=$(echo "$metrics" | jq -c '.rounds | sort_by(.round) | .[-1]')
        if [[ -n "$last_round" ]]; then
            echo "DOCUMENT METRICS (LATEST ROUND)" >&2
            local doc_section doc_name
            for doc_name in readme spec implementation; do
                doc_section=$(echo "$last_round" | jq -c --arg name "$doc_name" '.documents[$name] // null' 2>/dev/null || echo "null")
                if [[ "$doc_section" == "null" || -z "$doc_section" ]]; then
                    continue
                fi
                local chars words lines headings code_blocks links lists
                chars=$(safe_json_num "$doc_section" '.char_count' "0")
                words=$(safe_json_num "$doc_section" '.word_count' "0")
                lines=$(safe_json_num "$doc_section" '.line_count' "0")
                headings=$(safe_json_num "$doc_section" '.heading_count' "0")
                code_blocks=$(safe_json_num "$doc_section" '.code_block_count' "0")
                links=$(safe_json_num "$doc_section" '.link_count' "0")
                lists=$(safe_json_num "$doc_section" '.list_item_count' "0")

                printf "  %s: chars=%s words=%s lines=%s headings=%s code=%s links=%s lists=%s\n" \
                    "$doc_name" "$chars" "$words" "$lines" "$headings" "$code_blocks" "$links" "$lists" >&2
            done
            echo "" >&2
        fi
    fi

    local confidence_msg
    if [[ $(echo "$confidence >= 0.90" | bc 2>/dev/null || echo 0) -eq 1 ]]; then
        confidence_msg="Specification appears stable. Consider stopping soon."
    elif [[ $(echo "$confidence >= 0.75" | bc 2>/dev/null || echo 0) -eq 1 ]]; then
        confidence_msg="Nearly converged. Consider 1-2 more rounds."
    elif [[ $(echo "$confidence >= 0.50" | bc 2>/dev/null || echo 0) -eq 1 ]]; then
        confidence_msg="Approaching convergence. More rounds recommended."
    else
        confidence_msg="Significant changes still occurring."
    fi
    print_info "$confidence_msg"
}

metrics_filter_for_export() {
    local metrics="$1"
    local rounds_spec="${2:-}"
    local since="${3:-}"
    local filtered="$metrics"

    if [[ -n "$rounds_spec" ]]; then
        if [[ "$rounds_spec" =~ ^[0-9]+-[0-9]+$ ]]; then
            local start end
            start=${rounds_spec%-*}
            end=${rounds_spec#*-}
            if (( start > end )); then
                print_error "Invalid --rounds range: start greater than end"
                return 1
            fi
            filtered=$(echo "$filtered" | jq --argjson start "$start" --argjson end "$end" \
                '.rounds |= map(select(.round >= $start and .round <= $end))')
        elif [[ "$rounds_spec" =~ ^[0-9]+(,[0-9]+)*$ ]]; then
            local rounds_list_json
            IFS=',' read -r -a rounds_list <<< "$rounds_spec"
            rounds_list_json=$(printf '%s\n' "${rounds_list[@]}" | jq -Rsc 'split("\n") | map(select(length>0)) | map(tonumber)')
            filtered=$(echo "$filtered" | jq --argjson list "$rounds_list_json" \
                '.rounds |= map(select(.round as $r | $list | index($r)))')
        else
            print_error "Invalid --rounds format: $rounds_spec"
            print_info "Use N-M or comma-separated list (e.g. 1,3,5)"
            return 1
        fi
    fi

    if [[ -n "$since" ]]; then
        filtered=$(echo "$filtered" | jq --arg since "$since" \
            '.rounds |= map(select(.timestamp != null and .timestamp >= $since))')
    fi

    printf '%s\n' "$filtered"
}

export_json() {
    local metrics="$1"
    local output_file="${2:-}"

    if [[ -n "$output_file" ]]; then
        echo "$metrics" | jq '.' > "$output_file"
        print_success "Exported JSON to: $output_file"
    else
        echo "$metrics" | jq '.'
    fi
}

export_csv() {
    local metrics="$1"
    local output_file="${2:-}"

    local csv_output
    csv_output=$(echo "$metrics" | jq -r '
        (.convergence.confidence // "") as $conv
        | (["round","timestamp","output_chars","output_words","output_lines","lines_added","lines_deleted","similarity","convergence_score"] | @csv),
          (.rounds[] | [
              .round,
              .timestamp,
              (.output.char_count // ""),
              (.output.word_count // ""),
              (.output.line_count // ""),
              (.changes_from_previous.lines_added // ""),
              (.changes_from_previous.lines_deleted // ""),
              (.changes_from_previous.similarity_score // ""),
              $conv
          ] | @csv)
    ')

    if [[ -n "$output_file" ]]; then
        printf '%s\n' "$csv_output" > "$output_file"
        print_success "Exported CSV to: $output_file"
    else
        printf '%s\n' "$csv_output"
    fi
}

export_markdown() {
    local metrics="$1"
    local output_file="${2:-}"

    local workflow round_count convergence avg_size avg_human generated
    workflow=$(echo "$metrics" | jq -r '.workflow // "default"' 2>/dev/null || echo "default")
    round_count=$(echo "$metrics" | jq -r '.rounds | length' 2>/dev/null || echo "0")
    convergence=$(echo "$metrics" | jq -r '.convergence.confidence // 0' 2>/dev/null || echo "0")
    avg_size=$(echo "$metrics" | jq -r '[.rounds[].output.char_count // 0] | if length > 0 then (add / length | floor) else 0 end' 2>/dev/null || echo "0")
    if [[ -z "$convergence" || "$convergence" == "null" ]]; then
        convergence=0
    fi
    if [[ ! "$avg_size" =~ ^[0-9]+$ ]]; then
        avg_size=0
    fi
    avg_human=$(format_bytes "$avg_size")
    generated=$(date -u +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date +"%Y-%m-%dT%H:%M:%SZ")

    local convergence_pct
    convergence_pct=$(awk -v c="$convergence" 'BEGIN { printf "%.0f", c * 100 }')

    local rounds_md
    rounds_md=$(echo "$metrics" | jq -r '
        .rounds | sort_by(.round) | .[] |
        "### Round \(.round) - \(.timestamp // "N/A")\n" +
        "- Output: \(.output.char_count // "N/A") chars, \(.output.line_count // "N/A") lines\n" +
        (if .changes_from_previous == null then
            "- Changes: N/A\n- Similarity: N/A\n"
         else
            "- Changes: +\(.changes_from_previous.lines_added // "-") / -\(.changes_from_previous.lines_deleted // "-")\n" +
            "- Similarity: \((.changes_from_previous.similarity_score // 0) * 100 | floor)%\n"
         end) + "\n"
    ')

    local md_output
    md_output=$(cat <<EOF
# APR Metrics Report: $workflow

Generated: $generated

## Summary

| Metric | Value |
|--------|-------|
| Total Rounds | $round_count |
| Convergence | ${convergence_pct}% |
| Average Output Size | $avg_human |

## Round Details

$rounds_md
EOF
)

    if [[ -n "$output_file" ]]; then
        printf '%s\n' "$md_output" > "$output_file"
        print_success "Exported Markdown to: $output_file"
    else
        printf '%s\n' "$md_output"
    fi
}

export_metrics() {
    local workflow="$1"
    local format="${2:-json}"
    local output_file="${3:-}"
    local rounds_spec="${4:-}"
    local since="${5:-}"

    if ! command -v jq &>/dev/null; then
        print_error "jq is required for metrics export"
        return 1
    fi

    if ! metrics_exists "$workflow"; then
        print_error "No metrics available for workflow '$workflow'"
        print_info "Run 'apr backfill' to generate metrics from existing rounds"
        return 1
    fi

    local metrics
    metrics=$(metrics_read "$workflow") || return 1
    metrics=$(metrics_filter_for_export "$metrics" "$rounds_spec" "$since") || return 1

    case "$format" in
        json)
            export_json "$metrics" "$output_file"
            ;;
        csv)
            export_csv "$metrics" "$output_file"
            ;;
        md|markdown)
            export_markdown "$metrics" "$output_file"
            ;;
        *)
            print_error "Unknown export format: $format"
            print_info "Supported formats: json, csv, md"
            return 1
            ;;
    esac
}

show_stats() {
    local workflow="${WORKFLOW:-default}"

    verbose "show_stats: workflow=$workflow"

    # Verify workflow exists
    local workflow_file="$CONFIG_DIR/workflows/${workflow}.yaml"
    if [[ ! -f "$workflow_file" ]]; then
        print_error "Workflow '$workflow' not found"
        print_info "Run 'apr list' to see available workflows"
        exit $EXIT_CONFIG_ERROR
    fi

    if [[ -n "${EXPORT_FORMAT:-}" ]]; then
        export_metrics "$workflow" "$EXPORT_FORMAT" "$INTEGRATE_OUTPUT" "$EXPORT_ROUNDS" "$EXPORT_SINCE"
        return $?
    fi

    if [[ "$STATS_JSON" == "true" ]]; then
        if command -v jq &>/dev/null && metrics_exists "$workflow"; then
            metrics_read "$workflow"
        else
            print_warning "No metrics available; outputting empty JSON"
            echo "{}"
        fi
        return 0
    fi

    local rounds_dir="$CONFIG_DIR/rounds/$workflow"
    if [[ ! -d "$rounds_dir" ]]; then
        print_warning "No rounds recorded yet for workflow '$workflow'"
        print_info "Run 'apr run 1' to start your first revision round"
        exit $EXIT_SUCCESS
    fi

    if command -v jq &>/dev/null && metrics_exists "$workflow"; then
        if show_stats_full "$workflow"; then
            return 0
        fi
    fi

    # Collect round data
    local total_rounds=0
    local total_size=0
    local round_data=()
    local sizes=()
    local round_entries=()

    for round_file in "$rounds_dir"/round_*.md; do
        [[ -f "$round_file" ]] || continue
        local round_num
        round_num=$(basename "$round_file" .md | sed 's/round_//')
        [[ "$round_num" =~ ^[0-9]+$ ]] || continue
        round_entries+=("${round_num}|${round_file}")
    done

    if [[ ${#round_entries[@]} -eq 0 ]]; then
        print_warning "No rounds recorded yet for workflow '$workflow'"
        print_info "Run 'apr run 1' to start your first revision round"
        exit $EXIT_SUCCESS
    fi

    local sorted_entries=()
    mapfile -t sorted_entries < <(printf '%s\n' "${round_entries[@]}" | sort -n -t '|' -k1,1)

    for entry in "${sorted_entries[@]}"; do
        local round_num round_file size_bytes size_human mod_ts
        round_num=${entry%%|*}
        round_file=${entry#*|}
        ((++total_rounds))

        size_bytes=$(stat -c '%s' "$round_file" 2>/dev/null || stat -f '%z' "$round_file" 2>/dev/null || echo "0")
        size_human=$(du -h "$round_file" 2>/dev/null | cut -f1)
        mod_ts=$(stat -c '%Y' "$round_file" 2>/dev/null || stat -f '%m' "$round_file" 2>/dev/null || echo "0")

        total_size=$((total_size + size_bytes))
        sizes+=("$size_bytes")
        round_data+=("$round_num|$size_human|$size_bytes|$mod_ts")
    done

    # Calculate statistics
    local avg_size=$((total_size / total_rounds))
    local avg_human
    if [[ $avg_size -ge 1048576 ]]; then
        avg_human="$(echo "scale=1; $avg_size / 1048576" | bc 2>/dev/null || echo "$((avg_size / 1048576))M")"
        [[ "$avg_human" != *M ]] && avg_human="${avg_human}M"
    elif [[ $avg_size -ge 1024 ]]; then
        avg_human="$(echo "scale=1; $avg_size / 1024" | bc 2>/dev/null || echo "$((avg_size / 1024))K")"
        [[ "$avg_human" != *K ]] && avg_human="${avg_human}K"
    else
        avg_human="${avg_size}B"
    fi

    # Detect trend (compare first half vs second half)
    local trend_signal=""
    if [[ $total_rounds -ge 4 ]]; then
        local half=$((total_rounds / 2))
        local first_half_avg=0 second_half_avg=0
        local i=0
        for size in "${sizes[@]}"; do
            if [[ $i -lt $half ]]; then
                first_half_avg=$((first_half_avg + size))
            else
                second_half_avg=$((second_half_avg + size))
            fi
            ((++i))
        done
        first_half_avg=$((first_half_avg / half))
        second_half_avg=$((second_half_avg / (total_rounds - half)))

        if [[ $second_half_avg -lt $((first_half_avg * 80 / 100)) ]]; then
            trend_signal="Output size trending down (convergence signal)"
        elif [[ $second_half_avg -gt $((first_half_avg * 120 / 100)) ]]; then
            trend_signal="Output size trending up (scope may be expanding)"
        else
            trend_signal="Output size stable"
        fi
    fi

    # Display stats
    print_banner
    print_header "REVISION STATISTICS: $workflow"
    echo "" >&2

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style \
            --border rounded \
            --border-foreground 212 \
            --padding "1 2" \
            "$(gum style --foreground 39 "Rounds completed:")    $total_rounds" \
            "$(gum style --foreground 39 "Average output size:") $avg_human" >&2
    else
        echo -e "  ${CYAN}Rounds completed:${NC}    $total_rounds" >&2
        echo -e "  ${CYAN}Average output size:${NC} $avg_human" >&2
    fi

    echo "" >&2
    echo -e "  ${BOLD}${YELLOW}Round    Size    Modified${NC}" >&2
    echo -e "  ${DIM}─────    ────    ────────${NC}" >&2

    # Display round table
    for data in "${round_data[@]}"; do
        IFS='|' read -r round_num size_human size_bytes mod_ts <<< "$data"
        local mod_date
        mod_date=$(date -d "@$mod_ts" '+%Y-%m-%d %H:%M' 2>/dev/null || date -r "$mod_ts" '+%Y-%m-%d %H:%M' 2>/dev/null || echo "N/A")
        printf "  %-8s %-7s %s\n" "$round_num" "$size_human" "$mod_date" >&2
    done

    echo "" >&2

    # Show trend signal if available
    if [[ -n "$trend_signal" ]]; then
        print_info "$trend_signal"
        echo "" >&2
    fi

    # Suggestions based on round count
    if [[ $total_rounds -ge 5 ]]; then
        print_dim "Tip: After 5+ rounds, look for convergence - similar feedback suggests stability"
    elif [[ $total_rounds -eq 1 ]]; then
        print_dim "Tip: Run more rounds to see convergence trends"
    fi

    if command -v jq &>/dev/null && ! metrics_exists "$workflow"; then
        echo "" >&2
        print_warning "No analytics data available for workflow '$workflow'"
        print_info "Run 'apr backfill' to generate metrics from existing rounds"
    fi
}

# -----------------------------------------------------------------------------
# Dashboard (Interactive Analytics)
# -----------------------------------------------------------------------------

dashboard_clear() {
    if [[ -t 2 ]]; then
        printf '\033[2J\033[H' >&2
    fi
}

dashboard_term_size() {
    local cols rows
    cols=$(tput cols 2>/dev/null || echo "80")
    rows=$(tput lines 2>/dev/null || echo "24")
    echo "$cols $rows"
}

dashboard_iso_to_epoch() {
    local iso="$1"
    if [[ -z "$iso" || "$iso" == "null" ]]; then
        echo "0"
        return 0
    fi
    local epoch=""
    epoch=$(date -d "$iso" +%s 2>/dev/null || true)
    if [[ -n "$epoch" ]]; then
        echo "$epoch"
        return 0
    fi
    epoch=$(date -j -f '%Y-%m-%dT%H:%M:%SZ' "$iso" +%s 2>/dev/null || true)
    echo "${epoch:-0}"
}

dashboard_format_duration() {
    local seconds="${1:-0}"
    if [[ "$seconds" == "null" ]]; then
        echo "N/A"
        return 0
    fi
    if [[ ! "$seconds" =~ ^-?[0-9]+$ ]]; then
        echo "N/A"
        return 0
    fi
    if (( seconds < 0 )); then
        echo "N/A"
        return 0
    fi

    local days=$((seconds / 86400))
    local hours=$(( (seconds % 86400) / 3600 ))
    local mins=$(( (seconds % 3600) / 60 ))

    if (( days > 0 )); then
        echo "${days}d ${hours}h"
    elif (( hours > 0 )); then
        echo "${hours}h ${mins}m"
    else
        echo "${mins}m"
    fi
}

dashboard_format_nullable() {
    local value="${1:-}"
    if [[ -z "$value" || "$value" == "null" ]]; then
        echo "-"
        return 0
    fi
    echo "$value"
}

dashboard_hide_cursor() {
    printf '\033[?25l' >&2
}

dashboard_show_cursor() {
    printf '\033[?25h' >&2
}

dashboard_build_rounds() {
    local metrics="$1"

    DASHBOARD_ROUND_NUMS=()
    DASHBOARD_ROUND_SIZES=()
    DASHBOARD_ROUND_ADDED=()
    DASHBOARD_ROUND_DELETED=()
    DASHBOARD_ROUND_SIMILARITY=()
    DASHBOARD_ROUND_TS=()

    while IFS=$'\t' read -r round_num size added deleted similarity timestamp; do
        [[ -n "$round_num" ]] || continue
        DASHBOARD_ROUND_NUMS+=("$round_num")
        DASHBOARD_ROUND_SIZES+=("${size:-0}")
        DASHBOARD_ROUND_ADDED+=("${added:-}")
        DASHBOARD_ROUND_DELETED+=("${deleted:-}")
        DASHBOARD_ROUND_SIMILARITY+=("${similarity:-}")
        DASHBOARD_ROUND_TS+=("${timestamp:-}")
    done < <(echo "$metrics" | jq -r \
        '.rounds | sort_by(.round) | .[] | [.round, (.output.char_count // 0), (.changes_from_previous.lines_added // null), (.changes_from_previous.lines_deleted // null), (.changes_from_previous.similarity_score // null), (.timestamp // "")] | @tsv' 2>/dev/null)

    DASHBOARD_TOTAL_ROUNDS=${#DASHBOARD_ROUND_NUMS[@]}
}

dashboard_render_header() {
    local workflow="$1"
    printf "%sAPR Analytics Dashboard%s - workflow: %s\n" "${BOLD}" "${NC}" "$workflow" >&2
    printf "Press 'q' to quit, '?/h' for help, 'r' to refresh\n" >&2
    printf "────────────────────────────────────────────────────────────────────────\n" >&2
}

dashboard_render_convergence() {
    local metrics="$1"
    local confidence
    confidence=$(echo "$metrics" | jq -r '.convergence.confidence // 0' 2>/dev/null || echo "0")
    local indicator
    indicator=$(get_convergence_indicator "$confidence")

    local percent
    percent=$(awk -v c="$confidence" 'BEGIN { printf "%d", c*100 }' 2>/dev/null || echo "0")

    local status="Diverging"
    if (( percent >= 90 )); then
        status="Converged"
    elif (( percent >= 75 )); then
        status="Nearly Converged"
    elif (( percent >= 50 )); then
        status="Approaching Convergence"
    fi

    local remaining
    remaining=$(echo "$metrics" | jq -r '.convergence.estimated_rounds_remaining // ""' 2>/dev/null || echo "")
    if [[ -z "$remaining" || "$remaining" == "null" ]]; then
        remaining="?"
    fi

    printf "CONVERGENCE STATUS\n" >&2
    printf "  %s %s%% - %s\n" "$indicator" "$percent" "$status" >&2
    printf "  Est. %s more rounds\n" "$remaining" >&2
    printf "\n" >&2
}

dashboard_render_quick_stats() {
    local metrics="$1"

    local round_count
    round_count=$(echo "$metrics" | jq -r '.rounds | length' 2>/dev/null || echo "0")

    local avg_size
    avg_size=$(echo "$metrics" | jq -r '[.rounds[].output.char_count // 0] | if length > 0 then ((add / length) | floor) else 0 end' 2>/dev/null || echo "0")

    local last_ts first_ts
    last_ts=$(echo "$metrics" | jq -r '.rounds | sort_by(.round) | .[-1].timestamp // ""' 2>/dev/null || echo "")
    first_ts=$(echo "$metrics" | jq -r '.rounds | sort_by(.round) | .[0].timestamp // ""' 2>/dev/null || echo "")

    local last_epoch first_epoch span_secs
    last_epoch=$(dashboard_iso_to_epoch "$last_ts")
    first_epoch=$(dashboard_iso_to_epoch "$first_ts")
    span_secs=$((last_epoch - first_epoch))
    (( span_secs < 0 )) && span_secs=0

    local total_span last_run
    total_span=$(dashboard_format_duration "$span_secs")
    last_run=$(format_iso_date "$last_ts")

    printf "QUICK STATS\n" >&2
    printf "  Rounds:     %s\n" "$round_count" >&2
    printf "  Avg Size:   %s\n" "$(format_bytes "$avg_size")" >&2
    printf "  Total Span: %s\n" "$total_span" >&2
    printf "  Last Run:   %s\n" "$last_run" >&2
    printf "\n" >&2
}

dashboard_render_bar_chart() {
    local -a values=("$@")
    local count=${#values[@]}
    if [[ $count -eq 0 ]]; then
        printf "OUTPUT SIZE TREND\n  (no data)\n\n" >&2
        return 0
    fi

    local max_val=${values[0]}
    local v
    for v in "${values[@]}"; do
        (( v > max_val )) && max_val=$v
    done
    (( max_val <= 0 )) && max_val=1

    local max_height=5

    printf "OUTPUT SIZE TREND\n" >&2
    for ((row=max_height; row>=1; row--)); do
        local threshold=$((max_val * row / max_height))
        printf "  " >&2
        for v in "${values[@]}"; do
            if (( v >= threshold )); then
                printf "██" >&2
            else
                printf "  " >&2
            fi
            printf " " >&2
        done
        printf "\n" >&2
    done
    printf "  " >&2
    local i
    for ((i=0; i<count; i++)); do
        local label="R$((i+1))"
        # Check if DASHBOARD_ROUND_NUMS is set (safe for set -u)
        if [[ -n "${DASHBOARD_ROUND_NUMS[*]+_}" ]]; then
            if [[ ${#DASHBOARD_ROUND_NUMS[@]} -eq count ]]; then
                label="R${DASHBOARD_ROUND_NUMS[$i]}"
            fi
        fi
        printf "%-3s" "$label" >&2
    done
    printf "\n\n" >&2
}

dashboard_render_round_table() {
    local selected="$1"
    local total="$2"
    local max_rows=10
    local start=0

    if (( total > max_rows )); then
        start=$((selected - max_rows / 2))
        (( start < 0 )) && start=0
        (( start > total - max_rows )) && start=$((total - max_rows))
    fi

    local end=$((start + max_rows))
    (( end > total )) && end=$total

    printf "ROUND DETAILS (use ↑/↓)\n" >&2
    printf "  #   Output   +Add  -Del   Sim     Date\n" >&2
    printf "  ─────────────────────────────────────────\n" >&2

    local i
    for ((i=start; i<end; i++)); do
        local marker=" "
        if [[ $i -eq $selected ]]; then
            marker=">"
        fi
        local round_num size added deleted similarity ts
        round_num="${DASHBOARD_ROUND_NUMS[$i]}"
        size="$(format_bytes "${DASHBOARD_ROUND_SIZES[$i]}")"
        added="$(dashboard_format_nullable "${DASHBOARD_ROUND_ADDED[$i]}")"
        deleted="$(dashboard_format_nullable "${DASHBOARD_ROUND_DELETED[$i]}")"
        similarity="$(format_float "${DASHBOARD_ROUND_SIMILARITY[$i]}")"
        ts="$(format_iso_date "${DASHBOARD_ROUND_TS[$i]}")"

        printf " %s %3s %7s %5s %5s %6s %10s\n" "$marker" "$round_num" "$size" \
            "$added" "$deleted" "$similarity" "$ts" >&2
    done
    printf "\n" >&2
    printf "Keys: Enter=details  d=diff  r=refresh  ?=help  q=quit\n" >&2
}

dashboard_show_help() {
    dashboard_clear
    printf "APR DASHBOARD HELP\n" >&2
    printf "──────────────────\n" >&2
    printf "  q      Quit dashboard\n" >&2
    printf "  ↑/↓    Navigate rounds\n" >&2
    printf "  Enter  Show selected round details\n" >&2
    printf "  d      Diff selected round with previous\n" >&2
    printf "  r      Refresh metrics\n" >&2
    printf "  ?/h    Show this help\n" >&2
    printf "\nPress any key to return...\n" >&2
    read -rsn1 _ </dev/tty
}

dashboard_show_round_detail() {
    local idx="$1"
    local workflow="$2"
    local round_num="${DASHBOARD_ROUND_NUMS[$idx]}"
    local size="${DASHBOARD_ROUND_SIZES[$idx]}"
    local added
    local deleted
    added="$(dashboard_format_nullable "${DASHBOARD_ROUND_ADDED[$idx]}")"
    deleted="$(dashboard_format_nullable "${DASHBOARD_ROUND_DELETED[$idx]}")"
    local similarity="${DASHBOARD_ROUND_SIMILARITY[$idx]}"
    local ts="${DASHBOARD_ROUND_TS[$idx]}"

    dashboard_clear
    printf "ROUND %s DETAILS (%s)\n" "$round_num" "$workflow" >&2
    printf "──────────────────────────────\n" >&2
    printf "Output size: %s\n" "$(format_bytes "$size")" >&2
    printf "Lines added: %s\n" "$added" >&2
    printf "Lines del:   %s\n" "$deleted" >&2
    printf "Similarity:  %s\n" "$(format_float "$similarity")" >&2
    printf "Timestamp:   %s\n" "$(format_iso_date "$ts")" >&2
    printf "\nPress any key to return...\n" >&2
    read -rsn1 _ </dev/tty
}

dashboard_handle_input() {
    local key="" rest=""
    read -rsn1 key </dev/tty || true
    case "$key" in
        $'\x1b')
            # Add timeout to differentiate ESC from arrow keys
            read -rsn2 -t 0.1 rest </dev/tty || rest=""
            case "$rest" in
                '[A') echo "up" ;;
                '[B') echo "down" ;;
                *) echo "quit" ;; # Plain ESC quits
            esac
            ;;
        q|Q) echo "quit" ;;
        r|R) echo "refresh" ;;
        d|D) echo "diff" ;;
        '?'|h|H) echo "help" ;;
        '') echo "detail" ;;
    esac
}

dashboard_render() {
    local workflow="$1"
    local metrics="$2"
    local selected="$3"

    dashboard_clear
    dashboard_render_header "$workflow"
    dashboard_render_convergence "$metrics"
    dashboard_render_quick_stats "$metrics"
    dashboard_render_bar_chart "${DASHBOARD_ROUND_SIZES[@]}"
    dashboard_render_round_table "$selected" "$DASHBOARD_TOTAL_ROUNDS"
}

show_dashboard() {
    local workflow="${WORKFLOW:-default}"

    local workflow_file="$CONFIG_DIR/workflows/${workflow}.yaml"
    if [[ ! -f "$workflow_file" ]]; then
        print_error "Workflow '$workflow' not found"
        print_info "Run 'apr list' to see available workflows"
        exit $EXIT_CONFIG_ERROR
    fi

    if [[ ! -t 0 || ! -t 2 ]]; then
        print_error "Dashboard requires an interactive terminal"
        print_info "Use 'apr stats' for non-interactive output"
        exit $EXIT_USAGE_ERROR
    fi

    if ! command -v jq &>/dev/null; then
        print_error "jq not available; dashboard requires jq"
        print_info "Install jq or use 'apr stats' for basic output"
        exit $EXIT_DEPENDENCY_ERROR
    fi

    if ! metrics_exists "$workflow"; then
        print_error "No analytics data for workflow '$workflow'"
        print_info "Run some rounds or 'apr backfill' first"
        exit $EXIT_CONFIG_ERROR
    fi

    local cols rows
    read -r cols rows < <(dashboard_term_size)
    if (( cols < 80 || rows < 24 )); then
        print_error "Terminal too small for dashboard (${cols}x${rows})"
        print_info "Resize to at least 80x24 and try again"
        exit $EXIT_USAGE_ERROR
    fi

    local selected=0
    local metrics

    DASHBOARD_ACTIVE=true
    dashboard_hide_cursor

    while true; do
        read -r cols rows < <(dashboard_term_size)
        if (( cols < 80 || rows < 24 )); then
            dashboard_clear
            print_error "Terminal too small for dashboard (${cols}x${rows})"
            print_info "Resize to at least 80x24 and press any key to retry"
            read -rsn1 _ </dev/tty
            continue
        fi

        metrics=$(metrics_read "$workflow") || exit $EXIT_CONFIG_ERROR
        dashboard_build_rounds "$metrics"

        if (( DASHBOARD_TOTAL_ROUNDS <= 0 )); then
            dashboard_clear
            print_warning "No rounds in metrics for workflow '$workflow'"
            print_info "Run 'apr run 1' or 'apr backfill' first"
            break
        fi

        if (( selected >= DASHBOARD_TOTAL_ROUNDS )); then
            selected=$((DASHBOARD_TOTAL_ROUNDS - 1))
        fi
        (( selected < 0 )) && selected=0

        dashboard_render "$workflow" "$metrics" "$selected"

        case "$(dashboard_handle_input)" in
            up) ((selected--)) || true ;;
            down) ((selected++)) || true ;;
            diff)
                if (( selected >= 1 )); then
                    dashboard_clear
                    diff_rounds "${DASHBOARD_ROUND_NUMS[$((selected - 1))]}" "${DASHBOARD_ROUND_NUMS[$selected]}"
                    print_dim "Press any key to return..." >&2
                    read -rsn1 _ </dev/tty
                else
                    print_warning "Round 1 has no previous round to diff"
                    print_dim "Press any key to continue..." >&2
                    read -rsn1 _ </dev/tty
                fi
                ;;
            detail)
                dashboard_show_round_detail "$selected" "$workflow"
                ;;
            help)
                dashboard_show_help
                ;;
            refresh)
                ;;
            quit)
                break
                ;;
        esac
    done

    dashboard_show_cursor
    dashboard_clear
    DASHBOARD_ACTIVE=false
}

# ---------------------------------------------------------------------------
# Backfill Metrics for Existing Rounds (fzi.9)
# ---------------------------------------------------------------------------

cmd_backfill() {
    local workflow_arg="${1:-}"
    if [[ -n "$workflow_arg" ]] && ! is_valid_workflow_name "$workflow_arg"; then
        print_error "Invalid workflow name: $workflow_arg"
        print_info "Use only letters, numbers, dots, hyphens, underscores"
        exit $EXIT_USAGE_ERROR
    fi
    local workflow="${workflow_arg:-${WORKFLOW:-default}}"
    local force="${BACKFILL_FORCE:-false}"
    local dry_run="${DRY_RUN:-false}"
    local all="${BACKFILL_ALL:-false}"

    if [[ "$all" == "true" ]]; then
        backfill_all_workflows "$force" "$dry_run"
    else
        backfill_workflow "$workflow" "$force" "$dry_run"
    fi
}

backfill_workflow() {
    local workflow="$1"
    local force="$2"
    local dry_run="$3"

    local rounds_dir="$CONFIG_DIR/rounds/$workflow"
    local workflow_file="$CONFIG_DIR/workflows/${workflow}.yaml"

    if [[ ! -d "$rounds_dir" ]]; then
        print_error "No rounds found for workflow '$workflow'"
        return 1
    fi

    if [[ ! -f "$workflow_file" ]]; then
        print_error "Workflow config not found: $workflow_file"
        return 1
    fi

    if metrics_exists "$workflow" && [[ "$force" != "true" ]]; then
        print_warning "Metrics already exist for '$workflow'"
        print_info "Use --force to overwrite"
        return 1
    fi

    if [[ "$dry_run" == "true" ]]; then
        print_info "[DRY RUN] Would backfill workflow '$workflow'"
    else
        if metrics_exists "$workflow" && [[ "$force" == "true" ]]; then
            metrics_write_file "$workflow" "$(metrics_default_json "$workflow")"
        else
            metrics_init "$workflow"
        fi
    fi

    print_info "Backfilling metrics for workflow '$workflow'..."

    local round_entries=()
    local round_file
    for round_file in "$rounds_dir"/round_*.md; do
        [[ -f "$round_file" ]] || continue
        local round_num
        round_num=$(basename "$round_file" .md | sed 's/round_//')
        [[ "$round_num" =~ ^[0-9]+$ ]] || continue
        round_entries+=("${round_num}|${round_file}")
    done

    if [[ ${#round_entries[@]} -eq 0 ]]; then
        print_warning "No round files found for workflow '$workflow'"
        return 0
    fi

    local sorted_entries=()
    mapfile -t sorted_entries < <(printf '%s\n' "${round_entries[@]}" | sort -n -t '|' -k1,1)

    local count=0
    local prev_output=""

    for entry in "${sorted_entries[@]}"; do
        local round_num round_file
        round_num=${entry%%|*}
        round_file=${entry#*|}

        print_dim "  Analyzing round $round_num..."

        if [[ "$dry_run" == "true" ]]; then
            ((count++)) || true
            prev_output="$round_file"
            continue
        fi

        local output_metrics
        output_metrics=$(collect_document_metrics "$round_file" "output")
        if [[ -z "$output_metrics" ]]; then
            output_metrics="null"
        fi

        local file_ts timestamp
        file_ts=$(stat -c '%Y' "$round_file" 2>/dev/null || stat -f '%m' "$round_file" 2>/dev/null || echo "0")
        timestamp=$(date -d "@$file_ts" -u +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || \
            date -r "$file_ts" -u +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || \
            echo "1970-01-01T00:00:00Z")

        local change_metrics="null"
        if [[ -n "$prev_output" && -f "$prev_output" ]]; then
            change_metrics=$(calculate_change_metrics "$prev_output" "$round_file") || change_metrics="null"
        fi

        local round_record
        round_record=$(jq -nc \
            --argjson round "$round_num" \
            --arg timestamp "$timestamp" \
            --argjson output "$output_metrics" \
            --argjson changes "$change_metrics" \
            '{
                round: $round,
                timestamp: $timestamp,
                documents: null,
                output: $output,
                changes_from_previous: $changes,
                backfilled: true
            }')

        if ! metrics_write_round "$workflow" "$round_num" "$round_record"; then
            print_warning "Failed to write metrics for round $round_num"
        fi

        prev_output="$round_file"
        ((count++)) || true
    done

    if [[ "$dry_run" == "true" ]]; then
        print_info "[DRY RUN] Would backfill $count rounds"
        return 0
    fi

    verbose "Calculating convergence metrics..."
    update_convergence_metrics "$workflow"

    print_success "Backfilled $count rounds"
    print_success "Calculated convergence metrics"
}

backfill_all_workflows() {
    local force="$1"
    local dry_run="$2"

    local workflow_dir="$CONFIG_DIR/workflows"
    if [[ ! -d "$workflow_dir" ]]; then
        print_error "No workflows configured"
        return 1
    fi

    local count=0
    local config
    for config in "$workflow_dir"/*.yaml; do
        [[ -f "$config" ]] || continue
        local name
        name=$(basename "$config" .yaml)
        backfill_workflow "$name" "$force" "$dry_run" || true
        ((count++)) || true
    done

    print_success "Processed $count workflow(s)"
}

# =============================================================================
# ROBOT MODE - JSON API for coding agents
# =============================================================================
#
# All robot mode output goes to stdout as valid JSON.
# Response envelope: { ok, code, data, hint?, meta: {v, ts} }
#
# Error codes (`.code`): ok, usage_error, not_configured, config_error,
# validation_failed, dependency_missing, busy, network_error, update_error,
# attachment_mismatch, not_implemented, internal_error
# =============================================================================

# Robot mode state
# shellcheck disable=SC2034  # State flag for helper functions
ROBOT_MODE=false
ROBOT_COMPACT=false
ROBOT_STATS=false
# Robot output format (resolved in cmd_robot): json|toon
ROBOT_FORMAT="json"
ROBOT_FORMAT_OVERRIDE=""

robot_resolve_output_format() {
    local explicit="${1:-}"
    local fmt=""

    if [[ -n "$explicit" ]]; then
        fmt="$explicit"
    elif [[ -n "${APR_OUTPUT_FORMAT:-}" ]]; then
        fmt="$APR_OUTPUT_FORMAT"
    elif [[ -n "${TOON_DEFAULT_FORMAT:-}" ]]; then
        fmt="$TOON_DEFAULT_FORMAT"
    else
        fmt="json"
    fi

    fmt="${fmt,,}"
    case "$fmt" in
        json|toon)
            echo "$fmt"
            return 0
            ;;
        *)
            return 2
            ;;
    esac
}

robot_try_load_toon_sh() {
    # Avoid hard dependency; only used when --format toon is requested.
    if declare -F toon_encode >/dev/null 2>&1; then
        return 0
    fi

    local toon_sh="${TOON_SH_PATH:-$HOME/.local/lib/toon.sh}"
    if [[ -f "$toon_sh" ]]; then
        # shellcheck source=/dev/null
        source "$toon_sh" 2>/dev/null || true
    fi

    declare -F toon_encode >/dev/null 2>&1
}

robot_json_to_toon() {
    local json="$1"
    if ! robot_try_load_toon_sh; then
        return 1
    fi
    if ! toon_available >/dev/null 2>&1; then
        return 1
    fi
    printf '%s' "$json" | toon_encode
}

# Build JSON response using jq (required for robot mode)
# Usage: robot_json ok|false code data_json [hint]
robot_json() {
    local ok="$1"
    local code="$2"
    local data="$3"
    local hint="${4:-}"
    local ts
    ts=$(iso_timestamp)

    local result
    if [[ -n "$hint" ]]; then
        result=$(jq -nc \
            --argjson ok "$ok" \
            --arg code "$code" \
            --argjson data "$data" \
            --arg hint "$hint" \
            --arg v "$VERSION" \
            --arg ts "$ts" \
            '{ok: $ok, code: $code, data: $data, hint: $hint, meta: {v: $v, ts: $ts}}')
    else
        result=$(jq -nc \
            --argjson ok "$ok" \
            --arg code "$code" \
            --argjson data "$data" \
            --arg v "$VERSION" \
            --arg ts "$ts" \
            '{ok: $ok, code: $code, data: $data, meta: {v: $v, ts: $ts}}')
    fi

    if [[ "${ROBOT_FORMAT:-json}" == "toon" ]]; then
        local toon_out
        if toon_out="$(robot_json_to_toon "$result" 2>/dev/null)"; then
            # Show stats if requested
            if [[ "${ROBOT_STATS:-false}" == "true" ]]; then
                local json_bytes toon_bytes savings
                json_bytes=$(printf '%s' "$result" | wc -c)
                toon_bytes=$(printf '%s' "$toon_out" | wc -c)
                if [[ $json_bytes -gt 0 ]]; then
                    savings=$((100 - (toon_bytes * 100 / json_bytes)))
                else
                    savings=0
                fi
                printf '[apr-toon] JSON: %d bytes, TOON: %d bytes (%d%% savings)\n' \
                    "$json_bytes" "$toon_bytes" "$savings" >&2
            fi
            printf '%s' "$toon_out"
        else
            echo "[toon] warn: tru/toon.sh not available; outputting JSON" >&2
            if [[ "$ROBOT_COMPACT" == "true" ]]; then
                echo "$result"
            else
                echo "$result" | jq .
            fi
        fi
        return 0
    fi

    # Show stats for JSON mode if requested (compares against potential TOON savings)
    if [[ "${ROBOT_STATS:-false}" == "true" ]]; then
        local json_bytes toon_out toon_bytes savings
        json_bytes=$(printf '%s' "$result" | wc -c)
        if toon_out="$(robot_json_to_toon "$result" 2>/dev/null)"; then
            toon_bytes=$(printf '%s' "$toon_out" | wc -c)
            if [[ $json_bytes -gt 0 ]]; then
                savings=$((100 - (toon_bytes * 100 / json_bytes)))
            else
                savings=0
            fi
            printf '[apr-toon] JSON: %d bytes, TOON would be: %d bytes (%d%% potential savings)\n' \
                "$json_bytes" "$toon_bytes" "$savings" >&2
        else
            printf '[apr-toon] JSON: %d bytes (TOON unavailable for comparison)\n' "$json_bytes" >&2
        fi
    fi

    if [[ "$ROBOT_COMPACT" == "true" ]]; then
        echo "$result"
    else
        echo "$result" | jq .
    fi
}

robot_fail() {
    local code="$1"
    local data="${2:-}"
    local hint="${3:-}"
    if [[ -z "$data" ]]; then
        data='{}'
    fi
    robot_json false "$code" "$data" "$hint"
    apr_emit_error_code_tag "$code"
    local exit_code
    exit_code="$(apr_exit_code_for_code "$code")"

    # Unit tests source apr (with main() removed). In that mode we must not
    # `exit`, or we terminate the test runner. Return the mapped exit code.
    if [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
        return "$exit_code"
    fi
    exit "$exit_code"
}

# Robot: Status - System overview
robot_status() {
    local configured=false
    local default_workflow=""
    local workflow_count=0
    local oracle_available=false
    local oracle_method=""
    local workflows_json="[]"

    # Check configuration
    if [[ -d "$CONFIG_DIR" && -f "$CONFIG_DIR/config.yaml" ]]; then
        configured=true
        default_workflow=$(get_config_value "default_workflow" "$CONFIG_DIR/config.yaml" 2>/dev/null || echo "")
    fi

    # Count and list workflows (JSON-safe)
    if [[ -d "$CONFIG_DIR/workflows" ]]; then
        local workflow_names=()
        for wf in "$CONFIG_DIR/workflows"/*.yaml; do
            [[ -f "$wf" ]] || continue
            local name
            name=$(basename "$wf" .yaml)
            if is_valid_workflow_name "$name"; then
                workflow_names+=("$name")
            fi
        done
        workflow_count="${#workflow_names[@]}"
        workflows_json=$(printf '%s\n' "${workflow_names[@]}" | jq -Rsc 'split("\n") | map(select(length>0))')
    fi

    # Check Oracle
    if command -v oracle &>/dev/null; then
        oracle_available=true
        oracle_method="global"
    elif [[ -z "${APR_NO_NPX:-}" ]] && command -v npx &>/dev/null; then
        oracle_available=true
        oracle_method="npx"
    fi

    # Build data object with jq
    local data
    data=$(jq -nc \
        --argjson configured "$configured" \
        --arg default_workflow "$default_workflow" \
        --argjson workflow_count "$workflow_count" \
        --argjson workflows "$workflows_json" \
        --argjson oracle_available "$oracle_available" \
        --arg oracle_method "$oracle_method" \
        --arg config_dir "$CONFIG_DIR" \
        --arg apr_home "$APR_HOME" \
        '{
            configured: $configured,
            default_workflow: $default_workflow,
            workflow_count: $workflow_count,
            workflows: $workflows,
            oracle_available: $oracle_available,
            oracle_method: $oracle_method,
            config_dir: $config_dir,
            apr_home: $apr_home
        }')

    local hint=""
    if [[ "$configured" == "false" ]]; then
        hint="Run 'apr robot init' to initialize, then 'apr setup' to create workflow"
    elif [[ "$oracle_available" == "false" ]]; then
        hint="Install Oracle: npm install -g @steipete/oracle"
    fi

    robot_json true "ok" "$data" "$hint"
}

# Robot: Workflows - List all workflows
robot_workflows() {
    if [[ ! -d "$CONFIG_DIR/workflows" ]]; then
        robot_fail "not_configured" '{"workflows":[]}' "Run 'apr robot init' then 'apr setup'"
        return $?
    fi

    local items=()
    for wf in "$CONFIG_DIR/workflows"/*.yaml; do
        [[ -f "$wf" ]] || continue
        local name desc
        name=$(basename "$wf" .yaml)
        desc=$(yaml_unquote "$(get_config_value "description" "$wf" 2>/dev/null || echo "")")
        items+=("$(jq -nc --arg name "$name" --arg desc "$desc" '{name: $name, description: $desc}')")
    done

    local workflows_json="[]"
    if [[ ${#items[@]} -gt 0 ]]; then
        workflows_json=$(printf '%s\n' "${items[@]}" | jq -sc .)
    fi

    robot_json true "ok" "{\"workflows\":$workflows_json}"
}

# Robot: Init - Initialize .apr directory
robot_init() {
    # Check if fully initialized
    if [[ -d "$CONFIG_DIR" && -f "$CONFIG_DIR/config.yaml" ]]; then
        robot_json true "ok" '{"created":false,"existed":true}' "Already initialized"
        return 0
    fi

    # Handle errors gracefully to ensure JSON output
    if ! mkdir -p "$CONFIG_DIR/workflows" "$CONFIG_DIR/rounds" 2>/dev/null; then
        robot_fail "config_error" "$(jq -nc --arg dir "$CONFIG_DIR" '{directory: $dir}')" "Failed to create directory: $CONFIG_DIR"
        return $?
    fi

    if [[ ! -f "$CONFIG_DIR/config.yaml" ]]; then
        if ! echo "default_workflow: default" > "$CONFIG_DIR/config.yaml" 2>/dev/null; then
            robot_fail "config_error" '{"reason":"config_write"}' "Failed to write config file"
            return $?
        fi
    fi

    robot_json true "ok" '{"created":true,"existed":false}'
}

# Robot: Validate - Pre-run validation
robot_validate() {
    local round_num="${1:-}"
    local workflow="${WORKFLOW:-default}"
    local errors=()
    local warnings=()

    if [[ -z "$round_num" ]]; then
        errors+=("Round number required")
    elif ! is_non_negative_int "$round_num"; then
        errors+=("Round must be a non-negative integer")
    fi

    if [[ ! -d "$CONFIG_DIR" ]]; then
        errors+=("Not initialized - run 'apr robot init'")
    fi

    local wf_file="$CONFIG_DIR/workflows/${workflow}.yaml"
    if [[ ! -f "$wf_file" ]]; then
        errors+=("Workflow '$workflow' not found")
    else
        # Check required documents exist
        local readme spec model output_dir
        readme=$(yaml_unquote "$(get_config_value "readme" "$wf_file" 2>/dev/null || echo "")")
        spec=$(yaml_unquote "$(get_config_value "spec" "$wf_file" 2>/dev/null || echo "")")
        model=$(yaml_unquote "$(get_config_value "model" "$wf_file" 2>/dev/null || echo "")")
        output_dir=$(yaml_unquote "$(get_config_value "output_dir" "$wf_file" 2>/dev/null || echo "")")

        if [[ -n "$readme" && ! -f "$readme" ]]; then
            errors+=("README not found: $readme")
        fi
        if [[ -n "$spec" && ! -f "$spec" ]]; then
            errors+=("Spec not found: $spec")
        fi
        if [[ -z "$model" ]]; then
            errors+=("Model not configured in workflow")
        fi
        if [[ -z "$output_dir" ]]; then
            errors+=("Output directory not configured in workflow")
        fi

        # Prompt quality checks (fail fast before expensive Oracle runs).
        local prompt_no_impl=""
        prompt_no_impl=$(build_revision_prompt "false" "$wf_file" 2>/dev/null || echo "")
        if [[ -n "$prompt_no_impl" ]]; then
            if ! prompt_quality_check "$prompt_no_impl" "$wf_file" "template"; then
                errors+=("$PROMPT_QC_REASON (template)")
            fi
        fi

        local prompt_with_impl=""
        prompt_with_impl=$(build_revision_prompt "true" "$wf_file" 2>/dev/null || echo "")
        if [[ -n "$prompt_with_impl" ]]; then
            if ! prompt_quality_check "$prompt_with_impl" "$wf_file" "template_with_impl"; then
                errors+=("$PROMPT_QC_REASON (template_with_impl)")
            fi
        fi
    fi

    # Check Oracle
    if ! command -v oracle &>/dev/null; then
        if [[ -n "${APR_NO_NPX:-}" ]] || ! command -v npx &>/dev/null; then
            errors+=("Oracle not available")
        fi
    fi

    # Check for previous round if not round 1
    if is_non_negative_int "$round_num" && [[ "$round_num" -gt 1 ]]; then
        local prev=$((round_num - 1))
        local prev_file="$CONFIG_DIR/rounds/$workflow/round_${prev}.md"
        if [[ ! -f "$prev_file" ]]; then
            warnings+=("Previous round $prev not found - starting fresh?")
        fi
    fi

    local valid=true
    [[ ${#errors[@]} -gt 0 ]] && valid=false

    local errors_json warnings_json
    errors_json=$(printf '%s\n' "${errors[@]:-}" | jq -Rsc 'split("\n") | map(select(length > 0))')
    warnings_json=$(printf '%s\n' "${warnings[@]:-}" | jq -Rsc 'split("\n") | map(select(length > 0))')

    local data
    data=$(jq -nc \
        --argjson valid "$valid" \
        --argjson errors "$errors_json" \
        --argjson warnings "$warnings_json" \
        --arg workflow "$workflow" \
        --arg round "$round_num" \
        '{valid: $valid, errors: $errors, warnings: $warnings, workflow: $workflow, round: $round}')

    if [[ "$valid" == "true" ]]; then
        robot_json true "ok" "$data"
    else
        local fail_code="validation_failed"
        # Prefer argument errors over environment/config state. If the user
        # invokes `apr robot validate` without a round, that's a usage error
        # regardless of whether .apr is initialized.
        if [[ -z "$round_num" ]] || ! is_non_negative_int "$round_num"; then
            fail_code="usage_error"
        elif [[ ! -d "$CONFIG_DIR" ]]; then
            fail_code="not_configured"
        fi
        robot_fail "$fail_code" "$data" "Fix errors before running"
    fi
}

# Robot: Run - Execute a revision round
robot_run() {
    local round_num="${1:-}"
    local workflow="${WORKFLOW:-default}"
    local include_impl="${INCLUDE_IMPL:-false}"

    verbose "robot_run: round=$round_num workflow=$workflow include_impl=$include_impl"

    # First validate
    if [[ -z "$round_num" ]]; then
        robot_fail "usage_error" '{"argument":"round"}' "Round number required"
        return $?
    fi

    if ! is_non_negative_int "$round_num"; then
        robot_fail "usage_error" "$(jq -nc --arg round "$round_num" '{argument: "round", value: $round}')" "Round must be a non-negative integer"
        return $?
    fi

    # Check Oracle
    if ! check_oracle; then
        robot_fail "dependency_missing" '{"dependency":"oracle"}' "Oracle not available"
        return $?
    fi
    oracle_detect_features || true

    # Load workflow config
    local config_path="$CONFIG_DIR/workflows/$workflow.yaml"
    if [[ ! -f "$config_path" ]]; then
        robot_fail "usage_error" "$(jq -nc --arg wf "$workflow" '{argument: "workflow", value: $wf}')" "Workflow not found"
        return $?
    fi

    # Parse config
    local readme_path spec_path impl_path model output_dir impl_every_n
    local browser_hide_window_raw browser_hide_window
    readme_path=$(yaml_unquote "$(get_config_value "readme" "$config_path")")
    spec_path=$(yaml_unquote "$(get_config_value "spec" "$config_path")")
    impl_path=$(yaml_unquote "$(get_config_value "implementation" "$config_path")")
    model=$(yaml_unquote "$(get_config_value "model" "$config_path")")
    output_dir=$(yaml_unquote "$(get_config_value "output_dir" "$config_path")")
    impl_every_n=$(yaml_unquote "$(get_config_value "impl_every_n" "$config_path")")
    browser_hide_window_raw=$(yaml_unquote "$(get_config_value "browser_hide_window" "$config_path")")
    browser_hide_window=$(config_bool_default_true "$browser_hide_window_raw")

    # Auto-include implementation every N rounds if configured
    if [[ -n "$impl_every_n" && "$impl_every_n" =~ ^[0-9]+$ && "$impl_every_n" -gt 0 ]]; then
        if (( round_num % impl_every_n == 0 )); then
            verbose "impl_every_n=$impl_every_n: round $round_num triggers automatic impl inclusion"
            include_impl=true
        fi
    fi

    if [[ -z "$model" ]]; then
        robot_fail "config_error" '{"field":"model"}' "Model not configured in workflow"
        return $?
    fi
    if [[ -z "$output_dir" ]]; then
        robot_fail "config_error" '{"field":"output_dir"}' "Output directory not configured in workflow"
        return $?
    fi

    # Validate required files
    if [[ ! -f "$readme_path" ]]; then
        robot_fail "config_error" "$(jq -nc --arg f "$readme_path" '{resource: "file", path: $f}')" "README file not found"
        return $?
    fi
    if [[ ! -f "$spec_path" ]]; then
        robot_fail "config_error" "$(jq -nc --arg f "$spec_path" '{resource: "file", path: $f}')" "Spec file not found"
        return $?
    fi

    if [[ "$include_impl" == "true" ]]; then
        if [[ -z "$impl_path" || ! -f "$impl_path" ]]; then
            include_impl=false
        fi
    fi

    # Build session info
    local slug="apr-${workflow}-round-${round_num}"
    local output_file="${output_dir}/round_${round_num}.md"

    if [[ "$include_impl" == "true" && -n "$impl_path" ]]; then
        slug="${slug}-with-impl"
    fi

    # Check if output file already exists (Robot mode safety)
    if [[ -f "$output_file" ]]; then
        robot_fail "validation_failed" "$(jq -nc --arg path "$output_file" '{kind:"output_exists", file: $path}')" "Output file already exists"
        return $?
    fi

    # Acquire lock so concurrent robot runs can't trample the same workflow/round.
    local lock_file="$CONFIG_DIR/.locks/${workflow}_round_${round_num}.lock"
    if ! acquire_lock "$workflow" "$round_num"; then
        local existing_pid=""
        existing_pid=$(cat "$lock_file" 2>/dev/null || echo "")
        robot_fail "busy" "$(jq -nc --arg wf "$workflow" --argjson r "$round_num" --arg lock "$lock_file" --arg pid "$existing_pid" '{workflow: $wf, round: $r, lock_file: $lock, pid: $pid}')" \
            "Another APR process is already running this round"
        return $?
    fi

    # Build file arguments
    local file_args=(--file "$readme_path")
    if [[ "$include_impl" == "true" && -n "$impl_path" && -f "$impl_path" ]]; then
        file_args+=(--file "$impl_path")
    fi
    file_args+=(--file "$spec_path")

    # Build prompt using shared function
    local prompt
    prompt=$(build_revision_prompt "$include_impl" "$config_path")
    if [[ -z "$prompt" ]]; then
        release_lock 2>/dev/null || true
        robot_fail "config_error" '{"errors":["Prompt template is empty"]}' \
            "Add 'template' or 'template_with_impl' to workflow"
        return $?
    fi

    if ! prompt_quality_check "$prompt" "$config_path" "prompt"; then
        release_lock 2>/dev/null || true
        robot_fail "validation_failed" "$(jq -nc --arg err "$PROMPT_QC_REASON" '{errors:[$err]}')" \
            "Fix workflow template (remove {{...}} placeholders) before running"
        return $?
    fi

    # Create output directory
    if ! mkdir -p "$(dirname "$output_file")" 2>/dev/null; then
        release_lock 2>/dev/null || true
        robot_fail "config_error" "$(jq -nc --arg dir "$(dirname "$output_file")" '{directory: $dir}')" \
            "Failed to create output directory"
        return $?
    fi

    # Build Oracle command
    local oracle_args=(
        --engine browser
        -m "$model"
        "${file_args[@]}"
        --browser-attachments never  # Paste inline, never upload as files
        --slug "$slug"
        --write-output "$output_file"
        --files-report
        --heartbeat 30
        -p "$prompt"
    )

    [[ "$ORACLE_SUPPORTS_NOTIFY" == "true" ]] && oracle_args+=(--notify)
    [[ "$browser_hide_window" == "true" ]] && oracle_args+=(--browser-hide-window)

    verbose "robot_run Oracle command: ${ORACLE_CMD[*]} ${oracle_args[*]}"
    verbose "robot_run output_file: $output_file"

    # Execute in background (always use retry for reliability in robot mode).
    # Important: robot mode must keep output clean; capture all Oracle/retry output to a log file.
    local logs_dir="$CONFIG_DIR/logs"
    local oracle_log="/dev/null"
    if mkdir -p "$logs_dir" 2>/dev/null; then
        oracle_log="$logs_dir/oracle_${slug}.log"
    fi

    (
        # Bash will SIGHUP background jobs on shell exit. Ignore HUP so the
        # detached robot run can survive after `apr` exits.
        trap "" HUP
        run_oracle_with_retry "${oracle_args[@]}"
    ) >"$oracle_log" 2>&1 &
    local oracle_pid=$!

    # Brief delay to verify process started
    sleep 0.5

    # Verify the process is actually running
    if ! kill -0 "$oracle_pid" 2>/dev/null; then
        release_lock 2>/dev/null || true
        robot_fail "internal_error" '{"reason":"process_start_failed"}' "Oracle process failed to start immediately"
        return $?
    fi

    background_lock_detach_parent "$oracle_pid"

    # Return session info
    local data
    data=$(jq -nc \
        --arg slug "$slug" \
        --argjson pid "$oracle_pid" \
        --arg output_file "$output_file" \
        --arg log_file "$oracle_log" \
        --arg workflow "$workflow" \
        --arg round "$round_num" \
        --argjson include_impl "$include_impl" \
        '{
            slug: $slug,
            pid: $pid,
            output_file: $output_file,
            log_file: $log_file,
            workflow: $workflow,
            round: ($round | tonumber),
            include_impl: $include_impl,
            status: "running"
        }')

    robot_json true "ok" "$data" "Use 'apr status' or 'apr attach $slug' to monitor"
}

# Robot: History - List revision rounds
robot_history() {
    local workflow="${WORKFLOW:-default}"
    local rounds_dir="$CONFIG_DIR/rounds/$workflow"

    if [[ ! -d "$rounds_dir" ]]; then
        robot_fail "validation_failed" "$(jq -nc --arg wf "$workflow" '{resource: "rounds", workflow: $wf}')" "No rounds found for workflow"
        return $?
    fi

    local round_entries=()
    for round_file in "$rounds_dir"/round_*.md; do
        [[ -f "$round_file" ]] || continue
        local round_num
        round_num=$(basename "$round_file" .md | sed 's/round_//')
        [[ "$round_num" =~ ^[0-9]+$ ]] || continue
        round_entries+=("${round_num}|${round_file}")
    done

    local sorted_entries=()
    if [[ ${#round_entries[@]} -gt 0 ]]; then
        mapfile -t sorted_entries < <(printf '%s\n' "${round_entries[@]}" | sort -n -t '|' -k1,1)
    fi

    local rounds=()
    for entry in "${sorted_entries[@]}"; do
        local round_num round_file size mod_ts
        round_num=${entry%%|*}
        round_file=${entry#*|}
        size=$(stat -c '%s' "$round_file" 2>/dev/null || stat -f '%z' "$round_file" 2>/dev/null || echo "0")
        mod_ts=$(stat -c '%Y' "$round_file" 2>/dev/null || stat -f '%m' "$round_file" 2>/dev/null || echo "0")

        rounds+=("$(jq -nc \
            --arg round "$round_num" \
            --arg file "$round_file" \
            --arg size "$size" \
            --arg mod_ts "$mod_ts" \
            '{round: ($round | tonumber), file: $file, size: ($size | tonumber), modified: ($mod_ts | tonumber)}')")
    done

    local rounds_json="[]"
    if [[ ${#rounds[@]} -gt 0 ]]; then
        rounds_json=$(printf '%s\n' "${rounds[@]}" | jq -sc .)
    fi

    local data
    data=$(jq -nc \
        --arg workflow "$workflow" \
        --argjson count "${#rounds[@]}" \
        --argjson rounds "$rounds_json" \
        '{workflow: $workflow, count: $count, rounds: $rounds}')

    robot_json true "ok" "$data"
}

# Robot: Stats - Analytics metrics summary
robot_stats() {
    if ! command -v jq &>/dev/null; then
        robot_fail "dependency_missing" '{"dependency":"jq"}' "Robot stats requires jq"
        return $?
    fi

    local workflow="${WORKFLOW:-default}"
    if ! metrics_exists "$workflow"; then
        robot_fail "validation_failed" "$(jq -nc --arg wf "$workflow" '{resource: "metrics", workflow: $wf}')" \
            "No metrics found. Run some rounds or backfill."
        return $?
    fi

    local metrics round_count avg_size convergence rounds
    if ! metrics=$(metrics_read "$workflow"); then
        robot_fail "config_error" "$(jq -nc --arg wf "$workflow" '{resource: "metrics", workflow: $wf}')" "Failed to read metrics"
        return $?
    fi
    round_count=$(echo "$metrics" | jq -r '.rounds | length' 2>/dev/null || echo "0")
    avg_size=$(echo "$metrics" | jq -r '[.rounds[].output.char_count // 0] | if length > 0 then (add / length) else 0 end' 2>/dev/null || echo "0")
    convergence=$(echo "$metrics" | jq -c '.convergence // {}' 2>/dev/null || echo "{}")
    rounds=$(echo "$metrics" | jq -c '.rounds' 2>/dev/null || echo "[]")

    local data
    data=$(jq -nc \
        --arg workflow "$workflow" \
        --argjson round_count "$round_count" \
        --argjson average_output_size "$avg_size" \
        --argjson convergence "$convergence" \
        --argjson rounds "$rounds" \
        '{
            workflow: $workflow,
            round_count: $round_count,
            average_output_size: $average_output_size,
            convergence: $convergence,
            rounds: $rounds
        }')

    robot_json true "ok" "$data"
}

# Robot: Show - View round content with metadata
robot_show() {
    local round_num="${1:-}"
    local workflow="${WORKFLOW:-default}"

    if [[ -z "$round_num" ]]; then
        robot_fail "usage_error" '{"argument":"round"}' "Round number required"
        return $?
    fi
    if ! is_non_negative_int "$round_num"; then
        robot_fail "usage_error" "$(jq -nc --arg round "$round_num" '{argument: "round", value: $round}')" \
            "Round must be a non-negative integer"
        return $?
    fi

    # Verify workflow exists
    local workflow_file="$CONFIG_DIR/workflows/${workflow}.yaml"
    if [[ ! -f "$workflow_file" ]]; then
        robot_fail "usage_error" "$(jq -nc --arg wf "$workflow" '{argument: "workflow", value: $wf}')" "Workflow not found"
        return $?
    fi

    local round_file="$CONFIG_DIR/rounds/$workflow/round_${round_num}.md"
    if [[ ! -f "$round_file" ]]; then
        robot_fail "usage_error" "$(jq -nc --arg r "$round_num" --arg wf "$workflow" '{argument: "round", value: $r, workflow: $wf}')" "Round not found"
        return $?
    fi

    local content char_count line_count word_count mtime
    content=$(cat "$round_file")
    char_count=${#content}
    line_count=$(wc -l < "$round_file" | tr -d ' ')
    word_count=$(wc -w < "$round_file" | tr -d ' ')
    mtime=$(stat -c %Y "$round_file" 2>/dev/null || stat -f %m "$round_file" 2>/dev/null || echo "0")

    local data
    data=$(jq -nc \
        --arg workflow "$workflow" \
        --argjson round "$round_num" \
        --arg content "$content" \
        --argjson char_count "$char_count" \
        --argjson line_count "$line_count" \
        --argjson word_count "$word_count" \
        --argjson mtime "$mtime" \
        --arg path "$round_file" \
        '{
            workflow: $workflow,
            round: $round,
            content: $content,
            stats: {
                chars: $char_count,
                lines: $line_count,
                words: $word_count
            },
            mtime: $mtime,
            path: $path
        }')

    robot_json true "ok" "$data"
}

# Robot: Diff - Compare two rounds
robot_diff() {
    local arg1="${1:-}"
    local arg2="${2:-}"
    local workflow="${WORKFLOW:-default}"

    if [[ -z "$arg1" ]]; then
        robot_fail "usage_error" '{"argument":"round_a"}' "At least one round number required"
        return $?
    fi
    if ! is_non_negative_int "$arg1"; then
        robot_fail "usage_error" "$(jq -nc --arg round "$arg1" '{argument: "round_a", value: $round}')" \
            "Round must be a non-negative integer"
        return $?
    fi
    if [[ -n "$arg2" ]] && ! is_non_negative_int "$arg2"; then
        robot_fail "usage_error" "$(jq -nc --arg round "$arg2" '{argument: "round_b", value: $round}')" \
            "Round must be a non-negative integer"
        return $?
    fi

    # Verify workflow exists
    local workflow_file="$CONFIG_DIR/workflows/${workflow}.yaml"
    if [[ ! -f "$workflow_file" ]]; then
        robot_fail "usage_error" "$(jq -nc --arg wf "$workflow" '{argument: "workflow", value: $wf}')" "Workflow not found"
        return $?
    fi

    local rounds_dir="$CONFIG_DIR/rounds/$workflow"
    local round_old
    local round_new

    # Argument normalization
    if [[ -z "$arg2" ]]; then
        round_new="$arg1"
        if [[ "$round_new" -le 1 ]]; then
            robot_fail "usage_error" '{"argument":"round_a","reason":"no_previous"}' "Round 1 has no previous round to compare with"
            return $?
        fi
        round_old=$((round_new - 1))
    else
        round_old="$arg1"
        round_new="$arg2"
        if [[ "$round_old" -gt "$round_new" ]]; then
            local tmp="$round_old"
            round_old="$round_new"
            round_new="$tmp"
        fi
    fi

    local file_old="$rounds_dir/round_${round_old}.md"
    local file_new="$rounds_dir/round_${round_new}.md"

    if [[ ! -f "$file_old" ]]; then
        robot_fail "usage_error" "$(jq -nc --arg r "$round_old" --arg wf "$workflow" '{argument: "round", value: $r, workflow: $wf}')" "Round $round_old not found"
        return $?
    fi
    if [[ ! -f "$file_new" ]]; then
        robot_fail "usage_error" "$(jq -nc --arg r "$round_new" --arg wf "$workflow" '{argument: "round", value: $r, workflow: $wf}')" "Round $round_new not found"
        return $?
    fi

    # Get file stats
    local size_old size_new lines_old lines_new
    size_old=$(stat -c %s "$file_old" 2>/dev/null || stat -f %z "$file_old" 2>/dev/null || echo "0")
    size_new=$(stat -c %s "$file_new" 2>/dev/null || stat -f %z "$file_new" 2>/dev/null || echo "0")
    lines_old=$(wc -l < "$file_old" | tr -d ' ')
    lines_new=$(wc -l < "$file_new" | tr -d ' ')

    # Generate unified diff
    local diff_output
    diff_output=$(diff -u "$file_old" "$file_new" 2>/dev/null || true)

    # Calculate diff stats
    local additions deletions
    additions=$(printf '%s\n' "$diff_output" | grep -c '^+[^+]' || true)
    deletions=$(printf '%s\n' "$diff_output" | grep -c '^-[^-]' || true)

    local data
    data=$(jq -nc \
        --arg workflow "$workflow" \
        --argjson round_old "$round_old" \
        --argjson round_new "$round_new" \
        --argjson size_old "$size_old" \
        --argjson size_new "$size_new" \
        --argjson lines_old "$lines_old" \
        --argjson lines_new "$lines_new" \
        --argjson additions "$additions" \
        --argjson deletions "$deletions" \
        --arg diff "$diff_output" \
        '{
            workflow: $workflow,
            comparing: {from: $round_old, to: $round_new},
            stats: {
                before: {bytes: $size_old, lines: $lines_old},
                after: {bytes: $size_new, lines: $lines_new},
                changes: {additions: $additions, deletions: $deletions}
            },
            diff: $diff
        }')

    robot_json true "ok" "$data"
}

# Robot: Integrate - Generate Claude Code integration prompt
robot_integrate() {
    local round_num="${1:-}"
    local workflow="${WORKFLOW:-default}"

    if [[ -z "$round_num" ]]; then
        robot_fail "usage_error" '{"argument":"round"}' "Round number required"
        return $?
    fi
    if ! is_non_negative_int "$round_num"; then
        robot_fail "usage_error" "$(jq -nc --arg round "$round_num" '{argument: "round", value: $round}')" \
            "Round must be a non-negative integer"
        return $?
    fi

    # Verify workflow exists
    local workflow_file="$CONFIG_DIR/workflows/${workflow}.yaml"
    if [[ ! -f "$workflow_file" ]]; then
        robot_fail "usage_error" "$(jq -nc --arg wf "$workflow" '{argument: "workflow", value: $wf}')" "Workflow not found"
        return $?
    fi

    # Get spec path
    local spec_path
    spec_path=$(yaml_unquote "$(get_config_value "spec" "$workflow_file")")
    if [[ -z "$spec_path" ]]; then
        robot_fail "config_error" '{"field":"spec"}' "Spec path not configured in workflow"
        return $?
    fi

    local round_file="$CONFIG_DIR/rounds/$workflow/round_${round_num}.md"
    if [[ ! -f "$round_file" ]]; then
        robot_fail "usage_error" "$(jq -nc --arg r "$round_num" --arg wf "$workflow" '{argument: "round", value: $r, workflow: $wf}')" "Round not found"
        return $?
    fi

    local round_content round_size
    round_content=$(cat "$round_file")
    round_size=${#round_content}

    # Build the integration prompt
    local prompt
    prompt=$(cat <<'PROMPT_HEADER'
First read ALL of the AGENTS.md file and README.md file super carefully
and understand ALL of both! Then use your code investigation agent mode
to fully understand the code and technical architecture of the project.
PROMPT_HEADER
)
    prompt+="
Read ALL of the specification document at: $spec_path

Now integrate the following feedback from GPT Pro 5.2 Extended Reasoning
(Round $round_num of the APR iterative refinement process). For each
suggestion, carefully evaluate whether you agree with the proposed change.
Then apply the changes you endorse to the specification document.

Be meticulous and use ultrathink.

---

$round_content"

    local data
    data=$(jq -nc \
        --arg workflow "$workflow" \
        --argjson round "$round_num" \
        --arg spec_path "$spec_path" \
        --arg prompt "$prompt" \
        --argjson round_size "$round_size" \
        --argjson prompt_size "${#prompt}" \
        '{
            workflow: $workflow,
            round: $round,
            spec_path: $spec_path,
            prompt: $prompt,
            stats: {
                round_chars: $round_size,
                prompt_chars: $prompt_size
            }
        }')

    robot_json true "ok" "$data" "Copy .data.prompt to Claude Code"
}

# Robot: Help - Show robot mode help in JSON
robot_help() {
    local data
    data=$(jq -nc '{
        description: "Robot mode for coding agents - JSON interface to APR",
        usage: "apr robot <command> [args] [options]",
        commands: {
            status: "System overview (config, workflows, oracle)",
            workflows: "List all workflows with descriptions",
            init: "Initialize .apr directory",
            validate: "Pre-run validation (apr robot validate <round>)",
            run: "Execute revision round (apr robot run <round>)",
            show: "View round content (apr robot show <round>)",
            diff: "Compare rounds (apr robot diff <N> [M])",
            integrate: "Get Claude integration prompt (apr robot integrate <round>)",
            history: "List revision rounds for workflow",
            stats: "Show analytics metrics summary",
            help: "This help"
        },
        options: {
            "-w, --workflow NAME": "Workflow name (default: from config)",
            "-i, --include-impl": "Include implementation document",
            "-f, --format FORMAT": "Robot output format: json or toon (env: APR_OUTPUT_FORMAT, TOON_DEFAULT_FORMAT)",
            "--stats": "Show token savings statistics (JSON vs TOON byte comparison)",
            "--compact": "Minified JSON output"
        },
        examples: [
            "apr robot status",
            "apr robot workflows",
            "apr robot validate 1 -w myspec",
            "apr robot run 1",
            "apr robot show 3 -w myspec",
            "apr robot diff 3 -w myspec",
            "apr robot diff 3 2 -w myspec",
            "apr robot integrate 3 -w myspec",
            "apr robot history -w myspec",
            "apr robot stats -w myspec"
        ],
        quick_start: "For agents: 1) apr robot status (check setup), 2) apr robot show <N> (read round), 3) apr robot integrate <N> (get prompt), 4) apr robot stats (check convergence)"
    }')

    robot_json true "ok" "$data"
}

# Robot: Main dispatcher
cmd_robot() {
    # shellcheck disable=SC2034  # State flag for helper functions
    ROBOT_MODE=true

    # Check jq is available (required for robot mode)
    if ! command -v jq &>/dev/null; then
        apr_emit_error_code_tag "dependency_missing"
        # Output to stdout (not stderr) for consistency with robot mode JSON output
        echo '{"ok":false,"code":"dependency_missing","data":{},"hint":"Robot mode requires jq. Install with: apt install jq","meta":{"v":"'"$VERSION"'","ts":"'"$(iso_timestamp)"'"}}'
        if [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
            return $EXIT_DEPENDENCY_ERROR
        fi
        exit $EXIT_DEPENDENCY_ERROR
    fi

    # Parse robot-specific options
    local robot_cmd=""
    local robot_args=()

    while [[ $# -gt 0 ]]; do
        case $1 in
            --compact)
                ROBOT_COMPACT=true
                shift
                ;;
            --stats)
                ROBOT_STATS=true
                shift
                ;;
            --format|-f)
                if [[ -z "${2:-}" ]]; then
                    robot_fail "usage_error" '{"option":"--format"}' "Option --format requires a value (json|toon)"
                    return $?
                fi
                ROBOT_FORMAT_OVERRIDE="$2"
                shift 2
                ;;
            --format=*)
                ROBOT_FORMAT_OVERRIDE="${1#*=}"
                shift
                ;;
            -w|--workflow)
                if [[ -z "${2:-}" ]]; then
                    robot_fail "usage_error" '{"option":"-w"}' "Option -w requires a workflow name"
                    return $?
                fi
                if ! is_valid_workflow_name "$2"; then
                    robot_fail "usage_error" "$(jq -nc --arg wf "$2" '{argument: "workflow", value: $wf}')" \
                        "Workflow name may contain only letters, numbers, dots, hyphens, underscores"
                    return $?
                fi
                WORKFLOW="$2"
                shift 2
                ;;
            -i|--include-impl)
                INCLUDE_IMPL=true
                shift
                ;;
            -*)
                # Use jq for proper escaping of user input in JSON
                robot_fail "usage_error" "$(jq -nc --arg opt "$1" '{option: $opt}')" "Unknown option: $1"
                return $?
                ;;
            *)
                if [[ -z "$robot_cmd" ]]; then
                    robot_cmd="$1"
                else
                    robot_args+=("$1")
                fi
                shift
                ;;
        esac
    done

    # Resolve robot output format:
    # CLI (--format) > APR_OUTPUT_FORMAT > TOON_DEFAULT_FORMAT > json
    ROBOT_FORMAT="$(robot_resolve_output_format "${ROBOT_FORMAT_OVERRIDE:-}")" || {
        robot_fail "usage_error" "$(jq -nc --arg fmt "${ROBOT_FORMAT_OVERRIDE:-}" '{argument: "format", value: $fmt}')" \
            "Format must be json or toon"
        return $?
    }

    robot_cmd="${robot_cmd:-help}"

    case "$robot_cmd" in
        status)
            robot_status
            ;;
        workflows)
            robot_workflows
            ;;
        init)
            robot_init
            ;;
        validate)
            robot_validate "${robot_args[0]:-}"
            ;;
        run)
            robot_run "${robot_args[0]:-}"
            ;;
        show)
            robot_show "${robot_args[0]:-}"
            ;;
        diff)
            robot_diff "${robot_args[0]:-}" "${robot_args[1]:-}"
            ;;
        integrate)
            robot_integrate "${robot_args[0]:-}"
            ;;
        history)
            robot_history
            ;;
        stats)
            robot_stats
            ;;
        help|--help|-h)
            robot_help
            ;;
        *)
            # Use jq for proper escaping of user input in JSON
            robot_fail "usage_error" "$(jq -nc --arg cmd "$robot_cmd" '{command: $cmd}')" "Unknown command. Try 'apr robot help'"
            return $?
            ;;
    esac
}

# -----------------------------------------------------------------------------
# Help
# -----------------------------------------------------------------------------

show_help() {
    check_gum || true
    print_banner

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 214 --bold "DESCRIPTION" >&2
        gum style --padding "0 2" "Automated Plan Reviser Pro automates iterative specification" >&2
        gum style --padding "0 2" "refinement using GPT Pro Extended Reasoning via Oracle." >&2
        echo "" >&2

        gum style --foreground 214 --bold "SYNOPSIS" >&2
        echo "  apr [command] [options]" >&2
        echo "" >&2

        gum style --foreground 214 --bold "COMMANDS" >&2
        gum style --foreground 39 "  Core Workflow" >&2
        echo "    $(gum style --foreground 82 'run <round>')        Run a revision round" >&2
        echo "    $(gum style --foreground 82 'setup')              Interactive workflow setup wizard" >&2
        echo "    $(gum style --foreground 82 'status')             Check Oracle session status" >&2
        echo "    $(gum style --foreground 82 'attach <session>')   Attach to running/completed session" >&2
        echo "" >&2
        gum style --foreground 39 "  Management" >&2
        echo "    $(gum style --foreground 82 'list')               List configured workflows" >&2
        echo "    $(gum style --foreground 82 'history')            Show revision history" >&2
        echo "    $(gum style --foreground 82 'show <round>')       View round output" >&2
        echo "    $(gum style --foreground 82 'backfill')           Generate metrics from existing rounds" >&2
        echo "    $(gum style --foreground 82 'update')             Check for and install updates" >&2
        echo "    $(gum style --foreground 82 'help')               Show this help message" >&2
        echo "" >&2
        gum style --foreground 39 "  Analysis" >&2
        echo "    $(gum style --foreground 82 'diff <N> [M]')       Compare round outputs (N vs M or N vs N-1)" >&2
        echo "    $(gum style --foreground 82 'integrate <round>')  Generate Claude Code integration prompt" >&2
        echo "    $(gum style --foreground 82 'stats')              Show round analytics & convergence signals" >&2
        echo "    $(gum style --foreground 82 'dashboard')          Interactive analytics dashboard" >&2
        echo "" >&2
        gum style --foreground 39 "  Automation" >&2
        echo "    $(gum style --foreground 82 'robot')              Machine-friendly CLI for coding agents" >&2
        echo "" >&2

        gum style --foreground 214 --bold "OPTIONS" >&2
        gum style --faint "  -w, --workflow NAME  Workflow to use (default: from config)" >&2
        gum style --faint "  -i, --include-impl   Include implementation document" >&2
        gum style --faint "  -d, --dry-run        Preview without sending to GPT Pro" >&2
        gum style --faint "  -r, --render         Render bundle for manual paste" >&2
        gum style --faint "  -c, --copy           Copy rendered bundle to clipboard" >&2
        gum style --faint "  -o, --output FILE    Output to file (integrate/export)" >&2
        gum style --faint "  --wait               Wait for completion (blocking)" >&2
        gum style --faint "  --login              Manual login mode (first-time setup)" >&2
        gum style --faint "  --keep-browser       Keep browser open after completion" >&2
        gum style --faint "  --no-preflight       Skip pre-flight validation checks" >&2
        gum style --faint "  --retry/--no-retry   Enable/disable auto-retry (default: enabled)" >&2
        gum style --faint "  --hours NUM          Status window in hours (default: 72)" >&2
        gum style --faint "  --detailed           Show detailed metrics in stats" >&2
        gum style --faint "  --json               Output stats as raw JSON" >&2
        gum style --faint "  --export FORMAT      Export stats (json, csv, md)" >&2
        gum style --faint "  --rounds RANGE       Filter export rounds (e.g. 3-5 or 1,3,5)" >&2
        gum style --faint "  --since ISO_DATE     Filter export rounds since timestamp" >&2
        gum style --faint "  --all                Backfill all workflows" >&2
        gum style --faint "  --force              Overwrite existing metrics" >&2
        gum style --faint "  -v, --verbose        Show detailed debug output" >&2
        gum style --faint "  -q, --quiet          Minimal output (errors only)" >&2
        gum style --faint "  --version            Show version" >&2
        echo "" >&2

        gum style --foreground 214 --bold "ENVIRONMENT VARIABLES" >&2
        gum style --faint "  APR_HOME             Data directory (~/.local/share/apr)" >&2
        gum style --faint "  APR_CACHE            Cache directory (~/.cache/apr)" >&2
        gum style --faint "  APR_CHECK_UPDATES    Enable daily update checking (set to 1)" >&2
        gum style --faint "  APR_STATUS_HOURS     Default status time window (default: 72)" >&2
        gum style --faint "  APR_VERBOSE          Enable verbose mode (set to true)" >&2
        gum style --faint "  APR_MAX_RETRIES      Max retry attempts (default: 3)" >&2
        gum style --faint "  APR_INITIAL_BACKOFF  Initial retry backoff in seconds (default: 10)" >&2
        gum style --faint "  APR_NO_GUM           Disable gum even if available" >&2
        gum style --faint "  NO_COLOR             Disable colored output" >&2
        echo "" >&2

        gum style --foreground 214 --bold "EXAMPLES" >&2
        gum style --foreground 39 "  # First-time setup" >&2
        echo "  apr setup" >&2
        echo "" >&2
        gum style --foreground 39 "  # Run revision round 1" >&2
        echo "  apr run 1" >&2
        echo "" >&2
        gum style --foreground 39 "  # Run with implementation doc" >&2
        echo "  apr run 2 --include-impl" >&2
        echo "" >&2
        gum style --foreground 39 "  # First run with manual login" >&2
        echo "  apr run 1 --login --wait" >&2
        echo "" >&2
        gum style --foreground 39 "  # Compare round outputs" >&2
        echo "  apr diff 3 5" >&2
        echo "" >&2
        gum style --foreground 39 "  # Generate Claude Code integration prompt" >&2
        echo "  apr integrate 5 --copy" >&2
        echo "" >&2
        gum style --foreground 39 "  # Check session status" >&2
        echo "  apr status" >&2
        echo "" >&2
        gum style --foreground 39 "  # Robot mode (for coding agents)" >&2
        echo "  apr robot status" >&2
        echo "" >&2

        gum style --foreground 214 --bold "EXIT CODES" >&2
        gum style --faint "  0   Success" >&2
        gum style --faint "  1   Partial failure" >&2
        gum style --faint "  2   Usage error (bad arguments)" >&2
        gum style --faint "  3   Dependency error (missing Oracle)" >&2
        gum style --faint "  4   Configuration error" >&2
        gum style --faint "  10  Network error" >&2
        gum style --faint "  11  Update error" >&2
        echo "" >&2

        gum style --foreground 39 "More info: https://github.com/${REPO_OWNER}/${REPO_NAME}" >&2
    else
        echo -e "${BOLD}${YELLOW}DESCRIPTION${NC}" >&2
        echo "  Automated Plan Reviser Pro automates iterative specification" >&2
        echo "  refinement using GPT Pro Extended Reasoning via Oracle." >&2
        echo "" >&2
        echo -e "${BOLD}${YELLOW}SYNOPSIS${NC}" >&2
        echo "  apr [command] [options]" >&2
        echo "" >&2
        echo -e "${BOLD}${YELLOW}COMMANDS${NC}" >&2
        echo -e "  ${CYAN}Core Workflow${NC}" >&2
        echo -e "    ${GREEN}run <round>${NC}        Run a revision round" >&2
        echo -e "    ${GREEN}setup${NC}              Interactive workflow setup wizard" >&2
        echo -e "    ${GREEN}status${NC}             Check Oracle session status" >&2
        echo -e "    ${GREEN}attach <session>${NC}   Attach to running/completed session" >&2
        echo "" >&2
        echo -e "  ${CYAN}Management${NC}" >&2
        echo -e "    ${GREEN}list${NC}               List configured workflows" >&2
        echo -e "    ${GREEN}history${NC}            Show revision history" >&2
        echo -e "    ${GREEN}show <round>${NC}       View round output" >&2
        echo -e "    ${GREEN}backfill${NC}           Generate metrics from existing rounds" >&2
        echo -e "    ${GREEN}update${NC}             Check for and install updates" >&2
        echo -e "    ${GREEN}help${NC}               Show this help message" >&2
        echo "" >&2
        echo -e "  ${CYAN}Analysis${NC}" >&2
        echo -e "    ${GREEN}diff <N> [M]${NC}       Compare round outputs (N vs M or N vs N-1)" >&2
        echo -e "    ${GREEN}integrate <round>${NC}  Generate Claude Code integration prompt" >&2
        echo -e "    ${GREEN}stats${NC}              Show round analytics & convergence signals" >&2
        echo -e "    ${GREEN}dashboard${NC}          Interactive analytics dashboard" >&2
        echo "" >&2
        echo -e "  ${CYAN}Automation${NC}" >&2
        echo -e "    ${GREEN}robot${NC}              Machine-friendly CLI for coding agents" >&2
        echo "" >&2
        echo -e "${BOLD}${YELLOW}OPTIONS${NC}" >&2
        echo "  -w, --workflow NAME  Workflow to use (default: from config)" >&2
        echo "  -i, --include-impl   Include implementation document" >&2
        echo "  -d, --dry-run        Preview without sending to GPT Pro" >&2
        echo "  -r, --render         Render bundle for manual paste" >&2
        echo "  -c, --copy           Copy rendered bundle to clipboard" >&2
        echo "  -o, --output FILE    Output to file (integrate/export)" >&2
        echo "  --wait               Wait for completion (blocking)" >&2
        echo "  --login              Manual login mode (first-time setup)" >&2
        echo "  --keep-browser       Keep browser open after completion" >&2
        echo "  --no-preflight       Skip pre-flight validation checks" >&2
        echo "  --retry/--no-retry   Enable/disable auto-retry (default: enabled)" >&2
        echo "  --hours NUM          Status window in hours (default: 72)" >&2
        echo "  --detailed           Show detailed metrics in stats" >&2
        echo "  --json               Output stats as raw JSON" >&2
        echo "  --export FORMAT      Export stats (json, csv, md)" >&2
        echo "  --rounds RANGE       Filter export rounds (e.g. 3-5 or 1,3,5)" >&2
        echo "  --since ISO_DATE     Filter export rounds since timestamp" >&2
        echo "  --all                Backfill all workflows" >&2
        echo "  --force              Overwrite existing metrics" >&2
        echo "  -v, --verbose        Show detailed debug output" >&2
        echo "  -q, --quiet          Minimal output (errors only)" >&2
        echo "  --version            Show version" >&2
        echo "" >&2
        echo -e "${BOLD}${YELLOW}ENVIRONMENT VARIABLES${NC}" >&2
        echo "  APR_HOME             Data directory (~/.local/share/apr)" >&2
        echo "  APR_CACHE            Cache directory (~/.cache/apr)" >&2
        echo "  APR_CHECK_UPDATES    Enable daily update checking (set to 1)" >&2
        echo "  APR_STATUS_HOURS     Default status time window (default: 72)" >&2
        echo "  APR_VERBOSE          Enable verbose mode (set to true)" >&2
        echo "  APR_MAX_RETRIES      Max retry attempts (default: 3)" >&2
        echo "  APR_INITIAL_BACKOFF  Initial retry backoff in seconds (default: 10)" >&2
        echo "  APR_NO_GUM           Disable gum even if available" >&2
        echo "  NO_COLOR             Disable colored output" >&2
        echo "" >&2
        echo -e "${BOLD}${YELLOW}EXAMPLES${NC}" >&2
        echo "  apr setup                    # First-time setup" >&2
        echo "  apr run 1                    # Run revision round 1" >&2
        echo "  apr run 2 --include-impl     # Include implementation doc" >&2
        echo "  apr run 1 --login --wait     # First run with manual login" >&2
        echo "  apr diff 3 5                 # Compare round outputs" >&2
        echo "  apr integrate 5 --copy       # Generate integration prompt" >&2
        echo "  apr status                   # Check session status" >&2
        echo "  apr robot status             # Robot mode (for agents)" >&2
        echo "" >&2
        echo -e "${BOLD}${YELLOW}EXIT CODES${NC}" >&2
        echo "  0   Success" >&2
        echo "  1   Partial failure" >&2
        echo "  2   Usage error (bad arguments)" >&2
        echo "  3   Dependency error (missing Oracle)" >&2
        echo "  4   Configuration error" >&2
        echo "  10  Network error" >&2
        echo "  11  Update error" >&2
        echo "" >&2
        echo -e "${CYAN}More info: https://github.com/${REPO_OWNER}/${REPO_NAME}${NC}" >&2
    fi
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    # Handle --version and --help early (before gum/oracle checks)
    if [[ "${1:-}" == "--version" || "${1:-}" == "-V" ]]; then
        echo "apr version $VERSION"
        exit $EXIT_SUCCESS
    fi

    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        check_gum || true
        show_help
        exit $EXIT_SUCCESS
    fi

    # Check for quiet flag early
    for arg in "$@"; do
        if [[ "$arg" == "-q" || "$arg" == "--quiet" ]]; then
            QUIET_MODE=true
            break
        fi
    done

    # Initialize gum
    check_gum || true

    # Check for updates (opt-in, non-blocking)
    check_for_updates

    # Check Oracle availability (not needed for some commands)
    local command="${1:-help}"

    # First-run experience: if no args and not configured, show welcome
    if [[ "$command" == "help" && ! -d "$CONFIG_DIR" ]]; then
        show_first_run_welcome
        exit $EXIT_SUCCESS
    fi

    # Parse command and options
    shift || true

    # Robot mode handles its own argument parsing
    if [[ "$command" == "robot" ]]; then
        # Initialize workflow variable for robot commands that need it
        WORKFLOW=""
        if [[ -f "$CONFIG_DIR/config.yaml" ]]; then
            WORKFLOW=$(get_config_value "default_workflow" "$CONFIG_DIR/config.yaml" 2>/dev/null || echo "")
        fi
        WORKFLOW="${WORKFLOW:-default}"
        if ! is_valid_workflow_name "$WORKFLOW"; then
            WORKFLOW="default"
        fi
        cmd_robot "$@"
        exit $?
    fi

    # Global options
    WORKFLOW=""
    INCLUDE_IMPL=false
    DRY_RUN=false
    RENDER=false
    COPY=false
    WAIT_MODE=false
    MANUAL_LOGIN=false
    KEEP_BROWSER=false
    SKIP_PREFLIGHT=false
    ENABLE_RETRY=true
    INTEGRATE_OUTPUT=""
    STATUS_HOURS="${APR_STATUS_HOURS:-72}"
    STATS_DETAILED=false
    STATS_JSON=false
    EXPORT_FORMAT=""
    EXPORT_ROUNDS=""
    EXPORT_SINCE=""
    BACKFILL_ALL=false
    BACKFILL_FORCE=false

    local positional_args=()

    while [[ $# -gt 0 ]]; do
        case $1 in
            -w|--workflow)
                if [[ -z "${2:-}" || "$2" == -* ]]; then
                    print_error "Option -w requires a workflow name"
                    exit $EXIT_USAGE_ERROR
                fi
                if ! is_valid_workflow_name "$2"; then
                    print_error "Invalid workflow name: $2"
                    print_info "Use only letters, numbers, dots, hyphens, underscores"
                    exit $EXIT_USAGE_ERROR
                fi
                WORKFLOW="$2"
                shift 2
                ;;
            -i|--include-impl)
                INCLUDE_IMPL=true
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -r|--render)
                RENDER=true
                shift
                ;;
            -c|--copy)
                COPY=true
                shift
                ;;
            --wait)
                WAIT_MODE=true
                shift
                ;;
            --login)
                MANUAL_LOGIN=true
                shift
                ;;
            --keep-browser)
                KEEP_BROWSER=true
                shift
                ;;
            --no-preflight)
                SKIP_PREFLIGHT=true
                shift
                ;;
            --retry)
                ENABLE_RETRY=true
                shift
                ;;
            --no-retry)
                ENABLE_RETRY=false
                shift
                ;;
            -o|--output)
                if [[ -z "${2:-}" || "$2" == -* ]]; then
                    print_error "Option --output requires a file path"
                    exit $EXIT_USAGE_ERROR
                fi
                INTEGRATE_OUTPUT="$2"
                shift 2
                ;;
            --hours)
                if [[ -z "${2:-}" || "$2" == -* ]]; then
                    print_error "Option --hours requires a number"
                    exit $EXIT_USAGE_ERROR
                fi
                if ! is_non_negative_int "$2"; then
                    print_error "Option --hours requires a non-negative integer"
                    exit $EXIT_USAGE_ERROR
                fi
                STATUS_HOURS="$2"
                shift 2
                ;;
            --detailed)
                STATS_DETAILED=true
                shift
                ;;
            --json)
                STATS_JSON=true
                shift
                ;;
            --export)
                if [[ -z "${2:-}" || "$2" == -* ]]; then
                    print_error "Option --export requires a format (json, csv, md)"
                    exit $EXIT_USAGE_ERROR
                fi
                EXPORT_FORMAT="$2"
                shift 2
                ;;
            --rounds)
                if [[ -z "${2:-}" || "$2" == -* ]]; then
                    print_error "Option --rounds requires a value (e.g. 3-5 or 1,3,5)"
                    exit $EXIT_USAGE_ERROR
                fi
                EXPORT_ROUNDS="$2"
                shift 2
                ;;
            --since)
                if [[ -z "${2:-}" || "$2" == -* ]]; then
                    print_error "Option --since requires an ISO date"
                    exit $EXIT_USAGE_ERROR
                fi
                EXPORT_SINCE="$2"
                shift 2
                ;;
            --all)
                BACKFILL_ALL=true
                shift
                ;;
            --force)
                BACKFILL_FORCE=true
                shift
                ;;
            -q|--quiet)
                QUIET_MODE=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            --version)
                echo "apr version $VERSION"
                exit $EXIT_SUCCESS
                ;;
            --help|-h)
                show_help
                exit $EXIT_SUCCESS
                ;;
            -*)
                print_error "Unknown option: $1"
                show_help
                exit $EXIT_USAGE_ERROR
                ;;
            *)
                positional_args+=("$1")
                shift
                ;;
        esac
    done

    # Set workflow default
    if [[ -z "$WORKFLOW" && -f "$CONFIG_DIR/config.yaml" ]]; then
        WORKFLOW=$(get_config_value "default_workflow" "$CONFIG_DIR/config.yaml")
    fi
    WORKFLOW="${WORKFLOW:-default}"
    if ! is_valid_workflow_name "$WORKFLOW"; then
        print_warning "Invalid default workflow name in $CONFIG_DIR/config.yaml; using 'default'"
        WORKFLOW="default"
    fi

    local command_is_round=false
    if is_non_negative_int "$command"; then
        command_is_round=true
    fi

    local oracle_required=false
    if [[ "$command_is_round" == "true" || "$command" == "run" ]]; then
        if [[ "$DRY_RUN" == "true" && "$RENDER" != "true" ]]; then
            oracle_required=false
        else
            oracle_required=true
        fi
    elif [[ "$command" == "status" || "$command" == "attach" ]]; then
        oracle_required=true
    fi

    if [[ "$oracle_required" == "true" ]]; then
        if ! check_oracle; then
            print_error "Oracle not found"
            print_info "Install with: npm install -g @steipete/oracle"
            if [[ -n "${APR_NO_NPX:-}" ]]; then
                print_info "APR_NO_NPX is set; unset it to allow npx fallback"
            else
                print_info "Or ensure npx is available"
            fi
            exit $EXIT_DEPENDENCY_ERROR
        fi
    else
        # Best-effort Oracle detection for dry-run output
        if [[ "$command_is_round" == "true" || "$command" == "run" ]]; then
            if ! check_oracle; then
                ORACLE_CMD=("oracle")
                [[ "$QUIET_MODE" != "true" ]] && print_warning "Oracle not found; dry run will use a placeholder command"
            fi
        fi
    fi

    # Execute command
    case "$command" in
        run)
            if [[ ${#positional_args[@]} -lt 1 ]]; then
                print_error "Round number required"
                print_info "Usage: apr run <round_number>"
                exit $EXIT_USAGE_ERROR
            fi
            if ! is_non_negative_int "${positional_args[0]}"; then
                print_error "Round number must be a non-negative integer"
                print_info "Usage: apr run <round_number>"
                exit $EXIT_USAGE_ERROR
            fi
            run_round "${positional_args[0]}"
            ;;
        setup)
            run_setup
            ;;
        status)
            show_status
            ;;
        attach)
            if [[ ${#positional_args[@]} -lt 1 ]]; then
                print_error "Session ID/slug required"
                print_info "Usage: apr attach <session>"
                exit $EXIT_USAGE_ERROR
            fi
            attach_session "${positional_args[0]}"
            ;;
        list)
            list_workflows
            ;;
        history)
            show_history
            ;;
        show)
            if [[ ${#positional_args[@]} -lt 1 ]]; then
                print_error "Round number required"
                print_info "Usage: apr show <round>"
                exit $EXIT_USAGE_ERROR
            fi
            if ! is_non_negative_int "${positional_args[0]}"; then
                print_error "Round number must be a non-negative integer"
                print_info "Usage: apr show <round>"
                exit $EXIT_USAGE_ERROR
            fi
            show_round "${positional_args[0]}"
            ;;
        diff)
            if [[ ${#positional_args[@]} -lt 1 ]]; then
                print_error "At least one round number required"
                print_info "Usage: apr diff <round> [round2]"
                print_info "  apr diff 5      # Compare round 5 with round 4"
                print_info "  apr diff 3 7    # Compare round 3 with round 7"
                exit $EXIT_USAGE_ERROR
            fi
            if ! is_non_negative_int "${positional_args[0]}"; then
                print_error "Round number must be a non-negative integer"
                exit $EXIT_USAGE_ERROR
            fi
            local round_b=""
            if [[ ${#positional_args[@]} -ge 2 ]]; then
                if ! is_non_negative_int "${positional_args[1]}"; then
                    print_error "Second round number must be a non-negative integer"
                    exit $EXIT_USAGE_ERROR
                fi
                round_b="${positional_args[1]}"
            fi
            diff_rounds "${positional_args[0]}" "$round_b"
            ;;
        integrate)
            if [[ ${#positional_args[@]} -lt 1 ]]; then
                print_error "Round number required"
                print_info "Usage: apr integrate <round> [--copy] [--output FILE]"
                exit $EXIT_USAGE_ERROR
            fi
            if ! is_non_negative_int "${positional_args[0]}"; then
                print_error "Round number must be a non-negative integer"
                exit $EXIT_USAGE_ERROR
            fi
            generate_integration "${positional_args[0]}"
            ;;
        stats)
            show_stats
            ;;
        dashboard)
            show_dashboard
            ;;
        backfill)
            cmd_backfill "${positional_args[@]}"
            ;;
        update)
            cmd_update
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            # If command looks like a number, treat as round number
            if is_non_negative_int "$command"; then
                run_round "$command"
            else
                print_error "Unknown command: $command"
                show_help
                exit $EXIT_USAGE_ERROR
            fi
            ;;
    esac
}

main "$@"
