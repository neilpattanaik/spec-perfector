#!/usr/bin/env bash
#
# apr - Automated Plan Reviser Pro (v1.1.0)
# Iterative specification refinement with GPT Pro Extended Reasoning via Oracle
#
# FEATURES:
#   - Beautiful gum-based terminal UI with graceful ANSI fallback
#   - Interactive workflow setup wizard
#   - Multi-round revision tracking with git integration
#   - GPT Pro 5.2 Extended Reasoning via Oracle browser automation
#   - Session monitoring and reattachment
#   - Configurable document bundles (README, spec, implementation)
#   - Automatic template generation and round management
#   - Self-update with checksum verification
#   - Daily update checking (opt-in)
#
# Usage:
#   apr [command] [options]
#
# Commands:
#   run <round>        Run a revision round (default command)
#   setup              Interactive workflow setup wizard
#   status             Check Oracle session status
#   attach <session>   Attach to a running/completed session
#   list               List all configured workflows
#   history            Show revision history for current workflow
#   update             Check for and install updates
#   help               Show help message
#
# Options:
#   -w, --workflow     Workflow name (default: from .apr/config.yaml or 'default')
#   -i, --include-impl Include implementation document
#   -d, --dry-run      Preview without sending to GPT Pro
#   -r, --render       Render bundle for manual paste
#   -c, --copy         Copy rendered bundle to clipboard
#   --wait             Wait for completion (blocking)
#   --login            Manual login mode (first-time setup)
#   --keep-browser     Keep browser open after completion
#   -q, --quiet        Minimal output (errors only)
#   --version          Show version
#
# Environment Variables:
#   APR_HOME           Data directory (default: ~/.local/share/apr)
#   APR_CACHE          Cache directory (default: ~/.cache/apr)
#   APR_CHECK_UPDATES  Enable daily update check (set to 1)
#   APR_NO_GUM         Disable gum even if available
#   NO_COLOR           Disable colors (accessibility)
#
# More info: https://github.com/Dicklesworthstone/automated_plan_reviser_pro

set -euo pipefail

VERSION="1.1.0"

# GitHub repository info for updates
readonly REPO_OWNER="Dicklesworthstone"
readonly REPO_NAME="automated_plan_reviser_pro"
readonly GITHUB_RAW="https://raw.githubusercontent.com"
readonly VERSION_URL="${GITHUB_RAW}/${REPO_OWNER}/${REPO_NAME}/main/VERSION"
readonly RELEASES_URL="https://github.com/${REPO_OWNER}/${REPO_NAME}/releases"

# -----------------------------------------------------------------------------
# Exit Codes (semantic, non-contiguous for future additions)
# -----------------------------------------------------------------------------
readonly EXIT_SUCCESS=0
# shellcheck disable=SC2034  # Reserved for future use
readonly EXIT_PARTIAL_FAILURE=1   # Some operations failed
readonly EXIT_USAGE_ERROR=2       # Bad arguments
readonly EXIT_DEPENDENCY_ERROR=3  # Missing Oracle, Node.js, etc.
readonly EXIT_CONFIG_ERROR=4      # Invalid config, missing files
readonly EXIT_NETWORK_ERROR=10    # Timeout, DNS, unreachable
readonly EXIT_UPDATE_ERROR=11     # Self-update failed

# -----------------------------------------------------------------------------
# Colors (conditional on TTY and NO_COLOR)
# -----------------------------------------------------------------------------
# Respect NO_COLOR environment variable for accessibility
# Check stderr (-t 2) since all log output goes there
if [[ -t 2 ]] && [[ -z "${NO_COLOR:-}" ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    CYAN='\033[0;36m'
    MAGENTA='\033[0;35m'
    WHITE='\033[1;37m'
    BOLD='\033[1m'
    DIM='\033[2m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' CYAN='' MAGENTA='' WHITE='' BOLD='' DIM='' NC=''
fi

# Gum availability flag
GUM_AVAILABLE=false

# Quiet mode flag
QUIET_MODE=false

# Configuration (XDG-compliant with overrides)
APR_HOME="${APR_HOME:-${XDG_DATA_HOME:-$HOME/.local/share}/apr}"
APR_CACHE="${APR_CACHE:-${XDG_CACHE_HOME:-$HOME/.cache}/apr}"
CONFIG_DIR=".apr"

# Oracle command (determined at runtime)
ORACLE_CMD=""

# -----------------------------------------------------------------------------
# Utility Functions
# -----------------------------------------------------------------------------

# Compare semantic versions. Returns 0 if $1 > $2
version_gt() {
    local v1="$1" v2="$2"
    if command -v sort &> /dev/null && printf '%s\n' "$v1" "$v2" | sort -V &>/dev/null; then
        [[ "$(printf '%s\n' "$v1" "$v2" | sort -V | tail -n1)" == "$v1" && "$v1" != "$v2" ]]
    else
        # Fallback to string comparison
        [[ "$v1" > "$v2" ]]
    fi
}

# Check if we can prompt the user (interactive terminal)
can_prompt() {
    [[ -t 0 && -t 2 && "$QUIET_MODE" != "true" ]]
}

# -----------------------------------------------------------------------------
# Update Checking (Opt-In)
# -----------------------------------------------------------------------------

check_for_updates() {
    # Only check if explicitly enabled
    [[ -z "${APR_CHECK_UPDATES:-}" ]] && return 0

    local check_file="${APR_HOME}/.last_update_check"
    local one_day=86400

    # Ensure directory exists
    mkdir -p "$APR_HOME" 2>/dev/null || true

    # Check if we already checked today
    if [[ -f "$check_file" ]]; then
        local last_check now
        last_check=$(cat "$check_file" 2>/dev/null || echo "0")
        now=$(date +%s)
        if (( now - last_check < one_day )); then
            return 0  # Skip - already checked today
        fi
    fi

    # Fetch remote version with short timeout
    local remote_version=""
    if command -v curl &> /dev/null; then
        remote_version=$(curl -fsSL --connect-timeout 2 --max-time 5 "$VERSION_URL" 2>/dev/null | tr -d '[:space:]') || true
    elif command -v wget &> /dev/null; then
        remote_version=$(wget -q --timeout=5 -O - "$VERSION_URL" 2>/dev/null | tr -d '[:space:]') || true
    fi

    # Update timestamp regardless of result
    date +%s > "$check_file" 2>/dev/null || true

    # Compare versions and notify if update available
    if [[ -n "$remote_version" && "$remote_version" != "$VERSION" ]]; then
        if version_gt "$remote_version" "$VERSION"; then
            echo -e "${YELLOW}[apr]${NC} Update available: ${VERSION} → ${remote_version}" >&2
            echo -e "${DIM}      Run 'apr update' to install${NC}" >&2
        fi
    fi
}

# -----------------------------------------------------------------------------
# Self-Update Command
# -----------------------------------------------------------------------------

cmd_update() {
    print_banner

    print_header "CHECKING FOR UPDATES"
    echo "" >&2

    # Fetch latest version
    print_info "Fetching latest version info..."
    local remote_version=""
    if command -v curl &> /dev/null; then
        remote_version=$(curl -fsSL --connect-timeout 5 --max-time 10 "$VERSION_URL" 2>/dev/null | tr -d '[:space:]') || true
    elif command -v wget &> /dev/null; then
        remote_version=$(wget -q --timeout=10 -O - "$VERSION_URL" 2>/dev/null | tr -d '[:space:]') || true
    fi

    if [[ -z "$remote_version" ]]; then
        print_error "Failed to check for updates (network error)"
        exit $EXIT_NETWORK_ERROR
    fi

    if [[ "$remote_version" == "$VERSION" ]]; then
        print_success "Already up to date (v${VERSION})"
        exit $EXIT_SUCCESS
    fi

    if ! version_gt "$remote_version" "$VERSION"; then
        print_info "Current version (v${VERSION}) is newer than remote (v${remote_version})"
        exit $EXIT_SUCCESS
    fi

    print_info "Update available: v${VERSION} → v${remote_version}"
    echo "" >&2

    # Prompt for confirmation if interactive
    if can_prompt; then
        if ! confirm "Install update?"; then
            print_info "Update cancelled"
            exit $EXIT_SUCCESS
        fi
    fi

    # Create temp directory
    local tmp_dir
    tmp_dir=$(mktemp -d 2>/dev/null || mktemp -d -t apr 2>/dev/null)
    if [[ -z "$tmp_dir" || ! -d "$tmp_dir" ]]; then
        print_error "Failed to create temp directory"
        exit $EXIT_UPDATE_ERROR
    fi

    # Download new version
    print_info "Downloading v${remote_version}..."
    local download_url="${RELEASES_URL}/download/v${remote_version}/apr"
    local checksum_url="${RELEASES_URL}/download/v${remote_version}/apr.sha256"

    if command -v curl &> /dev/null; then
        curl -fsSL "$download_url" -o "$tmp_dir/apr" 2>/dev/null || {
            # Fallback to main branch if no release
            curl -fsSL "${GITHUB_RAW}/${REPO_OWNER}/${REPO_NAME}/main/apr" -o "$tmp_dir/apr" 2>/dev/null
        }
    elif command -v wget &> /dev/null; then
        wget -q "$download_url" -O "$tmp_dir/apr" 2>/dev/null || {
            wget -q "${GITHUB_RAW}/${REPO_OWNER}/${REPO_NAME}/main/apr" -O "$tmp_dir/apr" 2>/dev/null
        }
    fi

    if [[ ! -s "$tmp_dir/apr" ]]; then
        print_error "Failed to download update"
        rm -rf "$tmp_dir"
        exit $EXIT_UPDATE_ERROR
    fi

    # Verify it's a bash script (security check)
    local first_line=""
    IFS= read -r first_line < "$tmp_dir/apr" 2>/dev/null || true
    if [[ "$first_line" != "#!/usr/bin/env bash" ]]; then
        print_error "Downloaded file is not a valid apr script"
        rm -rf "$tmp_dir"
        exit $EXIT_UPDATE_ERROR
    fi

    # Try to verify checksum (non-fatal if checksums not available)
    local expected_checksum=""
    if command -v curl &> /dev/null; then
        expected_checksum=$(curl -fsSL "$checksum_url" 2>/dev/null | tr -d '[:space:]') || true
    elif command -v wget &> /dev/null; then
        expected_checksum=$(wget -q -O - "$checksum_url" 2>/dev/null | tr -d '[:space:]') || true
    fi

    if [[ -n "$expected_checksum" ]]; then
        print_info "Verifying checksum..."
        local actual_checksum=""
        if command -v sha256sum &> /dev/null; then
            actual_checksum=$(sha256sum "$tmp_dir/apr" | cut -d' ' -f1)
        elif command -v shasum &> /dev/null; then
            actual_checksum=$(shasum -a 256 "$tmp_dir/apr" | cut -d' ' -f1)
        fi

        if [[ -n "$actual_checksum" && "$actual_checksum" != "$expected_checksum" ]]; then
            print_error "Checksum verification failed!"
            print_error "Expected: $expected_checksum"
            print_error "Got:      $actual_checksum"
            rm -rf "$tmp_dir"
            exit $EXIT_UPDATE_ERROR
        fi
        print_success "Checksum verified"
    else
        print_warning "Checksum not available (installing from main branch)"
    fi

    # Find where we're installed
    local script_path="${BASH_SOURCE[0]}"
    script_path=$(realpath "$script_path" 2>/dev/null || readlink -f "$script_path" 2>/dev/null || echo "$script_path")

    # Install update
    print_info "Installing to $script_path..."
    chmod +x "$tmp_dir/apr"

    if [[ -w "$script_path" ]]; then
        mv "$tmp_dir/apr" "$script_path"
    elif command -v sudo &> /dev/null; then
        sudo mv "$tmp_dir/apr" "$script_path"
    else
        print_error "Cannot write to $script_path (try running with sudo)"
        rm -rf "$tmp_dir"
        exit $EXIT_UPDATE_ERROR
    fi

    rm -rf "$tmp_dir"
    print_success "Updated to v${remote_version}!"
}

# -----------------------------------------------------------------------------
# Gum Installation & Detection
# -----------------------------------------------------------------------------

try_install_gum() {
    local os="unknown"
    case "$(uname -s)" in
        Darwin*) os="macos" ;;
        Linux*)  os="linux" ;;
    esac

    case "$os" in
        macos)
            if command -v brew &> /dev/null; then
                brew install gum &>/dev/null && return 0
            fi
            ;;
        linux)
            if command -v apt-get &> /dev/null; then
                (
                    sudo mkdir -p /etc/apt/keyrings 2>/dev/null
                    curl -fsSL https://repo.charm.sh/apt/gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/charm.gpg 2>/dev/null
                    echo "deb [signed-by=/etc/apt/keyrings/charm.gpg] https://repo.charm.sh/apt/ * *" | sudo tee /etc/apt/sources.list.d/charm.list >/dev/null
                    sudo apt-get update -qq && sudo apt-get install -y -qq gum
                ) &>/dev/null && return 0
            elif command -v dnf &> /dev/null; then
                (
                    echo '[charm]
name=Charm
baseurl=https://repo.charm.sh/yum/
enabled=1
gpgcheck=1
gpgkey=https://repo.charm.sh/yum/gpg.key' | sudo tee /etc/yum.repos.d/charm.repo >/dev/null
                    sudo dnf install -y gum
                ) &>/dev/null && return 0
            elif command -v pacman &> /dev/null; then
                sudo pacman -S --noconfirm gum &>/dev/null && return 0
            fi

            # Fallback: GitHub releases
            local arch
            arch=$(uname -m)
            case "$arch" in
                x86_64) arch="amd64" ;;
                aarch64|arm64) arch="arm64" ;;
                *) return 1 ;;
            esac

            local tmp_dir gum_version="0.14.5"
            tmp_dir=$(mktemp -d)
            local gum_url="https://github.com/charmbracelet/gum/releases/download/v${gum_version}/gum_${gum_version}_Linux_${arch}.tar.gz"

            (
                cd "$tmp_dir"
                curl -fsSL "$gum_url" -o gum.tar.gz
                tar -xzf gum.tar.gz
                sudo mv gum /usr/local/bin/gum 2>/dev/null || {
                    mkdir -p ~/.local/bin
                    mv gum ~/.local/bin/gum
                }
            ) &>/dev/null && rm -rf "$tmp_dir" && return 0

            rm -rf "$tmp_dir"
            ;;
    esac

    return 1
}

check_gum() {
    # Respect APR_NO_GUM
    [[ -n "${APR_NO_GUM:-}" ]] && return 1

    if command -v gum &> /dev/null; then
        GUM_AVAILABLE=true
        return 0
    fi

    # Only try to install if interactive and not in CI
    if [[ -t 1 && -z "${CI:-}" ]]; then
        if try_install_gum; then
            if [[ -x "${HOME}/.local/bin/gum" && ":$PATH:" != *":${HOME}/.local/bin:"* ]]; then
                export PATH="${HOME}/.local/bin:${PATH}"
            fi
            if command -v gum &> /dev/null; then
                GUM_AVAILABLE=true
                return 0
            fi
        fi
    fi

    return 1
}

# -----------------------------------------------------------------------------
# Oracle Detection
# -----------------------------------------------------------------------------

check_oracle() {
    if command -v oracle &> /dev/null; then
        ORACLE_CMD="oracle"
        return 0
    elif command -v npx &> /dev/null; then
        ORACLE_CMD="npx -y @steipete/oracle"
        return 0
    else
        return 1
    fi
}

# -----------------------------------------------------------------------------
# Styled Output Functions
# -----------------------------------------------------------------------------

print_banner() {
    [[ "$QUIET_MODE" == "true" ]] && return

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style \
            --border double \
            --border-foreground 212 \
            --padding "0 2" \
            --margin "1 0" \
            --bold \
            --foreground 212 \
            "  Automated Plan Reviser Pro v${VERSION}" \
            "  Iterative AI-Powered Spec Refinement" >&2
    else
        echo "" >&2
        echo -e "${BOLD}${MAGENTA}╔════════════════════════════════════════════════════════════╗${NC}" >&2
        echo -e "${BOLD}${MAGENTA}║${NC}  ${BOLD}${WHITE}  Automated Plan Reviser Pro${NC} ${DIM}v${VERSION}${NC}               ${BOLD}${MAGENTA}║${NC}" >&2
        echo -e "${BOLD}${MAGENTA}║${NC}  ${DIM}Iterative AI-Powered Spec Refinement${NC}                     ${BOLD}${MAGENTA}║${NC}" >&2
        echo -e "${BOLD}${MAGENTA}╚════════════════════════════════════════════════════════════╝${NC}" >&2
        echo "" >&2
    fi
}

print_header() {
    [[ "$QUIET_MODE" == "true" ]] && return
    local text="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 214 --bold "$text" >&2
    else
        echo -e "${BOLD}${YELLOW}$text${NC}" >&2
    fi
}

print_success() {
    [[ "$QUIET_MODE" == "true" ]] && return
    local text="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 82 "✓ $text" >&2
    else
        echo -e "${GREEN}✓${NC} $text" >&2
    fi
}

print_error() {
    local text="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 196 "✗ $text" >&2
    else
        echo -e "${RED}✗${NC} $text" >&2
    fi
}

print_warning() {
    local text="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 214 "⚠ $text" >&2
    else
        echo -e "${YELLOW}⚠${NC} $text" >&2
    fi
}

print_info() {
    [[ "$QUIET_MODE" == "true" ]] && return
    local text="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 39 "ℹ $text" >&2
    else
        echo -e "${CYAN}ℹ${NC} $text" >&2
    fi
}

print_dim() {
    [[ "$QUIET_MODE" == "true" ]] && return
    local text="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --faint "$text" >&2
    else
        echo -e "${DIM}$text${NC}" >&2
    fi
}

print_step() {
    [[ "$QUIET_MODE" == "true" ]] && return
    local step="$1"
    local total="$2"
    local text="$3"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        echo "$(gum style --foreground 212 --bold "[$step/$total]") $(gum style --faint "$text")" >&2
    else
        echo -e "${BOLD}${MAGENTA}[$step/$total]${NC} ${DIM}$text${NC}" >&2
    fi
}

spin() {
    local text="$1"
    shift
    if [[ "$GUM_AVAILABLE" == "true" && "$QUIET_MODE" != "true" ]]; then
        gum spin --spinner dot --title "$text" -- "$@"
    else
        [[ "$QUIET_MODE" != "true" ]] && echo -e "${CYAN}→${NC} $text" >&2
        "$@"
    fi
}

confirm() {
    local prompt="$1"
    local default="${2:-false}"

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum confirm "$prompt"
    else
        if ! can_prompt; then
            [[ "$default" == "true" ]]
            return $?
        fi

        local yn
        if [[ "$default" == "true" ]]; then
            read -rp "$prompt [Y/n] " yn
            case "${yn,,}" in
                n|no) return 1 ;;
                *) return 0 ;;
            esac
        else
            read -rp "$prompt [y/N] " yn
            case "${yn,,}" in
                y|yes) return 0 ;;
                *) return 1 ;;
            esac
        fi
    fi
}

choose() {
    local prompt="$1"
    shift
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum choose --header "$prompt" "$@"
    else
        echo "$prompt" >&2
        local i=1
        for opt in "$@"; do
            echo "  $i) $opt" >&2
            ((i++))
        done
        read -rp "Enter number: " choice
        local idx=1
        for opt in "$@"; do
            if [[ "$idx" == "$choice" ]]; then
                echo "$opt"
                return 0
            fi
            ((idx++))
        done
        echo "$1"  # default to first
    fi
}

input() {
    local prompt="$1"
    local default="${2:-}"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        if [[ -n "$default" ]]; then
            gum input --placeholder "$default" --prompt "$prompt: " --value "$default"
        else
            gum input --prompt "$prompt: "
        fi
    else
        if [[ -n "$default" ]]; then
            read -rp "$prompt [$default]: " value
            echo "${value:-$default}"
        else
            read -rp "$prompt: " value
            echo "$value"
        fi
    fi
}

file_picker() {
    local prompt="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum file --all --file --header "$prompt"
    else
        read -rp "$prompt (enter path): " path
        echo "$path"
    fi
}

# -----------------------------------------------------------------------------
# Configuration Management
# -----------------------------------------------------------------------------

ensure_config_dir() {
    mkdir -p "$CONFIG_DIR"
    mkdir -p "$CONFIG_DIR/workflows"
    mkdir -p "$CONFIG_DIR/rounds"
    mkdir -p "$CONFIG_DIR/templates"
}

load_config() {
    local workflow="${1:-default}"
    local config_path="$CONFIG_DIR/workflows/$workflow.yaml"

    if [[ ! -f "$config_path" ]]; then
        config_path="$CONFIG_DIR/config.yaml"
    fi

    if [[ ! -f "$config_path" ]]; then
        return 1
    fi

    echo "$config_path"
}

get_config_value() {
    local key="$1"
    local config_file="$2"
    # Handle both top-level and nested YAML keys (with optional leading whitespace)
    grep -E "^[[:space:]]*${key}:" "$config_file" 2>/dev/null | head -1 | cut -d':' -f2- | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
}

# -----------------------------------------------------------------------------
# Interactive Setup Wizard
# -----------------------------------------------------------------------------

run_setup() {
    print_banner

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style \
            --border rounded \
            --border-foreground 39 \
            --padding "1 2" \
            --margin "0 0 1 0" \
            "Welcome to the APR Setup Wizard!" \
            "" \
            "This will help you configure a new revision workflow." \
            "You'll specify your documents and review preferences." >&2
    else
        echo -e "${CYAN}╭────────────────────────────────────────────────────────────╮${NC}" >&2
        echo -e "${CYAN}│${NC}  ${BOLD}Welcome to the APR Setup Wizard!${NC}                         ${CYAN}│${NC}" >&2
        echo -e "${CYAN}│${NC}                                                            ${CYAN}│${NC}" >&2
        echo -e "${CYAN}│${NC}  This will help you configure a new revision workflow.     ${CYAN}│${NC}" >&2
        echo -e "${CYAN}│${NC}  You'll specify your documents and review preferences.     ${CYAN}│${NC}" >&2
        echo -e "${CYAN}╰────────────────────────────────────────────────────────────╯${NC}" >&2
    fi
    echo "" >&2

    ensure_config_dir

    # Step 1: Workflow name
    print_step 1 6 "Workflow name"
    local workflow_name
    workflow_name=$(input "Workflow name" "default")
    echo "" >&2

    # Step 2: Project description
    print_step 2 6 "Project description"
    local description
    description=$(input "Brief description" "Iterative specification refinement")
    echo "" >&2

    # Step 3: README/Overview document
    print_step 3 6 "README/Overview document"
    print_info "Select the main README or overview document"
    local readme_path
    readme_path=$(file_picker "Select README file")
    if [[ ! -f "$readme_path" ]]; then
        print_error "File not found: $readme_path"
        exit $EXIT_CONFIG_ERROR
    fi
    print_success "README: $readme_path"
    echo "" >&2

    # Step 4: Specification document
    print_step 4 6 "Specification document"
    print_info "Select the main specification/plan document"
    local spec_path
    spec_path=$(file_picker "Select specification file")
    if [[ ! -f "$spec_path" ]]; then
        print_error "File not found: $spec_path"
        exit $EXIT_CONFIG_ERROR
    fi
    print_success "Specification: $spec_path"
    echo "" >&2

    # Step 5: Implementation document (optional)
    print_step 5 6 "Implementation document (optional)"
    local impl_path=""
    if confirm "Do you have an implementation/reference document?"; then
        impl_path=$(file_picker "Select implementation file")
        if [[ -n "$impl_path" && ! -f "$impl_path" ]]; then
            print_warning "File not found: $impl_path (skipping)"
            impl_path=""
        else
            print_success "Implementation: $impl_path"
        fi
    fi
    echo "" >&2

    # Step 6: Review preferences
    print_step 6 6 "Review preferences"
    local model
    model=$(choose "Select GPT model for reviews:" \
        "5.2 Thinking (Extended Reasoning)" \
        "gpt-5.2-pro" \
        "gpt-5.2")

    # Extract model name
    case "$model" in
        "5.2 Thinking"*) model="5.2 Thinking" ;;
        *) ;;
    esac

    echo "" >&2

    # Create workflow directory and config
    local workflow_dir="$CONFIG_DIR/workflows"
    mkdir -p "$workflow_dir"
    mkdir -p "$CONFIG_DIR/rounds/$workflow_name"

    # Write config file
    cat > "$workflow_dir/$workflow_name.yaml" << EOF
# APR Workflow Configuration
# Generated: $(date -Iseconds)

name: $workflow_name
description: $description

documents:
  readme: $readme_path
  spec: $spec_path
  implementation: ${impl_path:-""}

oracle:
  model: "$model"
  thinking_time: heavy

rounds:
  output_dir: $CONFIG_DIR/rounds/$workflow_name

template: |
  First, read this README:

  \`\`\`
  <contents of README will be included by oracle>
  \`\`\`

  ---

  NOW: Carefully review this entire plan for me and come up with your best
  revisions in terms of better architecture, new features, changed features,
  etc. to make it better, more robust/reliable, more performant, more
  compelling/useful, etc.

  For each proposed change, give me your detailed analysis and
  rationale/justification for why it would make the project better along
  with the git-diff style change versus the original plan shown below:

  \`\`\`
  <contents of spec will be included by oracle>
  \`\`\`
EOF

    # Create default config if this is the first workflow
    if [[ ! -f "$CONFIG_DIR/config.yaml" ]]; then
        cat > "$CONFIG_DIR/config.yaml" << EOF
# APR Global Configuration
default_workflow: $workflow_name
EOF
    fi

    echo "" >&2
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style \
            --border rounded \
            --border-foreground 82 \
            --padding "1 2" \
            "✓ Workflow '$workflow_name' created successfully!" \
            "" \
            "To run your first revision round:" \
            "  apr run 1" \
            "" \
            "To run with implementation doc:" \
            "  apr run 1 --include-impl" >&2
    else
        echo -e "${GREEN}╭────────────────────────────────────────────────────────────╮${NC}" >&2
        echo -e "${GREEN}│${NC}  ${BOLD}✓ Workflow '$workflow_name' created successfully!${NC}" >&2
        echo -e "${GREEN}│${NC}" >&2
        echo -e "${GREEN}│${NC}  To run your first revision round:" >&2
        echo -e "${GREEN}│${NC}    ${CYAN}apr run 1${NC}" >&2
        echo -e "${GREEN}│${NC}" >&2
        echo -e "${GREEN}│${NC}  To run with implementation doc:" >&2
        echo -e "${GREEN}│${NC}    ${CYAN}apr run 1 --include-impl${NC}" >&2
        echo -e "${GREEN}╰────────────────────────────────────────────────────────────╯${NC}" >&2
    fi
}

# -----------------------------------------------------------------------------
# Run Revision Round
# -----------------------------------------------------------------------------

run_round() {
    local round_num="$1"
    local workflow="${WORKFLOW:-default}"
    local include_impl="${INCLUDE_IMPL:-false}"
    local dry_run="${DRY_RUN:-false}"
    local render="${RENDER:-false}"
    local copy="${COPY:-false}"
    local wait_mode="${WAIT_MODE:-false}"
    local manual_login="${MANUAL_LOGIN:-false}"
    local keep_browser="${KEEP_BROWSER:-false}"

    print_banner

    # Load workflow config
    local config_path="$CONFIG_DIR/workflows/$workflow.yaml"
    if [[ ! -f "$config_path" ]]; then
        print_error "Workflow '$workflow' not found"
        print_info "Run 'apr setup' to create a new workflow"
        exit $EXIT_CONFIG_ERROR
    fi

    # Parse config (simple grep-based for now)
    local readme_path spec_path impl_path model output_dir
    readme_path=$(get_config_value "readme" "$config_path" | tr -d '"')
    spec_path=$(get_config_value "spec" "$config_path" | tr -d '"')
    impl_path=$(get_config_value "implementation" "$config_path" | tr -d '"')
    model=$(get_config_value "model" "$config_path" | tr -d '"')
    output_dir=$(get_config_value "output_dir" "$config_path" | tr -d '"')

    # Validate files exist
    for f in "$readme_path" "$spec_path"; do
        if [[ ! -f "$f" ]]; then
            print_error "Required file not found: $f"
            exit $EXIT_CONFIG_ERROR
        fi
    done

    if [[ "$include_impl" == "true" && -n "$impl_path" && ! -f "$impl_path" ]]; then
        print_warning "Implementation file not found: $impl_path"
        include_impl=false
    fi

    # Display round info
    local slug="apr-${workflow}-round-${round_num}"
    local output_file="${output_dir}/round_${round_num}.md"

    if [[ "$include_impl" == "true" && -n "$impl_path" ]]; then
        slug="${slug}-with-impl"
    fi

    if [[ "$GUM_AVAILABLE" == "true" && "$QUIET_MODE" != "true" ]]; then
        gum style \
            --border rounded \
            --border-foreground 212 \
            --padding "1 2" \
            --margin "0 0 1 0" \
            "$(gum style --foreground 212 --bold "REVISION ROUND $round_num")" \
            "" \
            "$(gum style --foreground 39 "Workflow:") $workflow" \
            "$(gum style --foreground 39 "Model:") $model" \
            "$(gum style --foreground 39 "Include impl:") $include_impl" \
            "$(gum style --foreground 39 "Output:") $output_file" >&2
    elif [[ "$QUIET_MODE" != "true" ]]; then
        echo -e "${MAGENTA}╭────────────────────────────────────────────────────────────╮${NC}" >&2
        echo -e "${MAGENTA}│${NC}  ${BOLD}REVISION ROUND $round_num${NC}" >&2
        echo -e "${MAGENTA}│${NC}" >&2
        echo -e "${MAGENTA}│${NC}  ${CYAN}Workflow:${NC}     $workflow" >&2
        echo -e "${MAGENTA}│${NC}  ${CYAN}Model:${NC}        $model" >&2
        echo -e "${MAGENTA}│${NC}  ${CYAN}Include impl:${NC} $include_impl" >&2
        echo -e "${MAGENTA}│${NC}  ${CYAN}Output:${NC}       $output_file" >&2
        echo -e "${MAGENTA}╰────────────────────────────────────────────────────────────╯${NC}" >&2
    fi
    echo "" >&2

    # Build file arguments
    local file_args=(--file "$readme_path")
    if [[ "$include_impl" == "true" && -n "$impl_path" ]]; then
        file_args+=(--file "$impl_path")
    fi
    file_args+=(--file "$spec_path")

    # Build prompt
    local prompt
    prompt="First, read this README:

\`\`\`
<contents of README will be included by oracle>
\`\`\`

---
"

    if [[ "$include_impl" == "true" && -n "$impl_path" ]]; then
        prompt+="
And here is a document detailing the implementation; you should also keep
the implementation in mind as you think about the specification, since
ultimately the specification needs to be translated into code eventually!

\`\`\`
<contents of implementation will be included by oracle>
\`\`\`

---
"
    fi

    prompt+="
NOW: Carefully review this entire plan for me and come up with your best
revisions in terms of better architecture, new features, changed features,
etc. to make it better, more robust/reliable, more performant, more
compelling/useful, etc.

For each proposed change, give me your detailed analysis and
rationale/justification for why it would make the project better along
with the git-diff style change versus the original plan shown below:

\`\`\`
<contents of spec will be included by oracle>
\`\`\`
"

    # Dry run mode
    if [[ "$dry_run" == "true" ]]; then
        print_header "DRY RUN"
        echo "" >&2
        print_info "Would execute:"
        echo "" >&2
        echo "  $ORACLE_CMD --engine browser \\" >&2
        echo "    -m \"$model\" \\" >&2
        for f in "${file_args[@]}"; do
            echo "    $f \\" >&2
        done
        echo "    --slug \"$slug\" \\" >&2
        echo "    --write-output \"$output_file\" \\" >&2
        [[ "$manual_login" == "true" ]] && echo "    --browser-manual-login \\" >&2
        [[ "$keep_browser" == "true" ]] && echo "    --browser-keep-browser \\" >&2
        echo "    --notify --heartbeat 30 \\" >&2
        echo "    -p \"<prompt>\"" >&2
        exit $EXIT_SUCCESS
    fi

    # Render mode
    if [[ "$render" == "true" ]]; then
        local render_args=("--render")
        [[ "$copy" == "true" ]] && render_args+=("--copy")

        print_info "Rendering bundle for manual use..."
        $ORACLE_CMD "${file_args[@]}" "${render_args[@]}" -p "$prompt"
        exit $EXIT_SUCCESS
    fi

    # Build Oracle command
    local oracle_args=(
        --engine browser
        -m "$model"
        "${file_args[@]}"
        --slug "$slug"
        --write-output "$output_file"
        --files-report
        --notify
        --heartbeat 30
    )

    [[ "$manual_login" == "true" ]] && oracle_args+=(--browser-manual-login)
    [[ "$keep_browser" == "true" ]] && oracle_args+=(--browser-keep-browser)
    oracle_args+=(-p "$prompt")

    # Create output directory
    mkdir -p "$(dirname "$output_file")"

    # Execute
    print_info "Starting GPT Pro Extended Reasoning review..."
    print_dim "This may take 10-60 minutes depending on complexity."
    echo "" >&2

    if [[ "$manual_login" == "true" ]]; then
        print_warning "Manual login mode enabled"
        print_dim "Chrome will open - log into ChatGPT if prompted"
        print_dim "Your session will be saved for future runs"
        echo "" >&2
    fi

    if [[ "$wait_mode" == "true" ]]; then
        print_info "Running in foreground (--wait)..."
        echo "" >&2
        $ORACLE_CMD "${oracle_args[@]}"
        echo "" >&2
        print_success "Review complete!"
        print_info "Output saved to: $output_file"
    else
        $ORACLE_CMD "${oracle_args[@]}" &
        local oracle_pid=$!

        print_success "Oracle running in background (PID: $oracle_pid)"
        echo "" >&2

        if [[ "$GUM_AVAILABLE" == "true" && "$QUIET_MODE" != "true" ]]; then
            gum style \
                --border rounded \
                --border-foreground 39 \
                --padding "1 2" \
                "$(gum style --foreground 214 --bold "MONITORING COMMANDS")" \
                "" \
                "Check status:      $(gum style --foreground 82 "apr status")" \
                "Attach to session: $(gum style --foreground 82 "apr attach $slug")" \
                "View with output:  $(gum style --foreground 82 "$ORACLE_CMD session $slug --render")" >&2
        elif [[ "$QUIET_MODE" != "true" ]]; then
            echo -e "${CYAN}╭────────────────────────────────────────────────────────────╮${NC}" >&2
            echo -e "${CYAN}│${NC}  ${BOLD}MONITORING COMMANDS${NC}" >&2
            echo -e "${CYAN}├────────────────────────────────────────────────────────────┤${NC}" >&2
            echo -e "${CYAN}│${NC}  Check status:      ${GREEN}apr status${NC}" >&2
            echo -e "${CYAN}│${NC}  Attach to session: ${GREEN}apr attach $slug${NC}" >&2
            echo -e "${CYAN}│${NC}  View with output:  ${GREEN}$ORACLE_CMD session $slug --render${NC}" >&2
            echo -e "${CYAN}╰────────────────────────────────────────────────────────────╯${NC}" >&2
        fi

        echo "" >&2
        print_info "Output will be saved to: $output_file"
    fi

    echo "" >&2
    print_header "NEXT STEPS AFTER REVIEW COMPLETES"
    echo "1. Review the output in $output_file" >&2
    echo "2. Integrate feedback into your specification" >&2
    echo "3. Update README to reflect changes" >&2
    echo "4. Harmonize implementation doc (if applicable)" >&2
    echo "5. Commit and push" >&2
}

# -----------------------------------------------------------------------------
# Status & Session Management
# -----------------------------------------------------------------------------

show_status() {
    print_banner
    print_header "ORACLE SESSION STATUS"
    echo "" >&2
    $ORACLE_CMD status --hours 72
}

attach_session() {
    local session="$1"
    print_banner
    print_info "Attaching to session: $session"
    echo "" >&2
    $ORACLE_CMD session "$session" --render
}

# -----------------------------------------------------------------------------
# List Workflows
# -----------------------------------------------------------------------------

list_workflows() {
    print_banner
    print_header "CONFIGURED WORKFLOWS"
    echo "" >&2

    local workflow_dir="$CONFIG_DIR/workflows"
    if [[ ! -d "$workflow_dir" ]]; then
        print_warning "No workflows configured yet"
        print_info "Run 'apr setup' to create your first workflow"
        exit $EXIT_SUCCESS
    fi

    for config in "$workflow_dir"/*.yaml; do
        [[ -f "$config" ]] || continue
        local name desc
        name=$(basename "$config" .yaml)
        desc=$(get_config_value "description" "$config")

        if [[ "$GUM_AVAILABLE" == "true" ]]; then
            gum style --foreground 82 --bold "$name" >&2
            gum style --faint "  $desc" >&2
        else
            echo -e "  ${GREEN}${BOLD}$name${NC}" >&2
            echo -e "    ${DIM}$desc${NC}" >&2
        fi
        echo "" >&2
    done
}

# -----------------------------------------------------------------------------
# History
# -----------------------------------------------------------------------------

show_history() {
    local workflow="${WORKFLOW:-default}"
    print_banner
    print_header "REVISION HISTORY: $workflow"
    echo "" >&2

    local rounds_dir="$CONFIG_DIR/rounds/$workflow"
    if [[ ! -d "$rounds_dir" ]]; then
        print_warning "No rounds recorded for workflow '$workflow'"
        exit $EXIT_SUCCESS
    fi

    for round_file in "$rounds_dir"/round_*.md; do
        [[ -f "$round_file" ]] || continue
        local round_num size date
        round_num=$(basename "$round_file" .md | sed 's/round_//')
        size=$(du -h "$round_file" | cut -f1)
        date=$(stat -c %y "$round_file" 2>/dev/null || stat -f %Sm "$round_file" 2>/dev/null || echo "unknown")

        echo -e "  ${CYAN}Round $round_num${NC}  ${DIM}$size${NC}  ${DIM}$date${NC}" >&2
    done
}

# =============================================================================
# ROBOT MODE - JSON API for coding agents
# =============================================================================
#
# All robot mode output goes to stdout as valid JSON.
# Response envelope: { ok, code, data, hint?, meta: {v, ts} }
#
# Error codes: ok, not_configured, not_found, validation_failed, oracle_error
# =============================================================================

# Robot mode state
# shellcheck disable=SC2034  # State flag for helper functions
ROBOT_MODE=false
ROBOT_COMPACT=false

# ISO8601 timestamp
iso_timestamp() {
    date -u +"%Y-%m-%dT%H:%M:%SZ"
}

# Build JSON response using jq (required for robot mode)
# Usage: robot_json ok|false code data_json [hint]
robot_json() {
    local ok="$1"
    local code="$2"
    local data="$3"
    local hint="${4:-}"
    local ts
    ts=$(iso_timestamp)

    local result
    if [[ -n "$hint" ]]; then
        result=$(jq -nc \
            --argjson ok "$ok" \
            --arg code "$code" \
            --argjson data "$data" \
            --arg hint "$hint" \
            --arg v "$VERSION" \
            --arg ts "$ts" \
            '{ok: $ok, code: $code, data: $data, hint: $hint, meta: {v: $v, ts: $ts}}')
    else
        result=$(jq -nc \
            --argjson ok "$ok" \
            --arg code "$code" \
            --argjson data "$data" \
            --arg v "$VERSION" \
            --arg ts "$ts" \
            '{ok: $ok, code: $code, data: $data, meta: {v: $v, ts: $ts}}')
    fi

    if [[ "$ROBOT_COMPACT" == "true" ]]; then
        echo "$result"
    else
        echo "$result" | jq .
    fi
}

# Robot: Status - System overview
robot_status() {
    local configured=false
    local default_workflow=""
    local workflow_count=0
    local oracle_available=false
    local oracle_method=""
    local workflows_json="[]"

    # Check configuration
    if [[ -d "$CONFIG_DIR" && -f "$CONFIG_DIR/config.yaml" ]]; then
        configured=true
        default_workflow=$(get_config_value "default_workflow" "$CONFIG_DIR/config.yaml" 2>/dev/null || echo "")
    fi

    # Count and list workflows
    if [[ -d "$CONFIG_DIR/workflows" ]]; then
        workflow_count=$(find "$CONFIG_DIR/workflows" -name "*.yaml" 2>/dev/null | wc -l | tr -d ' ')
        local wf_list=()
        for wf in "$CONFIG_DIR/workflows"/*.yaml; do
            [[ -f "$wf" ]] || continue
            wf_list+=("\"$(basename "$wf" .yaml)\"")
        done
        if [[ ${#wf_list[@]} -gt 0 ]]; then
            workflows_json="[$(IFS=,; echo "${wf_list[*]}")]"
        fi
    fi

    # Check Oracle
    if command -v oracle &>/dev/null; then
        oracle_available=true
        oracle_method="global"
    elif command -v npx &>/dev/null; then
        oracle_available=true
        oracle_method="npx"
    fi

    # Build data object with jq
    local data
    data=$(jq -nc \
        --argjson configured "$configured" \
        --arg default_workflow "$default_workflow" \
        --argjson workflow_count "$workflow_count" \
        --argjson workflows "$workflows_json" \
        --argjson oracle_available "$oracle_available" \
        --arg oracle_method "$oracle_method" \
        --arg config_dir "$CONFIG_DIR" \
        --arg apr_home "$APR_HOME" \
        '{
            configured: $configured,
            default_workflow: $default_workflow,
            workflow_count: $workflow_count,
            workflows: $workflows,
            oracle_available: $oracle_available,
            oracle_method: $oracle_method,
            config_dir: $config_dir,
            apr_home: $apr_home
        }')

    local hint=""
    if [[ "$configured" == "false" ]]; then
        hint="Run 'apr robot init' to initialize, then 'apr setup' to create workflow"
    elif [[ "$oracle_available" == "false" ]]; then
        hint="Install Oracle: npm install -g @steipete/oracle"
    fi

    robot_json true "ok" "$data" "$hint"
}

# Robot: Workflows - List all workflows
robot_workflows() {
    if [[ ! -d "$CONFIG_DIR/workflows" ]]; then
        robot_json false "not_configured" '{"workflows":[]}' "Run 'apr robot init' then 'apr setup'"
        return 1
    fi

    local items=()
    for wf in "$CONFIG_DIR/workflows"/*.yaml; do
        [[ -f "$wf" ]] || continue
        local name desc
        name=$(basename "$wf" .yaml)
        desc=$(get_config_value "description" "$wf" 2>/dev/null || echo "")
        items+=("$(jq -nc --arg name "$name" --arg desc "$desc" '{name: $name, description: $desc}')")
    done

    local workflows_json="[]"
    if [[ ${#items[@]} -gt 0 ]]; then
        workflows_json=$(printf '%s\n' "${items[@]}" | jq -sc .)
    fi

    robot_json true "ok" "{\"workflows\":$workflows_json}"
}

# Robot: Init - Initialize .apr directory
robot_init() {
    if [[ -d "$CONFIG_DIR" ]]; then
        robot_json true "ok" '{"created":false,"existed":true}' "Already initialized"
        return 0
    fi

    # Handle errors gracefully to ensure JSON output
    if ! mkdir -p "$CONFIG_DIR/workflows" "$CONFIG_DIR/rounds" "$CONFIG_DIR/templates" 2>/dev/null; then
        robot_json false "init_failed" "$(jq -nc --arg dir "$CONFIG_DIR" '{directory: $dir}')" "Failed to create directory: $CONFIG_DIR"
        return 1
    fi

    if ! echo "default_workflow: default" > "$CONFIG_DIR/config.yaml" 2>/dev/null; then
        robot_json false "init_failed" '{"reason":"config_write"}' "Failed to write config file"
        return 1
    fi

    robot_json true "ok" '{"created":true,"existed":false}'
}

# Robot: Validate - Pre-run validation
robot_validate() {
    local round_num="${1:-}"
    local errors=()
    local warnings=()

    if [[ -z "$round_num" ]]; then
        errors+=("Round number required")
    fi

    if [[ ! -d "$CONFIG_DIR" ]]; then
        errors+=("Not initialized - run 'apr robot init'")
    fi

    local wf_file="$CONFIG_DIR/workflows/${WORKFLOW}.yaml"
    if [[ ! -f "$wf_file" ]]; then
        errors+=("Workflow '$WORKFLOW' not found")
    else
        # Check required documents exist
        local readme spec
        readme=$(get_config_value "readme" "$wf_file" 2>/dev/null || echo "")
        spec=$(get_config_value "spec" "$wf_file" 2>/dev/null || echo "")

        if [[ -n "$readme" && ! -f "$readme" ]]; then
            errors+=("README not found: $readme")
        fi
        if [[ -n "$spec" && ! -f "$spec" ]]; then
            errors+=("Spec not found: $spec")
        fi
    fi

    # Check Oracle
    if ! command -v oracle &>/dev/null && ! command -v npx &>/dev/null; then
        errors+=("Oracle not available")
    fi

    # Check for previous round if not round 1
    if [[ "$round_num" =~ ^[0-9]+$ ]] && [[ "$round_num" -gt 1 ]]; then
        local prev=$((round_num - 1))
        local prev_file="$CONFIG_DIR/rounds/$WORKFLOW/round_${prev}.md"
        if [[ ! -f "$prev_file" ]]; then
            warnings+=("Previous round $prev not found - starting fresh?")
        fi
    fi

    local valid=true
    [[ ${#errors[@]} -gt 0 ]] && valid=false

    local errors_json warnings_json
    errors_json=$(printf '%s\n' "${errors[@]:-}" | jq -Rsc 'split("\n") | map(select(length > 0))')
    warnings_json=$(printf '%s\n' "${warnings[@]:-}" | jq -Rsc 'split("\n") | map(select(length > 0))')

    local data
    data=$(jq -nc \
        --argjson valid "$valid" \
        --argjson errors "$errors_json" \
        --argjson warnings "$warnings_json" \
        --arg workflow "$WORKFLOW" \
        --arg round "$round_num" \
        '{valid: $valid, errors: $errors, warnings: $warnings, workflow: $workflow, round: $round}')

    if [[ "$valid" == "true" ]]; then
        robot_json true "ok" "$data"
    else
        robot_json false "validation_failed" "$data" "Fix errors before running"
        return 1
    fi
}

# Robot: Help - Show robot mode help in JSON
robot_help() {
    local data
    data=$(jq -nc '{
        description: "Robot mode for coding agents - JSON interface to APR",
        usage: "apr robot <command> [args] [--compact]",
        commands: {
            status: "System overview (config, workflows, oracle)",
            workflows: "List all workflows",
            init: "Initialize .apr directory",
            validate: "Pre-run validation (apr robot validate <round>)",
            help: "This help"
        },
        options: {
            "-w, --workflow": "Workflow name",
            "--compact": "Minified JSON output"
        },
        examples: [
            "apr robot status",
            "apr robot workflows",
            "apr robot validate 1 -w myspec"
        ]
    }')

    robot_json true "ok" "$data"
}

# Robot: Main dispatcher
cmd_robot() {
    # shellcheck disable=SC2034  # State flag for helper functions
    ROBOT_MODE=true

    # Check jq is available (required for robot mode)
    if ! command -v jq &>/dev/null; then
        # Output to stdout (not stderr) for consistency with robot mode JSON output
        echo '{"ok":false,"code":"dependency_missing","data":{},"hint":"Robot mode requires jq. Install with: apt install jq","meta":{"v":"'"$VERSION"'"}}'
        exit $EXIT_DEPENDENCY_ERROR
    fi

    # Parse robot-specific options
    local robot_cmd=""
    local robot_args=()

    while [[ $# -gt 0 ]]; do
        case $1 in
            --compact)
                ROBOT_COMPACT=true
                shift
                ;;
            -w|--workflow)
                if [[ -z "${2:-}" ]]; then
                    robot_json false "missing_argument" '{"option":"-w"}' "Option -w requires a workflow name"
                    exit $EXIT_USAGE_ERROR
                fi
                WORKFLOW="$2"
                shift 2
                ;;
            -*)
                # Use jq for proper escaping of user input in JSON
                robot_json false "invalid_option" "$(jq -nc --arg opt "$1" '{option: $opt}')" "Unknown option: $1"
                exit $EXIT_USAGE_ERROR
                ;;
            *)
                if [[ -z "$robot_cmd" ]]; then
                    robot_cmd="$1"
                else
                    robot_args+=("$1")
                fi
                shift
                ;;
        esac
    done

    robot_cmd="${robot_cmd:-help}"

    case "$robot_cmd" in
        status)
            robot_status
            ;;
        workflows)
            robot_workflows
            ;;
        init)
            robot_init
            ;;
        validate)
            robot_validate "${robot_args[0]:-}"
            ;;
        help|--help|-h)
            robot_help
            ;;
        *)
            # Use jq for proper escaping of user input in JSON
            robot_json false "unknown_command" "$(jq -nc --arg cmd "$robot_cmd" '{command: $cmd}')" "Unknown command. Try 'apr robot help'"
            exit $EXIT_USAGE_ERROR
            ;;
    esac
}

# -----------------------------------------------------------------------------
# Help
# -----------------------------------------------------------------------------

show_help() {
    check_gum || true
    print_banner

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 214 --bold "DESCRIPTION" >&2
        gum style --padding "0 2" "Automated Plan Reviser Pro automates iterative specification" >&2
        gum style --padding "0 2" "refinement using GPT Pro Extended Reasoning via Oracle." >&2
        echo "" >&2

        gum style --foreground 214 --bold "SYNOPSIS" >&2
        echo "  apr [command] [options]" >&2
        echo "" >&2

        gum style --foreground 214 --bold "COMMANDS" >&2
        gum style --foreground 39 "  Core Workflow" >&2
        echo "    $(gum style --foreground 82 'run <round>')        Run a revision round" >&2
        echo "    $(gum style --foreground 82 'setup')              Interactive workflow setup wizard" >&2
        echo "    $(gum style --foreground 82 'status')             Check Oracle session status" >&2
        echo "    $(gum style --foreground 82 'attach <session>')   Attach to running/completed session" >&2
        echo "" >&2
        gum style --foreground 39 "  Management" >&2
        echo "    $(gum style --foreground 82 'list')               List configured workflows" >&2
        echo "    $(gum style --foreground 82 'history')            Show revision history" >&2
        echo "    $(gum style --foreground 82 'update')             Check for and install updates" >&2
        echo "    $(gum style --foreground 82 'help')               Show this help message" >&2
        echo "" >&2
        gum style --foreground 39 "  Automation" >&2
        echo "    $(gum style --foreground 82 'robot')              Machine-friendly CLI for coding agents" >&2
        echo "" >&2

        gum style --foreground 214 --bold "OPTIONS" >&2
        gum style --faint "  -w, --workflow NAME  Workflow to use (default: from config)" >&2
        gum style --faint "  -i, --include-impl   Include implementation document" >&2
        gum style --faint "  -d, --dry-run        Preview without sending to GPT Pro" >&2
        gum style --faint "  -r, --render         Render bundle for manual paste" >&2
        gum style --faint "  -c, --copy           Copy rendered bundle to clipboard" >&2
        gum style --faint "  --wait               Wait for completion (blocking)" >&2
        gum style --faint "  --login              Manual login mode (first-time setup)" >&2
        gum style --faint "  --keep-browser       Keep browser open after completion" >&2
        gum style --faint "  -q, --quiet          Minimal output (errors only)" >&2
        gum style --faint "  --version            Show version" >&2
        echo "" >&2

        gum style --foreground 214 --bold "ENVIRONMENT VARIABLES" >&2
        gum style --faint "  APR_HOME             Data directory (~/.local/share/apr)" >&2
        gum style --faint "  APR_CACHE            Cache directory (~/.cache/apr)" >&2
        gum style --faint "  APR_CHECK_UPDATES    Enable daily update checking (set to 1)" >&2
        gum style --faint "  APR_NO_GUM           Disable gum even if available" >&2
        gum style --faint "  NO_COLOR             Disable colored output" >&2
        echo "" >&2

        gum style --foreground 214 --bold "EXAMPLES" >&2
        gum style --foreground 39 "  # First-time setup" >&2
        echo "  apr setup" >&2
        echo "" >&2
        gum style --foreground 39 "  # Run revision round 1" >&2
        echo "  apr run 1" >&2
        echo "" >&2
        gum style --foreground 39 "  # Run with implementation doc" >&2
        echo "  apr run 2 --include-impl" >&2
        echo "" >&2
        gum style --foreground 39 "  # First run with manual login" >&2
        echo "  apr run 1 --login --wait" >&2
        echo "" >&2
        gum style --foreground 39 "  # Check session status" >&2
        echo "  apr status" >&2
        echo "" >&2
        gum style --foreground 39 "  # Robot mode (for coding agents)" >&2
        echo "  apr robot status" >&2
        echo "" >&2

        gum style --foreground 214 --bold "EXIT CODES" >&2
        gum style --faint "  0   Success" >&2
        gum style --faint "  1   Partial failure" >&2
        gum style --faint "  2   Usage error (bad arguments)" >&2
        gum style --faint "  3   Dependency error (missing Oracle)" >&2
        gum style --faint "  4   Configuration error" >&2
        gum style --faint "  10  Network error" >&2
        gum style --faint "  11  Update error" >&2
        echo "" >&2

        gum style --foreground 39 "More info: https://github.com/${REPO_OWNER}/${REPO_NAME}" >&2
    else
        echo -e "${BOLD}${YELLOW}DESCRIPTION${NC}" >&2
        echo "  Automated Plan Reviser Pro automates iterative specification" >&2
        echo "  refinement using GPT Pro Extended Reasoning via Oracle." >&2
        echo "" >&2
        echo -e "${BOLD}${YELLOW}SYNOPSIS${NC}" >&2
        echo "  apr [command] [options]" >&2
        echo "" >&2
        echo -e "${BOLD}${YELLOW}COMMANDS${NC}" >&2
        echo -e "  ${CYAN}Core Workflow${NC}" >&2
        echo -e "    ${GREEN}run <round>${NC}        Run a revision round" >&2
        echo -e "    ${GREEN}setup${NC}              Interactive workflow setup wizard" >&2
        echo -e "    ${GREEN}status${NC}             Check Oracle session status" >&2
        echo -e "    ${GREEN}attach <session>${NC}   Attach to running/completed session" >&2
        echo "" >&2
        echo -e "  ${CYAN}Management${NC}" >&2
        echo -e "    ${GREEN}list${NC}               List configured workflows" >&2
        echo -e "    ${GREEN}history${NC}            Show revision history" >&2
        echo -e "    ${GREEN}update${NC}             Check for and install updates" >&2
        echo -e "    ${GREEN}help${NC}               Show this help message" >&2
        echo "" >&2
        echo -e "  ${CYAN}Automation${NC}" >&2
        echo -e "    ${GREEN}robot${NC}              Machine-friendly CLI for coding agents" >&2
        echo "" >&2
        echo -e "${BOLD}${YELLOW}OPTIONS${NC}" >&2
        echo "  -w, --workflow NAME  Workflow to use (default: from config)" >&2
        echo "  -i, --include-impl   Include implementation document" >&2
        echo "  -d, --dry-run        Preview without sending to GPT Pro" >&2
        echo "  -r, --render         Render bundle for manual paste" >&2
        echo "  -c, --copy           Copy rendered bundle to clipboard" >&2
        echo "  --wait               Wait for completion (blocking)" >&2
        echo "  --login              Manual login mode (first-time setup)" >&2
        echo "  --keep-browser       Keep browser open after completion" >&2
        echo "  -q, --quiet          Minimal output (errors only)" >&2
        echo "  --version            Show version" >&2
        echo "" >&2
        echo -e "${BOLD}${YELLOW}ENVIRONMENT VARIABLES${NC}" >&2
        echo "  APR_HOME             Data directory (~/.local/share/apr)" >&2
        echo "  APR_CACHE            Cache directory (~/.cache/apr)" >&2
        echo "  APR_CHECK_UPDATES    Enable daily update checking (set to 1)" >&2
        echo "  APR_NO_GUM           Disable gum even if available" >&2
        echo "  NO_COLOR             Disable colored output" >&2
        echo "" >&2
        echo -e "${BOLD}${YELLOW}EXAMPLES${NC}" >&2
        echo "  apr setup                    # First-time setup" >&2
        echo "  apr run 1                    # Run revision round 1" >&2
        echo "  apr run 2 --include-impl     # Include implementation doc" >&2
        echo "  apr run 1 --login --wait     # First run with manual login" >&2
        echo "  apr status                   # Check session status" >&2
        echo "  apr robot status             # Robot mode (for agents)" >&2
        echo "" >&2
        echo -e "${BOLD}${YELLOW}EXIT CODES${NC}" >&2
        echo "  0   Success" >&2
        echo "  1   Partial failure" >&2
        echo "  2   Usage error (bad arguments)" >&2
        echo "  3   Dependency error (missing Oracle)" >&2
        echo "  4   Configuration error" >&2
        echo "  10  Network error" >&2
        echo "  11  Update error" >&2
        echo "" >&2
        echo -e "${CYAN}More info: https://github.com/${REPO_OWNER}/${REPO_NAME}${NC}" >&2
    fi
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    # Handle --version and --help early (before gum/oracle checks)
    if [[ "${1:-}" == "--version" || "${1:-}" == "-V" ]]; then
        echo "apr version $VERSION"
        exit $EXIT_SUCCESS
    fi

    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        check_gum || true
        show_help
        exit $EXIT_SUCCESS
    fi

    # Check for quiet flag early
    for arg in "$@"; do
        if [[ "$arg" == "-q" || "$arg" == "--quiet" ]]; then
            QUIET_MODE=true
            break
        fi
    done

    # Initialize gum
    check_gum || true

    # Check for updates (opt-in, non-blocking)
    check_for_updates

    # Check Oracle availability (not needed for some commands)
    local command="${1:-help}"
    if [[ "$command" != "help" && "$command" != "update" && "$command" != "robot" && "$command" != "--help" && "$command" != "-h" ]]; then
        if ! check_oracle; then
            print_error "Oracle not found"
            print_info "Install with: npm install -g @steipete/oracle"
            print_info "Or ensure npx is available"
            exit $EXIT_DEPENDENCY_ERROR
        fi
    fi

    # Parse command and options
    shift || true

    # Robot mode handles its own argument parsing
    if [[ "$command" == "robot" ]]; then
        # Initialize workflow variable for robot commands that need it
        WORKFLOW=""
        if [[ -f "$CONFIG_DIR/config.yaml" ]]; then
            WORKFLOW=$(get_config_value "default_workflow" "$CONFIG_DIR/config.yaml" 2>/dev/null || echo "")
        fi
        WORKFLOW="${WORKFLOW:-default}"
        cmd_robot "$@"
        exit $?
    fi

    # Global options
    WORKFLOW=""
    INCLUDE_IMPL=false
    DRY_RUN=false
    RENDER=false
    COPY=false
    WAIT_MODE=false
    MANUAL_LOGIN=false
    KEEP_BROWSER=false

    local positional_args=()

    while [[ $# -gt 0 ]]; do
        case $1 in
            -w|--workflow)
                WORKFLOW="$2"
                shift 2
                ;;
            -i|--include-impl)
                INCLUDE_IMPL=true
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -r|--render)
                RENDER=true
                shift
                ;;
            -c|--copy)
                COPY=true
                shift
                ;;
            --wait)
                WAIT_MODE=true
                shift
                ;;
            --login)
                MANUAL_LOGIN=true
                shift
                ;;
            --keep-browser)
                KEEP_BROWSER=true
                shift
                ;;
            -q|--quiet)
                QUIET_MODE=true
                shift
                ;;
            --version)
                echo "apr version $VERSION"
                exit $EXIT_SUCCESS
                ;;
            --help|-h)
                show_help
                exit $EXIT_SUCCESS
                ;;
            -*)
                print_error "Unknown option: $1"
                show_help
                exit $EXIT_USAGE_ERROR
                ;;
            *)
                positional_args+=("$1")
                shift
                ;;
        esac
    done

    # Set workflow default
    if [[ -z "$WORKFLOW" && -f "$CONFIG_DIR/config.yaml" ]]; then
        WORKFLOW=$(get_config_value "default_workflow" "$CONFIG_DIR/config.yaml")
    fi
    WORKFLOW="${WORKFLOW:-default}"

    # Execute command
    case "$command" in
        run)
            if [[ ${#positional_args[@]} -lt 1 ]]; then
                print_error "Round number required"
                print_info "Usage: apr run <round_number>"
                exit $EXIT_USAGE_ERROR
            fi
            run_round "${positional_args[0]}"
            ;;
        setup)
            run_setup
            ;;
        status)
            show_status
            ;;
        attach)
            if [[ ${#positional_args[@]} -lt 1 ]]; then
                print_error "Session ID/slug required"
                print_info "Usage: apr attach <session>"
                exit $EXIT_USAGE_ERROR
            fi
            attach_session "${positional_args[0]}"
            ;;
        list)
            list_workflows
            ;;
        history)
            show_history
            ;;
        update)
            cmd_update
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            # If command looks like a number, treat as round number
            if [[ "$command" =~ ^[0-9]+$ ]]; then
                run_round "$command"
            else
                print_error "Unknown command: $command"
                show_help
                exit $EXIT_USAGE_ERROR
            fi
            ;;
    esac
}

main "$@"
